//  TODO this should not be using the default charset because it's not an input and might introduce flakiness 
//  TODO Make this work with pending elements
/*  * The DSL for declaring plugins to inject into an included build. * * TODO: Plugins need to be located in this build's buildSrc. * * @since 4.6  */
//  TODO some kind of context of why the method was attached (e.g. which plugin declared the rule)   TODO some kind of instance state for the method (might be the same as context above) 
//  TODO: Need to track version/implementation of symbol strip tool. 
// TODO move to base-services once the ProgressLogger dependency is removed
//  Return a dummy implementation of this as creating a real hasher drags ~20 more services   along with it, and a hasher isn't actually needed on the worker process side at the moment. 
//  there's a risk, for some methods, that the hash is always   recomputed but it won't be worse than before 
//  This isn't quite right. Should close the worker classpath cache once we're finished with the worker processes. This may be before the end of this build   or they may be used across multiple builds 
//  TODO Need a better mechanism to wire tasks into lifecycle 
//  TODO:Cedric This is not quite right. We assume that if we are asking for a specific binary, then we resolve to the assembly instead   of the jar, but it should be somehow parameterized 
//  Ensure that at most one action that may have access to the mutable state of the build runs at a given time   TODO - move this to a better home and reuse 
//  TODO(ew): inject BuildOperationIdentifierRegistry instead of static use
//  TODO:HH Use managed views for this, only applied when the respective language is applied
//  TODO: There has to be a simpler way to do this.   We want to create a buildable filecollection based on a filtered view of selected source directory sets 
//  Passing null for sha1 - TODO - consider using the etag which is an MD5 hash of the file (when less than 5Gb) 
//  TODO:ADAM - need to do this earlier 
//  TODO - exception when no default type 
//  Don't force evaluation of rules here, let the task container do what it needs to
//  result is a scala.util.Either   right is a Seq of files that were generated   left is routes compilation errors   TODO: It might be nice to pass along these errors in some way 
//  TODO deleteOnExit won't clean up non-empty directories (and it leaks memory for long-running processes). 
/*  * Meta-info about a Java component. * * TODO - this is some legacy stuff, to be merged into other component interfaces  */
//  TODO: Need to track version/implementation of symbol extraction tool. 
//  TODO: This should be modeled differently, perhaps as a dependency on the implementation configuration 
//  This is not super nice, but dependencies are created through reflection, for decoration   and assume a constructor with 3 arguments (Group, Name, Version) which is suitable for   most cases. We could create an empty attribute set directly in the AbstractDependencyImpl,   but then it wouldn't be mutable. Therefore we proceed with "late injection" of the attributes 
//  TODO(ew): Consider whether this belongs in Console or here
//  TODO - should split this up, so that the inputs are attached to an object that represents the binary, which is then later used to configure the link/assemble tasks 
//  we need to wrap this into a loop, because there's always a risk   that the method, which is weakly referenced, has been collected   in between the creation time and now 
//  TODO(daniel): Should support in a better way multi file invocation. 
//  It's true right now that this is always coming from the TestKit, but might not be in the future.
//  TODO - don't select again here, as the selection is already performed to select the toolchain 
//  TODO include link to documentation giving more explanation of what's going on here. 
//  TODO: Migrate this away from here 
//  This looks ugly, very ugly, but that is apparently what Ant does itself 
//  TODO - should be incremental 
//  TODO: this is terrible 
//  TODO: This should actually be a Routable message with a single handler,   but we need some way to correlate a given request with a specific response channel 
//  TODO - this is pretty nasty, look at avoiding using a time bomb stub here 
// TODO:rbo Change the parameter type to `Transformer<String, @Nullable String>` once we migrate to Java 8
// TODO - make this work on windows  originalIn.close();
//  TODO better exception type 
//  Note: This would be better housed in a scope that encapsulated the tree of Gradle objects. 
/*  * A {@link org.gradle.api.file.ConfigurableFileCollection} that can be used as a task input property. Caches the matching set of files during task execution, and discards the result after task execution. * * TODO - disallow further changes to this collection once task has started * TODO - keep the file entries to snapshot later, to avoid a stat on each file during snapshot  */
//  TODO This class, DefaultBuildOperationQueue and ExecutionPlan have many of the same   behavior and concerns - we should look for a way to generalize this pattern. 
// TODO:instant-execution: remove this 
//  Can only set once: should really be part of the constructor   Can only set once: should really be part of the constructor
//  This isn't quite right, as we may lose precision when converting to a double 
//  decimalFormat is not thread safe - synchronize access to the instance 
//  TODO - wire this stuff in properly 
//  TODO:ADAM - need to cleanup completion too, if not used 
//  TODO: Need to check for proper type/cast 
//  TODO - should use a resolver so that this method is consistent with Project.uri(string) 
//  TODO wolfs - schedule fingerprinting separately, it can be done without having the project lock 
//  Note: don't actually remove this in 6.0, the deprecation is here to encourage people to use ObjectFactory instead. Just remove the overload and the nag and leave the method here
//  todo: consider multithreading/multiprocess issues   Teamcity has the concept of a "wave" of messages   where each thread/process uses a unique wave id 
//  TODO - reduce duplication with Swift binary 
// TODO: move bootclasspath to platform 
//  TODO: This should be modeled as a source set 
//  TODO - the project model should be reachable from ProjectState without another lookup 
//  TODO: Locate this tool from a tool provider   hide main symbol 
//  TODO: This prefix shouldn't be hardcoded 
//  TODO:LPTR Remove projection for reference node   This shouldn't be needed, but if there's no actual value referenced, model report can only   show the type of the node if we do this for now. It should use the schema instead to find   the type of the property node instead. 
//  TODO:ADAM - switch the logging back on. Need to make sending messages from daemon to client async wrt log event generation                  LOGGER.debug("Ignoring failure to extract throwable stack trace.", ignored); 
//  TODO: Need failure handling, e.g., cannot clone repository 
//  TODO This should actually compare a SortedSet 
//  TODO - validate that it's a valid model path 
//  The visual C++ tools use the path to find other executables   TODO:ADAM - restrict this to the specific path for the target tool 
//  TODO:pm Move this to WARN level once we fixed maven-publish, see gradle/gradle#1662 
//  TODO:ADAM - This isn't quite right   MB: I think ^ refers to the first capable classloader loading the class. This could be different   from the loader which originally loaded it, which could pose equality and lifecycle issues. 
//  TODO:Cedric This is an approximation: when a component wants to compile against the assembly of   a library (not the jar), then we should give it the *stubbed classes* instead of the raw classes. However:   - there's no such thing as a "stubbed classes assembly"   - for performance reasons only the classes that belong to the API are stubbed, so we would miss the classes that do not belong to the API   So this makes the UsageKind.API misleading (should this be COMPILE?).
/*  * An _immutable_ view of the variant of a component. * * TODO - this should replace or merge into VariantResolveMetadata, OutgoingVariant, ConfigurationMetadata  */
//  because it's a capability conflict resolution, there is only one candidate per module identifier   so we can be lenient wrt the version number used in the descriptor, which helps whenever the user   used the convenience "notation" method 
//  TODO improve lookup by reusing AvailableJavaHomes testfixture   for now we play it safe and just return false; 
//  TODO - should decorate 
//  TODO removing this stuff from the store should be handled through some sort of decoration 
//  TODO: fix the way we work out which exception is important: TaskExecutionException is not always the most helpful
//  TODO: do we need any factories here? 
//  TODO:HH This should be moved back into languageNative project 
//  TODO make this work with pending elements
//  TODO: Ultimately, this should be some kind of 3rd party dependency that's visible to dependency management.
//  TODO: These should come from somewhere else, probably 
//  TODO: This should become smarter and move into the compiler infrastructure instead     of the task, similar to how the other native languages are done.     For now, this does a rudimentary incremental build analysis by looking at     which files changed . 
/*  * A minimal resolver, which does not use any native services. Used during bootstrap only. You should generally use {@link FileResolver} instead. * * TODO - share more stuff with AbstractFileResolver.  */
// a list instance is needed here, as org.gradle.internal.snapshot.ValueSnapshotter.processValue() does not support  serializing Iterators directly 
//  TODO:lptr this should be added only if the scan plugin is applied, but SnapshotTaskInputsOperationIntegrationTest   TODO:lptr expects it to be added also when the build cache is enabled (but not the scan plugin) 
//  TODO: We should set this for macOS, but this currently breaks XCTest support for Swift   when Swift depends on C++ libraries built by Gradle. 
//  TODO:lptr When we drop Java 8 support we can switch to using ClassLoader.getName() instead of storing our own
//  TODO: Provide an abstraction for accessing resources within the same module (maven-metadata, directory listing, etc)   That way we can avoid passing `ivyPatterns` and `artifactPatterns` around everywhere 
//  TODO:instant-execution - remove kotlin predicate after updating the wrapper
/*      * Closes the tooling API, releasing all resources. Blocks until completed.     *     * <p>May attempt to expire some or all daemons started by this tooling API client. The exact behaviour here is implementation-specific and not guaranteed.     * The expiration is best effort only. This method may return before the daemons have stopped.</p>     *     * <p>Note: this is not yet part of the public tooling API yet.</p>     *     * TODO - need to model this as a long running operation, and allow stdout, stderr and progress listener to be supplied.     * TODO - need to define exceptions.     * TODO - no further operations are allowed after this has been called     * TODO - cancel current operations or block until complete     * TODO - introduce a 'tooling API client' interface and move this method there      */
//  TODO LD use something more stable than a cast here 
//  TODO: Make this more intelligent by matching the attributes of the runtime usage on the variant identities 
//  Workaround for backwards compatibility. Previously, this case would unintentionally cause the method to be invoked on the owner   continue below 
//  TODO - capitalise the target name in the task name   TODO - don't create a launch target for a library 
/*      * Create binaries for test suites. TODO: This should really be a @ComponentBinaries rule, but at this point we have no clue what the concrete binary type is, so everything has to be duplicated in     * specific plugins. See usages for example.      */
//  Did we already consider it as an output after the previous execution? 
//  TODO: To get rid of this, we need a `FunctionalSourceSet` instance here, and that's surprisingly difficult to get. 
//  TODO generic model related super exception? 
//  TODO - this should work for any build, rather than just an included build 
//  Workaround for https://issues.gradle.org/browse/GRADLE-2625 
//  TODO: We basically don't support copying custom Javadoc options
//  TODO: This exists because we detect all available native tool chains on a system (clang, gcc, swiftc, msvc).     Many of our old tests assume that available tool chains can compile many/most languages, so they do not try to   restrict the required set of tool chains.     The swiftc tool chain can build _only_ Swift, so tests that expect to use the swiftc tool chain properly annotate   their requirements with ToolChainRequirement.SWIFTC (or a version-specific requirement).     Our multi-test runner is smart enough to disable tests that do not meet the test's requirements, but since many   of the old tests do not have requirements, we assume the tests require a "C" like tool chain (GCC, Clang, MSVC).     In the future... we want to go back to old tests and annotate them with tool chains requirements.
// we don't handle Variables at the moment because users didn't request it yet  and it would probably push us to add support in the tooling api to retrieve the variable mappings.
//  TODO: VersionSelector should be more descriptive, so it can be directly translated 
//  TODO:LPTR Should be a content-less @InputDirectory 
//  TODO Need a smarter way to map usage to artifact classifier 
/*      * TODO once source compatibility is raised to 1.7, this should be rewritten using the java.nio.FileSystem API,     * which can deal with jars and folders the same way instead of duplicating code.      */
//  TODO - better exception 
// TODO SF this method accepts Closure instance as parameter but does not work correctly for it 
//  TODO find a better way to present this information in the error message   Attempt to mimic Gradle nested exception output 
//  TODO: we should really find a better solution for this...   maybe we could use a FilterReader instead of a FilterInputStream? 
//  not fully accurate but a sensible fallback   see http://stackoverflow.com/questions/1288102/how-do-i-detect-whether-the-file-system-is-case-sensitive 
//  TODO not sure if we can clean up the generics here and do less unchecked casting 
//  TODO - deal with more than one header dir, e.g. generated public headers 
//  TODO: projectDependency should be transformed based on defaultProject (and other context) elsewhere. 
//  TODO: This will have to be changed when we support setting credentials directly on the authentication 
//  TODO: this is an approximation as we know swift currently supports only 64-bit runtimes - eventually, we'll want to query for this 
// TODO the async work tracker should wait for children of an operation to finish first.  It should not be necessary to call it here. 
//  TODO - reduce duplication with C++ binary 
//  TODO: This should be more specific to just the tasks that create the class files? 
//  TODO: we aren't considering the filter 
//  Send a end-of-line. This is a workaround to convince the console that the cursor is at the start of the line to avoid indenting the next line of text that is displayed   It would be better for the console to listen for stuff read from stdin that would also be echoed to the output and update its state based on this
//  TODO - exception when type cannot be created 
//  TODO bind with the sourceCompatibility property   TODO link to runtime configuration ? 
//  We track this as an input since the Scala compiler output may depend on it.   TODO: This should be replaced by a property in the Scala toolchain as soon as we model these. 
//  TODO:LPTR Instead of the first view property, we should figure out these parameters from the actual property 
//  TODO - DSL documentation? 
//  TODO We can probably now support more versions with `strictly` but we'll need more test coverage 
//  TODO: move this to ObjectFactory 
// there are some exceptions attached to the suite. Let's make sure they are reported to the user.  this may happen for example when suite initialisation fails and no tests are executed 
//  TODO: Does a static library have runtime elements? 
//  TODO:LPTR This ignores changes to Project.buildDir after model node has been created
//  TODO:LPTR Remove projection for reference node   This shouldn't be needed, but if there's no actual value referenced, model report can only   show the type of the node if we do this for now. It should use the schema instead to find 
//  TODO: what if this errors? 
//  TODO:instant-execution - remove this 
//  TODO: remove this special case 
//  Need to move those implicit JVM args that contain a space to the Gradle command-line (if possible)   Note that this isn't strictly correct as some system properties can only be set on JVM start up.   Should change the implementation to deal with these properly
//  Doesn't really make sense 
// "type-only model reference of type '%s'%s is ambiguous as multiple model elements are available for this type:%n  %s (created by %s)%n  %s (created by %s)",
//  TODO - exceptions thrown here should point to some extensive documentation on the concept of class rule sources 
// (SF) this is a workaround until this story is completed. I'm hardcoding setting the idle timeout to be max X mins.  this way we avoid potential runaway daemons that steal resources on linux and break builds on windows.
//  TODO - move this to a base plugin   Setup the dependency on the main binary   This should all be replaced by a single dependency that points at some "testable" variants of the main binary 
//  TODO - should we support this?   Adds a void $propName(Object value) method that simply delegates to the converting setter method 
//  TODO: Send a message to workers to change their log level rather than stopping 
//  TODO - this should also be using the decorating instantiator but cannot for backwards compatibility 
//  TODO - visit the contents of this collection instead.   This is just a super simple implementation for now 
//  TODO We should get rid of this reflection (will need to reimplement the parser to act on the metadata directly) 
//  TODO: do we want to keep using SourceDirectorySet in the new API?   would feel more natural if dirs could be added directly to LanguageSourceSet   could also think about extending SourceDirectorySet 
//  TODO:LPTR This should be removed once BinaryContainer is a ModelMap   We need to also implement all the interfaces of the delegate type because otherwise   BinaryContainer won't recognize managed binaries as BinarySpecInternal
//  todo - stream serialised value to file   todo - handle hash collisions (properly, this time)   todo - don't store null links to child blocks in leaf index blocks   todo - align block boundaries   todo - thread safety control   todo - merge small values into a single data block   todo - discard when file corrupt   todo - include data directly in index entry when serializer can guarantee small fixed sized data   todo - free list leaks disk space   todo - merge adjacent free blocks   todo - use more efficient lookup for free block with nearest size 
//  This is a workaround for https://issues.gradle.org/browse/GRADLE-3324.   Somehow the ArrayList 'result' in `org.sonatype.aether.impl.internal.Utils#sortMetadataGeneratorFactories` ends up   being a list of nulls on windows and IBM's 1.6 JDK.
//  TODO - binaries aren't an input to this rule, they're an input to the action 
/*  * Specifies how to build and where to place a native executable file. * * <p>TODO:HH resolve naming conflict with existing NativeExecutableSpec</p>  */
//  This should be replaced by some stronger modelling and made open rather than hardcoding a set of source languages here 
//  We moved the API back into internal, so this isn't really correct. 
//  TODO - refactor this action out so it can be unit tested 
//  TODO - error if there are unknowns? 
//  TODO:ADAM - using a UUID means we create a ClassLoader hierarchy for each daemon process we talk to. Instead, use the spec to decide whether to reuse a ClassLoader 
//  TODO - should supply and check for the same parameters as passed to reserveNewClient() 
//  TODO - should use the _install_ task for an executable 
//  Implement this if you need to specify individual toolchains via "org.gradle.integtest.versions" 
//  todo annotate as required 
//  TODO: CC cannot enable this assertion because moduleSource is not serialized, so doesn't appear in the deserialized form  assert metadata.equals(forceRead);
//  todo An ExcludeRule is a value object but we don't enforce immutability for DefaultExcludeRule as strong as we   should (we expose the Map). We should provide a better API for ExcludeRule (I don't want to use unmodifiable Map).   As soon as DefaultExcludeRule is truly immutable, we don't need to create a new instance of DefaultExcludeRule.
//  production code should handle these exceptions more gracefully 
//  TODO - this isn't quite right 
//  The isEmpty check is not required, might look innocent, but Guava's performance bad for an empty immutable list   because it still creates an inner class for an iterator, which delegates to an Array iterator, which does... nothing.   so just adding this check has a significant impact because most components do not declare any capability 
//  TODO we are relying on the registration having established these links, we should be checking
// TODO SF add quotes to both formats (there will be *lots* of tests failing so I'm not sure if it is worth it). 
//  TODO(ew): Consider whether this belongs in BuildProgressArea or here 
//  TODO It would be better if these were added via a separate managed view, rather than hard coded. 
//  Shouldn't really be here. Currently this goal is used by {@link #bindAllReferences} which also expects the subject to be bound 
//  This doesn't work.   It used to because at the bottom of the hierarchy chain the object implemented methodMissing().   However, our normal “decorated” classes do not do this so it is not realistic. 
//  TODO: This returns the wrong public type for domain objects   created with the eager APIs or added directly to the container.   This can leak internal types.   We do not currently keep track of the type used when creating   a domain object (via create) or the type of the container when   a domain object is added directly (via add). 
//  TODO:LPTR What happens when the property has multiple accessors in the same role but with different type? 
//  TODO: Should not be ignoring DEPENDENCY_ATTRIBUTE modifications after resolve
// TODO this should be a container of platforms 
/*      * TODO - hack to avoid classloading issues. We should use org.gradle.util.TextUtil     *     * Currently we can't use it reliably because it causes CNF issues with cross version integration tests running against tooling api < 1.3.      */
//  TODO: else, verify that the build definition is the same 
//  TODO - make this lazy 
//  TODO should this take Object? 
//  Used by the Kotlin-dsl base plugin   TODO - remove this 
//  TODO - sources is not actual an input to binaries, it's an input to each binary
//  TODO - mix in Groovy support using bytecode decoration instead   TODO - validate closure parameters to check they are within bounds
// TODO this class attempts to mimic the behavior of the output of mvn help:effective-pom  instead of this class we should walk the maven project object model (instead of parsing the xml!)
/*      * we have a name foo.bar and an import foo.foo. This means foo.bar is possibly     * foo.foo.bar rather than foo.bar. This means to cut at the dot in foo.bar and     * foo for import      */
//  TODO - remove this once the above is removed 
//  This is a workaround for https://github.com/gradle/gradle-private/issues/1690
/*  * TODO only here because Kotlin DSL uses this. Please remove once that is fixed.  */
//  Hold the lock while creating the connection. Not generally good form.   In this instance, blocks other threads from creating the connection at the same time 
//  Currently retains strong references to types that are not loaded using a VisitableURLClassLoader   This is fine for JVM types, but a problem when a custom ClassLoader is used (which should probably be deprecated instead of supported) 
// We might fail hard here on the assumption that something weird happened to the daemon.  However, since we haven't yet started running the build, we can recover by just trying again... 
//  todo: improve configuration of reports 
//  TODO: Fix tests that rely on this being set before we process arguments like this...
//  TODO: turn into Set? 
/*             There's a potential problem here in that DisconnectableInputStream reads from input in the background.            This won't automatically stop when the process is over. Therefore, if input is not closed then this thread            will run forever. It would be better to ensure that this thread stops when the process does.          */
//  TODO - need to do a better job of routing messages when there are multiple endpoints. This is just going to forward all queued messages to the first   waiting endpoint, even if there are multiple waiting to do work 
//  Create test suite component   TODO - Reuse logic from Swift*Plugin   TODO - component name and extension name aren't the same   TODO - should use `src/xctest/swift` as the convention?   Add the test suite and extension 
//  Do not use this. It's here because some of the services this type needs are not easily accessed in certain cases and will be removed ay some point. Use one of the other methods instead 
//  TODO: should validate that clazz is of a non parameterized type
//  Workaround for when the task is given an input file that doesn't exist
//  TODO: Figure out how to get rid of origin scope id in snapshot outputs step 
//  get rid of the ivy [] token, as [ ] are not valid URI characters 
//  todo remove this property once configuration can handle normal file system dependencies 
//  This piece of ugliness copies the JAXP (ie XML API) provider, if any, from the system ClassLoader. Here's why:     1. When looking for a provider, JAXP looks for a service resource in the context ClassLoader, which is our isolated ClassLoader. If our classpath above does not contain a      provider, this returns null. If it does contain a provider, JAXP extracts the classname from the service resource.   2. If not found, JAXP looks for a service resource in the system ClassLoader. This happens to include all the application classes specified on the classpath. If the application      classpath does not contain a provider, this returns null. If it does contain a provider, JAXP extracts the implementation classname from the service resource.   3. If not found, JAXP uses a default classname   4. JAXP attempts to load the provider using the context ClassLoader. which is our isolated ClassLoader. This is fine if the classname came from step 1 or 3. It blows up if the      classname came from step 2.     So, as a workaround, locate and make visible XML parser classes from the system classloader in our isolated ClassLoader.     Note that in practise, this is only triggered when running in our tests 
//  TODO Will be implemented without hard-coded access to `$GRADLE_USER_HOME/gradle.properties` for 5.1 in #6084 
//  TODO: This hard-codes the assumption of a 'compile' configuration on the external module   Instead, we should be creating an API configuration for each resolved module 
//  This is a legacy quirk.   Scans use this to determine that progress logging is indicating start/finish of tasks.   This can be removed in Gradle 5.0 (along with the concept of a “logging category” of an operation) 
//  See the comment in #taskCompleted, above, for why this is here and why this is a problem 
//  TODO: CC the special casing of virtual platform should go away if we can implement   disambiguation of variants for a _single_ component 
//  TODO This should actually extend from the api dependencies, but since Swift currently   requires all dependencies to be treated like api dependencies (with transitivity) we just   use the implementation dependencies here.  See https://bugs.swift.org/browse/SR-1393. 
//  TODO: Replace this with `JvmAssembly` once that type is public 
// this is not very nice might be good enough until we get rid of ResolvedConfiguration and friends  avoid traversing the graph causing the full ResolvedDependency graph to be loaded for the most typical scenario 
//  Not implemented - not yet required. Please implement if required 
//  TODO: Extract the non-filesystem parts of the FileSystemChangeWaiter into a separate interface   This isn't really tied to file system watching, we just need another type of waiter. 
/*  * TODO: This class sources Gradle metadata files, but there's no corresponding ModuleComponentResolveMetadata for this metadata yet. * Because of this, we will generate an empty instance (either a Ivy or Maven) based on the repository type.  */
//  TODO - this isn't correct, assumes that a side effect is to add the element 
//  TODO: `classes` should be a little more tied to the classesDirs for a SourceSet so every plugin   doesn't need to do this. 
//  This is really not cool, but we cannot rely on `readAttributes` because it will   THROW AN EXCEPTION if the file is missing, which is really incredibly slow just   to determine if a file exists or not. 
// TODO: use Twirl library instead? 
//  DO NOT USE THIS CONSTRUCTOR DIRECTLY   It's only there for backwards compatibility with the Nebula plugin 
//  Groovy does something very strange here.   For some reason (probably because the class is Java), it won't employ any dynamism.   Even implementing invokeMethod at the Java level has no effect. 
//  TODO: We should see if we can go back to using HttpClient again.   This implementation is borrowed from the Apache HttpClient project   https://github.com/apache/httpclient/blob/4.2.2/httpclient/src/main/java/org/apache/http/conn/ssl/SSLSocketFactory.java#L246-L354
//  TODO Change to Set? 
//  TODO(daniel): Should support in a better way multi file invocation.   Override this method to have multi file invocation 
//  @Todo: refactor this task configuration to extend a copy task and use replace tokens 
//  TODO:REUSE Refactor after removing reuse   This is horrendously bad.   We need to set the platform, _before_ the @Defaults rules of NativeBinaryRules assign the toolchain.   We can't just assign the toolchain here because the initializer would be closing over the toolchain which is not reusable, and this breaks model reuse.   So here we are just closing over the safely reusable things and then using proper dependencies for the tool chain registry.   Unfortunately, we can't do it in the create action because that would fire _after_ @Defaults rules.   We have to use a @Defaults rule to assign the tool chain because it needs to be there in user @Mutate rules   Or at least, the file locations do so that they can be tweaked.   LD - 5/6/14 
//  Check enum equality without checking loading ClassLoader.   There is a slight risk that two versions of the same enum class are compared,   (that's why classloaders are used in equality checks), but checking both name   and ordinal should make this very unlikely. 
// TODO version - could be different from main artifact's version 
//  Should really be a parameter to the 'withContent' methods or baked into the accessor 
//  TODO - error messages   TODO - display names for this container and the Provider implementations 
//  Not subtypes as we don't know whether they are immutable or not 
//  TODO: This check should really be done in the compiler process 
//  Forced dependencies are only supported for enforced platforms, so it is currently hardcoded.   Should we want to add this as a first class concept to Gradle metadata, then it should be available on the component variant   metadata as well. 
//  TODO Remove this attempt to guess packaging from artifacts. Packaging should come from component, or be explicitly set.
//  Was it created during execution? 
//  TODO: Deprecate and eventually prevent these mutations when already resolved
//  TODO: this doesn't quite guarantee immutability, because the source may be holding closures that are doing god knows what 
//  TODO: Get rid of destinationDirectory entirely and replace it with a   collection of link outputs 
//  TODO: Migrate this to the worker API once the FileSystem and FileOperations services can be injected
//  TODO:LPTR Have the paths of the projects serve as @Input maybe? 
//  This could be handled, just not implemented yet 
//  TODO: Wrong, using the full classpath of the application
//  this is not very beautiful but at some point we will   get rid of ArchiveOutputStreamFactory in favor of the writable Resource 
// this if is a bit cheesy but 1-letter classname surely means a generic type and the warning will be useless 
/*      * Creates an instance of the given task type without invoking its constructors. This is used to recreate a task instance from the instant execution cache.     *     * TODO:instant-execution - review this      */
//  TODO - this selection should happen per target platform
//  TODO Resolve the JavaPlatform and ScalaPlatform from their PlatformResolvers, rather than instantiating directly
//  TODO should include some context on what the rule was trying to do (create vs. mutate) 
//  TODO: Get this from somewhere else? 
//  This is here to trigger creation of the ShutdownCoordinator. Could do this in a nicer way 
//  TODO:pm Move this to RunAsBuildOperationBuildActionRunner when BuildOperationWorkerRegistry scope is changed 
// TODO - outputEventListener and buildStandardInput are per-build settings  so down the road we should refactor the code accordingly and potentially attach them to BuildActionParameters 
/*  * Exposes methods for those properties whose value is a closure. * * TODO: use composition instead of inheritance  */
//  Platform specific arguments   TODO: Need to lazily configure compile task
//  If this occurs while running gradle or running integration tests, it is indicative of a problem.   If this occurs while running unit tests, then either use the NativeServicesTestFixture or the '@UsesNativeServices' annotation. 
//  Ugly, but there are a few places where we need to instantiate a JavaDebugOptions and a regular ObjectFactory service   is not available. 
// TODO adding the parent project first because the converter needs it this way ATM. This is oversimplified.  the converter should not depend on the order of reactor projects.  we should add coverage for nested multi-project builds with multiple parents. 
//  there's a possibility that this listener is called concurrently with   the build finished listener. If the message happens to be a graceful expire   one, then there's a large risk that we create a deadlock, because we're trying to   remove the same listener from 2 different notifications. To avoid this, we just   set the reference to null, which says that we're taking care of removing the listener
//  TODO: Need to track version/implementation of ar tool.
//  This is copied from Ant (see org.apache.tools.ant.util.FileUtils.tryHardToDelete).   It mentions that there is a bug in the Windows JDK impls that this is a valid   workaround for. I've been unable to find a definitive reference to this bug.   The thinking is that if this is good enough for Ant, it's good enough for us.
//  TODO Change this to only add SWIFT_API artifacts and instead parse modulemaps to discover compile task inputs
//  Rough implementation to get something to work 
//  TODO: remove these special cases
//  TODO: This is not a great paradigm for creating a temporary directory.   See http://guava-libraries.googlecode.com/svn/tags/release08/javadoc/com/google/common/io/Files.html#createTempDir%28%29 for an alternative. 
//  TODO: This should be part of the cached result? 
//  Implementation is currently dumb, can be made smarter 
//  TODO:RBO Clarify what it means and what's possible to do with it.   TODO:RBO E.g. Can the return value always be used to resolve back to the identified component? If so, how?   TODO:RBO Wouldn't it be better to define a proper type for project/model paths?
//  TODO: This can throw a NPE: will need an identifier for a variant without an owning component 
//  This implementation is broken. It does not consider include and exclude patterns 
//  TODO LJA Using the root as the NodeState here is a bit of a cheat, investigate if we can track the proper NodeState 
/*      * Produces an ArtifactIdentifier for this artifact (it's not actually an identifier - just a bucket of attributes).     * TODO:ADAM - remove this      */
//  TODO - property order needs to be deterministic across JVM invocations, i.e. sort the properties by name
//  TODO - this will leave invalid types in the cache when it fails 
//  Should repositories be able to participate in incremental?   At the least, they may be able to express themselves as output files   They *might* have input files and other dependencies as well though   Inputs: The credentials they need may be expressed in a file   Dependencies: Can't think of a case here 
//  TODO - have to do much better here 
//  TODO: these should be moved off to a separate type
//  TODO:LPTR This should be @Defaults @Each PlayApplicationBinarySpecInternal 
//  TODO we should refactor this to general, compatibility mapping solution, as we have it for model loading. See HasCompatibilityMapping class. 
//  This is a heuristic, more than truth: it is possible that the 2 long hashs   are identical AND that the sizes of collections are identical, but it's   extremely unlikely (never happened on test cases even on large dependency graph) 
//  failing, seems to be that set method override doesn't work for iterables - GRADLE-2097  assertThat(call("{ bean, list -> bean.things(list) }", bean, new LinkedList<Object>()), nullValue());  assertThat(bean.getThings().size(), equalTo(0)); 
//  TODO: This isn't quite right. We're leaking the _implementation_ type here.  But for tasks, this is usually right. 
//  TODO return a richer data structure that provides meta data about how the source was found, for use is diagnostics 
//  The configuration has been used in a resolution, and it is an error for build logic to change any dependencies,   exclude rules or parent configurations (values that will affect the resolved graph).
//  This method is sometimes called directly (i.e. not via an operation executor).   In these cases, the context is null. 
//  TODO:LPTR What is with the "metaClass" property here? 
//  TODO this doesn't belong here, that java plugin should add an extension to this guy with this 
//  need to make this better 
//  TODO: maybe we need to allow additional dirs like SourceSetOutput does   (esp. for backwards compatibility). Wonder if it's still necessary to distinguish   between classes and resources dirs, instead of just maintaining a collection of dirs.   As far as generated resources are concerned, it might be better to model   them as an additional (Buildable) ResourceSet.
//  workaround for bug in TestNG 6.2 (apparently fixed in some 6.3.x): listener is notified twice per event 
//  TODO: This isn't correct. This means that we've detected a cycle while determining the execution plan, but the graph walker did not find one.   https://github.com/gradle/gradle/issues/2293 
//  TODO:Cedric The following validation should in theory happen in its own rule, but it is not possible now because   there's no way to iterate on the map as subject of a `@Validate` rule without Gradle thinking you're trying to mutate it
// TODO: Simplify this class by busting it up into a locator for legacy SDKs and locator(s) for Windows 8 kits 
//  TODO - this is all terribly lame. We need some proper reporting here (which means implementing Reporting). 
//  TODO - implement these cases 
//  TODO(daniel): Swift compiler should extends from an abstraction of NativeCompiler (most of it applies to SwiftCompiler) 
//  TODO: should use target platform to make this decision 
//  TODO There should be a more explicit way to execute an action against existing services 
//  Have an unprocessed/new selector for this module. Need to re-select the target version. 
//  TODO: Assets should probably be a source set too 
// TODO:instant-execution - use the class generator instead 
//  TODO - implement this by moving this resolver to live alongside the external resolvers 
//  TODO This should use the same `MutationValidator` infrastructure that we use for other mutation types 
//  TODO: we should just cache these classloaders and eject/stop them when they are no longer in use 
//  TODO - should be >= self closed 
//  TODO:LPTR We should collect all source sets in the project source set, however this messes up ComponentReportRenderer 
//  TODO Only log expired workers count, log their "identity" once they are nameable/describable 
//  TODO This is not nice: work out a better way to collect the plugin requests from invoking the plugins block. 
//  TODO This is a brain-dead way to ensure that the reference project's model is ready to access 
//  TODO - this is not quite right, eg given *,!A->A;*,!B->B the result should be B->A and A->B but will in fact be B-> and A-> 
//  The very first event starts the Initializing phase   TODO - should use BuildRequestMetaData to determine the build start time 
//  one should really avoid using this constructor as it is totally inefficient   and reserved to spurious cases when the components have dots in names   (and this can happen if a task name contains dots)
//  TODO - bust up this hierarchy and compose using interfaces instead 
//  Simulate a stuck worker. There's probably a way to inject this failure... 
//  TODO - this should be an outgoing variant of the component under test 
//  Add an install task   TODO - should probably not add this for all executables? 
//  TODO:lptr why don't we check runningNodes here like we do in hasNodesRemaining()? 
//  Dumb terminal doesn't support ANSI control codes.   TODO - remove this when we use Terminal rather than JAnsi to render to console 
//  This is a workaround for https://github.com/gradle/gradle/issues/4241   Several early typed operations have `buildPath` property,   the value of which can only be determined after the settings file for the build has loaded.     The workaround is to buffer all operation notifications in memory until the root build's settings have loaded.   This works because all possible settings files have been evaluated by the time the root one has been.   This is not guaranteed to hold into the future.   A proper solution would be to change the operation details/results to be   truly immutable and convey values known at the time.
/*  * An amount is an immutable value of some quantity, such as duration or length. Each amount has a decimal value and associated units. * * TODO - need to sort out scaling when dividing or converting between units.  */
//  TODO - move this to PropertyValue instead
//  Trailing slash in name indicates that entry is a directory 
//  allow organisation synonyms, like 'org' or 'organization' 
//  No include expression, ignore 
//  rc-1, 1.0 
//  noop 
//  If node was previously traversed, need to remove outgoing edges. 
//  Simple scheme is to just present the public type of the container 
//  A nullable reference 
//  Always publish `ComponentWithVariants` 
/*      * Maven supports wildcards in exclusion rules according to:     * http://www.smartjava.org/content/maven-and-wildcard-exclusions     * https://issues.apache.org/jira/browse/MNG-3832     * This should be used for non-transitive dependencies      */
//  Returns an approximation of a composite variant 
//  We have some batched up conflicts. Resolve the first, and continue traversing the graph 
// Each build request carries it's own log level and it is used during the execution of the build (see LogToClient) 
//  Implementation note: It is only necessary to override visit methods   for AST nodes that reference statements. For ClosureExpression we rely on   the assumption that it always references a BlockStatement and hence our   visitBlockStatement() method gets called.
//  Workspace scope is expected to be persisted in the project cache dir since 4.0. 
//  register eagerly so stop() is triggered when services are being stopped 
//  may be we have C[k1:v1] -> should become (C)([k1:v1]) 
//  Construct a new CompilerOptions class 
//    Add `publicType`   
//  Swap the Foreground and Background bits. 
//  Configure the component 
//  This is called from the download thread. Only forward the events when not cancelled 
//  This insanity is needed for the case where someone calls pluginContainer.add(new SomePlugin())   That is, the plugin container has the instance that we want, but we don't think (we can't know) it has been applied
//  Register the project's source set output directories 
// no scheme means someone passed a relative url. In our context only file relative urls make sense. 
//  Sha256 is not part of core-services (i.e. no Hashing.sha256() available), hence we use plain Guava classes here. 
//  anything other than PropertyExpressions or   VariableExpressions will stop resolving 
//  If a delimiter; if dot, swap to groupToken, otherwise the rest belongs in qualifier. 
//  GENERATE ConfigureUtil.configureUsing(v); 
//  Ignore the rule if it expects Ivy metadata and this isn't an Ivy module 
//  Missing files can be ignored 
//  Matches: task <identifier> <operator> <expression> | task <string> <operator> <expression>   Map to: passThrough(task('<identifier>') <operator> <expression>) | passThrough(task(<string>) <operator> <expression>) 
//  No overlap no cry 
//  CopyProcessingSpec overrides to broaden return type 
//  Assume individual files have no dependencies 
//  For testing 
//  a local component that provides a JVM assembly 
//  we hold other project locks that we should release first 
//  Retain buffer if there is capacity in the queue, otherwise discard 
//  Sort source files to work around https://issues.apache.org/jira/browse/GROOVY-7966 
//  No macro includes were seen in the include graph of this file, so the result can be reused if this file is seen again 
//  Use an injected ObjectFactory to create a Server object 
//  TODO:ADAM - switch the logging back on.                  LOGGER.debug("Ignoring failure to extract throwable cause.", ignored);
//  On Windows, / and \ are separators, on Unix only / is a separator. 
//  Discard the body when the expression is not resolvable 
//  GROOVY-4043: Do this check up the hierarchy, if needed 
//  TODO - add stripped symbols to the installation
//  Matches: task <identifier>(<options-map>) <closure> 
//  Take a snapshot while holding lock 
//  TODO - all this matching stuff is constant for a given DependencyMetadata instance
//  -----------------------------------------------   ---- Delegate CopySpec methods to rootSpec ----   ----------------------------------------------- 
//  Matches: task <identifier> <closure> 
//  Only for relative positioning 
//  Capture changes in execution outcome 
//  Mark this listener type as being notified 
//  Register as a 'logger' to support this being replaced by build logic. 
//  Fallback to failing the task in case we don't know anything special   about the error 
//  Notify caches that lock is to be released. The caches may do work on the cache files during this 
//  Don't list versions for gradleMetadata if maven-metadata.xml will be checked. 
//  since we have B and want to get A we start with the most   outer class, put them together and then see if that does   already exist. In case of B from within A$B we are done   after the first step already. In case of for example   A.B.C.D.E.F and accessing E from F we test A$E=failed,   A$B$E=failed, A$B$C$E=fail, A$B$C$D$E=success 
//  not supported by javax.xml.transform.Transformer; use two spaces instead 
//  Short circuit logic when only 2 candidates 
//  In a similar way to Ivy, Maven may use other hosts for additional artifacts, but not POMs 
//  TODO get normal resolving to set declaring class
//  copy in case any actions mutate the store 
//  we would normally log at a lower level than lifecycle, but the Ant message priority is actually higher   than (or equal to) the set lifecycle log level 
//  producer doesn't declare anything, so we assume that it only provides the implicit capability 
//  Source dir already at the start of the path, just use the include path 
//  Configuration artifacts are determined locally 
//  Can discard the state required to create instance 
//  For stats we don't really care about thread safety 
/* Mutable */
//  No parent, we're done 
//  Skip, visitor is not interested 
//  complete cancelling key 
// noinspection OptionalGetWithoutIsPresent 
//  library, albeit only for selected classes that run a high risk of being statically referenced from a transform.
//  GENERATE public <type> <getter>() { return <field> } 
//  GENERATE private DynamicObject dynamicObjectHelper 
//  Always treat as non-empty 
//  the type of the property node instead. 
//  If the failure handler rethrows exception, then execution of other nodes is aborted. (--continue will collect failures) 
// exclude rules for a dependency specified in gradle DSL 
//  Create a processor that processes events in its own thread 
//  Only consider one candidate, because matchesUniqueVersion means that there's no ambiguity on the version number 
//  Not required, but Guava's performance bad for an empty immutable list 
/*  unsupported by this transformer  */
//  Always schedule the generation task after the clean task 
//  If there's more than one module, merge them into a module set 
//  some impls support this but not factory.setAttribute("indent-number") 
//  If any of the child strategies don't expire the daemon, the daemon will not expire.   Otherwise, the daemon will expire and aggregate the reasons together. 
// it means the registry didn't exist yet 
//  not supported 
//  If there is a transform for the language into one of the component inputs, add a default source set 
//  Allows individual identification for debugging 
//  only print first Gradle script stack trace element 
//  Finalizing here, as we need this to run after any 'assembling' task (jar, link, etc) is created.   TODO: Convert this to `@BinaryTasks` when we model a `NativeAssembly` instead of wiring compile tasks directly to LinkTask 
//  Never use empty settings when the settings were explicitly set 
//  Need to double check that the target still has hard edges to it 
//  We will only add dependencies to the leaves if there is such a published module 
//  Don't bother searching remotely 
//  Disallow classes from Groovy Jar that reference external classes. Such classes must be loaded from astTransformClassLoader,   or a NoClassDefFoundError will occur. Essentially this is drawing a line between the Groovy compiler and the Groovy 
//  When a Provider is used as a task dependency (rather than as a task input), need to unpack the value 
//  Metadata builder uses mutable project state, so synchronize access to the project state 
//  This special case is for Maven snapshots with Gradle Module Metadata when we need to remap the file name, which   corresponds to the unique timestamp, to the SNAPSHOT version, for backwards compatibility 
//  Part of a strongly connected component (ie cycle) - move values to root of the component   The root is the first node of the component we encountered 
//    Add `getName()`   
//  Remove all the classes other than the main class 
//  Necessary for Groovy compilation to pick up output of regular and joint Java compilation,   and for joint Java compilation to pick up the output of regular Java compilation.   Assumes that output of regular Java compilation (which is not under this task's control) also goes   into spec.getDestinationDir(). We could configure this on source set level, but then spec.getDestinationDir()   would end up on the compile class path of every compile task for that source set, which may not be desirable.
//  Call directly on the delegate to avoid some dynamic dispatch 
//  We need to sort here since the file order obtained from the filesystem   can change between machines and we always want to have the same shaded jars. 
//  Check that the object has already been serialized. 
//  This configuration cannot be mutated, but some parent configurations provide artifacts 
// This one should go away once we complete the auto-apply plugins 
/*         Note: Aether implicitly uses a thread pool and tasks to perform transfers,        so we manually propagate the current build operation ref so logging is correctly associated.      */
//  throw new MissingPropertyException(name, <view-type>.class) 
//  GENERATE getInstantiator() 
//  Find the candidates with the highest base version 
//  Hold the lock until we actually start accepting connections for the case when stop is called from another   thread while we are in the middle here. 
//  the platform itself is greater than the forced version 
//  GENERATE services.get(ObjectFactory.class) 
//  Replace result if we fail on warning 
//  Find and remove common prefix 
//  Serialize the worker implementation classpath, this is consumed by GradleWorkerMain 
//  else, might be a link which points to nothing, or has been removed while we're visiting, or ... 
//  Try to configure an element 
/*      * Returns Whether the transformer can transform     * these arguments at all.      */
//  Do not check for opaque properties when implementing PropertyMixIn, as this is expensive 
//  This does almost the same thing as passing through DesugaredAttributeContainerSerializer / DesugaringAttributeContainerSerializer.   Those make some assumptions about allowed attribute value types that we can't - we serialize everything else to a string instead. 
//  We don't adjust the column value as in the event we unwrap, we want to keep correctness 
//  see if the grammar if out-of-date by way of its importVocab 
//  only way I know of to determine current log level 
//  TODO: Reuse more of CommandlineActionFactory
//  Serialize the actual security manager type, this is consumed by BootstrapSecurityManager 
//  The accumulated exclusions that apply to this edge based on the path from the root 
// prefix internal fields with _ so that they don't get into the way of propertyMissing() 
//  TODO validate that the plugin accepts this kind of argument
//  We must be on some Unix variant, including Cygwin or MSYS(2) on Windows... 
//  Guard against TestNG calling this hook more than once with the same testClass.   See https://github.com/cbeust/testng/issues/1618 for details. 
//  Parallel configuration 
//  Should not reach this point as this is validated in the test framework implementation - just propagate the failure 
//  consumer expressed no preference, defaults to library 
//  Order is significant. Injection handler should be at the end 
//  https://en.wikipedia.org/wiki/Standard_error 
//  Queue this up for checking again later 
//  All of these field names are really long to prevent collisions with the groovy setters.   Groovy will try to set the private fields if given the opportunity.   This makes it much more difficult for this to happen accidentally.
//  Get any errors from the compiler result 
//  [baseName]-[appendix]-[version]-[classifier].[extension] 
//  Try to infer the effective jvm options for the currently running process.   We only care about 'managed' jvm args, anything else is unimportant to the running build 
//  Add the library and extension 
//  Should use ProjectState instead
//  2. the graph contains first-level dependencies which have been substituted (likely) so we're going to iterate on dependencies instead 
//  Reuse the same version as last build 
//  Used just to test the mechanism 
//  Add incoming artifact transforms 
//  This should live closer to the project itself
//  no daemon process has started yet 
//  Treat everything else as a single file 
//  TODO Add a deprecation warning in Gradle 6.0
//  Convert once, in order to write the Ivy descriptor with _all_ configurations 
//  no outputs file 
//  build tasks without project reference 
//  XCTest executable   Sync the binary to the BUILT_PRODUCTS_DIR, otherwise Xcode won't find any tests 
// supplied java location 
//  If we can't discover the version from the normal metadata, make some assumptions 
//  Create tasks for solutions, projects and filters 
//  this loop builds a name from right to left each name part   separated by "." 
//  No args 
//  Else, continue below 
//  Rename `LinuxMain.swift` to `main.swift` so the entry point is correctly detected by swiftc 
// class results may be created earlier, where we don't yet have access to the start time 
//  Add to the end of the queue, so that we traverse the graph in breadth-wise order to pick up as many conflicts as   possible before attempting to resolve them 
//  Use the index here so we can apply any filters to the realized element 
//  this work has to be done before classes are loaded, otherwise there are risks that   the PermGen space is full before we create the reflection methods 
//  GroovySystem.getMetaClassRegistry() 
//  parallel safe version of Compiler.compilerInterface() 
//  visit the method call, because one of the args may be an input method call 
//  We can't close replaced loaders immediately, because their classes may be used during shutdown,   after the return of the reload() call that caused the loader to be swapped out.   We have no way of knowing when the loader is actually done with, so we use the request after the request   that triggered the reload as the trigger point to close the replaced loader. 
//  Matches: task <method-call> <operator> <expression> 
//  A ∪ (A ∩ B) ∪ (A ∩ C) -> A 
// In case the output event arrives after completion of the test  and we need to have a matching descriptor to inform the user which test this output belongs to  we will use the current parent 
//  generate documentation 
//  This is a hidden property that may be useful to track down issues. Remove when NTLM Auth is solid. 
//  Should not happen when reading from a StringReader 
//  GENERATE private MetaClass metaClass = GroovySystem.getMetaClassRegistry().getMetaClass(getClass()) 
//  If we reach this point it means we have a dependency which doesn't belong to the resolution result   Which can mean two things: 
//  Wrap the processor in an actor, to make it thread-safe 
//  from this point down, logging is sent back to the client 
//  Java source files are supported, too. Therefore we should care about the relative path. 
//  Show any contextual cause recursively 
//  Use an arbitrary ordering when the artifacts have the same public attributes 
//  Other home dir cached and not in use, clean it up
//  We're making an assumption here that the target's plugin registry is backed classLoaderScope.   Because we are only build.gradle files right now, this holds. 
//  Build configuration for GradleWorkerMain 
//  start logging now that the logging manager is connected 
//  First try to resolve the artifacts locally before going remote 
//  Add to the front of the queue, to flush out configurations that are no longer required. 
//  Controls when to disable reading default authentication credentials, should be used in tests only 
//  If the jansi.force property is set, then we force to output 
//  Using the test sources feature introduced in Eclipse Photon 
//  Flaky 
//  Mix in some Groovy DSL support. Should decorate instead 
//  don't care 
//  Service calls have no effect, no need to register them 
//  just serialize as a String as best we can 
//  Create Visual Studio project extensions 
//  See https://issues.gradle.org/browse/GRADLE-1589 
//  Run the build and get the build outcomes model 
//  Done 
//  Reach into meta class to avoid lookup 
//  Windows at least will sometimes throw odd exceptions like java.nio.file.AccessDeniedException   if the file gets deleted while the watch is being set up. 
// verify that the parsed descriptor is the correct parent module. 
//  We need to attach failures on unattached dependencies too, in case a node wasn't selected   at all, but we still want to see an error message for it. 
//  For now, we only create test suites for static library variants 
//  We'll get this when we try to look up "ProgramFilesDir (x86)" on a 32-bit OS 
//  Serialize configuration for the worker process to it stdin 
/*  (non-Javadoc)         * @see org.apache.ivy.plugins.parser.m2.PomDependencyMgt#getVersion()          */
//  Only use this for top level init scripts 
//  Never up to date; we don't understand the data structures. 
//  TODO: Combine these with MutationGuard
//  setup the default configurations used when mapping to resolved versions 
//  A very dumb strategy for invalidating cache 
//  There is a chance we could not attach target configurations previously 
//  Add the Gradle API filter between the user classloader and the worker infrastructure classloader 
//  We need a consistent index here 
//  Object converted = $typeConverter.convert(foo, Float.class, false); 
//  Read body 
//  Mixed case 
//  Always expand empty node 
//  A dependency artifact will be defined if the descriptor specified a classifier or non-default type attribute. 
//  stream has been closed, don't bother reading anything else 
//  only care about HTTP hosts right now 
//  Call return new <implClass>(param1) 
//  Listen for the end of configuration of the root project of the root build,   and discard buffered notifications if no listeners have yet appeared.   This avoids buffering until the end of the build when no listener comes. 
//  Assume that test has renamed itself (this can actually happen) 
//  Expire recently unused Daemons when memory pressure is high 
//  FindBugs cannot handle missing directories 
//  Only count non-CREATE events, since creation also causes a modification event, unless the event is for a directory. 
//  Retain strong reference 
//  Augment the environment for the execution 
//  Transient, don't serialize all the views that happen to have been visited, recreate them when visited via the deserialized view 
//  some implementation uses null to represent bootstrap classloader   i.e. Object.class.getClassLoader()==null 
//  TaskListenerInternal 
//  Ignore. Currently the actions don't need to run, it's just better if they do   By the time this node is notified that the task in the other build has completed, it's too late to run the action   Instead, the action should be attached to the task in the other build rather than here 
//  Here, we will distribute A ∩ (B ∪ C) if, and only if, at   least one of the distribution operations (A ∩ B) can be simplified 
//  Find the nearest parent up that we care about and use that as the parent. 
//  When the outputs are generated, throw away all state for files that do not live in an append-only cache.   This is intentionally very simple, to be improved later 
//  and class as property 
//  A launchable created by the provider - just hand it back 
//  Must run each action 
//  The other is better, current is not part of result 
//  this shouldn't happen, resolvers should call notFound() 
//  Redirect stderr to stdout when both stdout and stderr are attached to a console. Assume that they are attached to the same console   This avoids interleaving problems when stdout and stderr end up at the same location 
//  get(<type>) 
//  Should get back some kind of reference that can be queried below instead of looking the task up every time 
//  This is the root block. Can have any number of children <= maxChildIndexEntries 
//  There are enough entries in this block and the left sibling to make up 2 blocks, so redistribute   the entries evenly between them 
//  the deployment descriptor already exists; no need to generate it 
/*  (non-Javadoc)         * @see org.apache.ivy.plugins.parser.m2.PomDependencyMgt#getGroupId()          */
//  GENERATE objectFactory.directoryProperty() 
//  Sanitise the exception and report it 
//  https://github.com/gradle/gradle/issues/2319 
//  Return the group to use for the given build operation, searching up the build operation hierarchy for the first group 
//  Split line if a single line goes over 1 MB 
//  Intentionally not the text 
//  in which case we output "" to stay compatible with existing builds that scan the script for it 
//  Resolving a project component can cause traversal to other projects, at which   point we could release the project lock and allow another task to run.  We can't   use a cache loader here because it is synchronized.  If the other task also tries   to resolve a project component, he can block trying to get the lock around the   loader while still holding the project lock.  To avoid this deadlock, we check,   then release the project lock only if we need to resolve the project and ensure   that only the thread holding the lock can populate the metadata for a project.
//  the name is a type so remove it from the scoping   as it is only a classvariable, it is only in   referencedClassVariables, but must be removed   for each parentscope too 
//  Layout 
//  Add any finalizers to the queue 
//  We know all are compatibles, so this is only possible if some disambiguation happens but not getting us to 1 candidate 
//  should this be null?
//  /proc/meminfo is in kB since Linux 4.0, see https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/fs/proc/task_mmu.c?id=39a8804455fb23f09157341d3ba7db6d7ae6ee76#n22 
//  Because the same suffix is used for all decorating class generator instances, share the same cache as well 
//  check if directory is already watched   on Windows, check if any parent is already watched 
//  Should really fail here if sourcesToCompile is not empty: no transform for this source set in this binary 
//  Include the shortest path from each version that has a direct dependency on the broken dependency, back to the root 
//  Ignore the subkey if it doesn't have a folder and version 
// directly printing to the stream to avoid log level filtering. 
/*         The song and dance with Action<Runnable> is to ease testing.        See DisconnectableInputStreamTest      */
//  Add dependencies to the start of the queue 
//  end element marker 
// when 
//  Don't configure anything 
//  Target: arm 
//  Add if absent 
//  GENERATE private ConventionMapping mapping 
//  Initialize Matchers once and then reset them for performance 
//  Project has no publications: simply use the project name in place of the dependency name 
//  only add confs if they are specified. if they aren't, endElement will handle this 
//  This second check is only done so that we can make the difference between an uninitialized rule (never seen before) and   a rule which is not reusable 
//  this.getServices() 
//  Currently visiting the successor node - we're in a cycle 
// for gradle distribution specific dependencies 
//  Handle anyOf first because we don't want to special case it in   every other case 
//  Adds a void $propName(Closure<?> cl) method that executes the closure 
//  Stopping, so result doesn't really matter. 
//  More information: http://blog.jetbrains.com/scala/2014/10/30/scala-plugin-update-for-intellij-idea-14-rc-is-out/ 
//  Configurations are built on-demand, but only once. 
//  We have enough local data to make a comparison, get the remote metadata 
//  we do not resolve a vanilla name starting with a lower case letter   try to resolve against a default import, because we know that the 
//  A launchable synthesized by the consumer - unpack it into a set of task names 
// offset based implementation is only safe up to certain figure  because of the int max value  for large streams/files (huge builds), we need to roll the file 
//  TODO - deal with more than one directory
//  private member: implementation details 
//  Don't inline the Groovy jar as the Groovy “tools locator” searches for it by name 
//  TODO:ADAM - switch the logging back on.                  LOGGER.debug("Ignoring failure to serialize throwable.", ignored);
//  min chunk size 4kB, max size 1MB 
// for updates to private JDK caches of the environment state 
//  Set the system properties and use this process 
//  Was it updated during execution?
//  Foreground daemon cannot be 'told' what's his startup options as the client sits in the same process so we will infer the jvm opts from the inputArguments() 
//  round to nearest second 
//  this.field = value 
//  Configure the included build to discover available modules 
//  Initialize SSLContext 
//  J flags can not be set in the option file   add additional option files 
//  use the max heap as an approximation 
//  Collect artifact sets in a list, using the id of the set as its index in the list 
//  If no errors, get the compiled source and write it to the destination file 
//  For now, required and preferred are treated the same 
//  Does not need to be redrawn if component is out of bound 
//  Prevent construction 
//  the removal of the method will be reported   the removed methods will be reported   the added methods will be reported 
/*              * We know that DefaultScript & friends don't have user-visible nested types,             * so don't try to look up nonsensical types like org.gradle.Script#sourceCompatibility              */
//  We don't know what the type is - let Guava take care of it. 
//  Query the declared methods of the meta class 
//  check interfaces at this level first 
//  Could be different to ids in the requests as they may be unqualified 
//  Could potentially also look whether we have the details for an ancestor directory tree   Could possibly infer that the path refers to a directory, if we have details for a descendant path (and it's not a missing file) 
//  set up a configuration named 'antlr' for the user to specify the antlr libs to use in case   they want a specific version etc. 
//  <class>.getDeclaredMethod(<getter-name>) 
//  This will propagate through the graph and prune configurations that are no longer required. 
// by keying the failures only by 'requested' we lose some precision  at edge case we'll lose info about a different exception if we have different failure for the same requested version 
//  wait for it to open 
//  Serialize the application classpath, this is consumed by BootstrapSecurityManager 
// TODO: all methods 
//  check module node imports aliases   the while loop enables a check for inner classes which are not fully imported, 
//  this situation occurs when there was no branch defined   in the original dependency descriptor. So the dynamicId   shouldn't contain a branch neither 
//  TODO: Honor changes to build directory 
//  the target component exists, so we need to fallback to the traditional selection process 
//  happens when dispatching to taskdef via createNode() 
// is it sane enough?
//  Retain strong references to the values created for this session 
//  Configure test binary to compile against binary under test 
//  If this task uses a pre-compiled header 
//  only define a Scala SDK for a module if we could create a scalaSdkLibrary 
//  Flushing data split across previous and current appending 
//  GENERATE public DynamicObject getAsDynamicObject() { 
//  TODO: Publishing for test executable?
//  Skip things that aren't files 
//  next character is not a separator 
//  need to run operation under cache lock 
//  Total number of garbage collection events observed in the window 
//  Buckets of dependencies 
//  Force loading to check if method handle is supported 
//  Wrap in generic 'build failed' cross version exception 
//  Otherwise, macro or macro function call 
//  can't be equal otherwise wouldn't have been collected 
//  TODO: Reuse more of BuildActionsFactory
//  Configure test binary to link against tested component compiled objects 
//  Use writeFile because the cache can internally recover from datafile   corruption, so we don't care at this level if it's corrupt 
//  Exit value is unreliable for determination of process failure. 
//  Setup the dependency on the main binary   This should all be replaced by a single dependency that points at some "testable" variants of the main binary 
//  TODO: consider entryAttributes in equals, hashCode, and toString 
//  invokeMethod(this, name, args) 
//  Used by the Kotlin plugin 
//  Last entry, complete the result 
//  a class consisting of a vanilla name can never be   a static inner class, because at least one dot is   required for this. Example: foo.bar -> foo$bar 
//  Copy selection failure 
//  It's almost always the same attribute sets which are compared, so in order to avoid a lot of memory allocation   during computation of the intersection, we cache the result here. 
//  Pull-only always comes first 
//  Look for model(«») (i.e. call to model with anything other than non literal closure) 
//  Authoritative result - don't need to try remote 
//  do some checks up-front, so we avoid creating the queue in most cases   Cases we want to handle:   - List<String>   - Class<?>   - List<Class<?>>   - Integer[]   - ? extends BaseType   - Class<?>[] 
//  create the listener adapters right when the ConsumerOperationParameters are instantiated but no earlier,   this ensures that when multiple requests are issued that are built from the same builder, such requests do not share any state kept in the listener adapters   e.g. if the listener adapters do per-request caching, such caching must not leak between different requests built from the same builder
//  Snapshot the state and notify the caches 
//  Currently not required 
//  TODO: synchronization 
//  We're sorting the names of the configurations and later attributes   to make sure the output is consistently the same between invocations 
//  don't forward 
//  Allow only certain things from the underlying classloader 
//  Don't add if our last record has a `:taskName` status, and this one is `:taskName SOMETHING` 
//  Assume that each artifact points to a unique file, and use the relative path from the project as the id 
//  Matches: task <identifier> <arg-list> | task <string> <arg-list>   Map to: task("<identifier>", <arg-list>) | task(<string>, <arg-list>) 
//  Remove license files that cause collisions between a LICENSE file and a license/ directory. 
//  If no expiration strategies exist, the daemon will not expire. 
//  overwrite rather than append libraries 
//  let's see if we can find a single variant which has exactly the requested artifacts 
//  Check to see if there are any compatible canceled daemons and wait to see if one becomes idle 
//  count every event on OSX 
//  Info about the owning task can be inferred, and we don't provide any further info at this point.   This is largely to expose timing information about executed tasks 
//  Assume 8.1 
//  don't bother trying to handle primitive arrays specially 
//  Attempt to merge with the left sibling 
//  for command file format, see http://docs.oracle.com/javase/6/docs/technotes/tools/windows/javac.html#commandlineargfile   use platform character and line encoding 
//  This can happen on Windows 
//  fully visit the class hierarchy before any interfaces in order to meet the contract   of PropertyDetails.getGetters() etc. 
//  caches 
//  If no current selection for module, just use the candidate. 
//  Running the task requires access to the task's owning project 
//  all the values are equal, but we store all the binaries that match that value   and incrementally build a list of binaries which are excluded because of a better match 
//  store thrown exception 
//  lock on demand 
//  not the same provider 
//  Already completed 
//  Encode as ascii 
//  Another process may have already copied the compiler interface JAR   Avoid copying over same existing file to avoid locking problems 
//  Lock is in use - mark as contended 
//  Handles both junctions and real symlinks (https://www.2brightsparks.com/resources/articles/NTFS-Hard-Links-Junctions-and-Symbolic-Links.pdf) 
//  Should not happen reading from a StringReader 
//  Attaches the owning WorkerExecutor to this factory 
//  Same as the length of this, minus the last element, minus the dot between them 
//  Keep the argument from this expression 
//  Are all file snapshots after execution accounted for as new entries?
//  we must use a String literal here, otherwise using things like Foo.class.name will trigger unnecessary   loading of classes in the classloader of the DefaultIsolatedAntBuilder, which is not what we want. 
//  Create the tasks for each C++ binary that is registered 
//  an exclude all is for modules, not artifacts 
//  Adds a void set$PropName(Object value) method that fails 
//  start element marker 
//  This should only be used for top-level builds 
//  Else, wait for the next update event 
//  Don't care, collect the artifacts later (in the correct order) 
//  Verify that none of the listed "versions" do match another pattern 
//  We've already validated the inputs: should never get here. 
//  Use this thread to process any work - this allows work to be executed using the   worker lease acquired by this thread even if the executor thread pool is full of   workers from other threads.  In other words, it ensures that all worker leases   are being utilized, regardless of the bounds of the thread pool. 
//  Restrict the decorations to those required to decorate all views reachable from this type 
//  cached resolved values 
//  do not fail the build as feature is non-critical 
//  do not remove task descriptors because they might be needed to describe subsequent tasks' dependencies 
//  avoid clone 
//  TODO - take care of this in the selector parser 
//  gradleFileResource type is mapped to AntFileResource 
//  A javac warning, ignore 
//  No support for command file 
//  Configure an implicit variant 
//  Path is an ancestor of this 
//  Copied from Method.isDefault() 
//  This should come from the compiler classpath only 
//  Consider every node that must run before the finalizer 
//  Do not hold lock while removing listener, as the listener may still be receiving events on another thread and will need to acquire the lock to handle these events 
//  Create all of the pipeline eagerly as soon as this is enabled, to track the state of build operations.   All of the pipelines do this, so should instead have a single stage that tracks this for all pipelines and that can replay the current state to new pipelines   Then, a pipeline can be added for each listener as required 
//  Once the node has been discovered, changing the target is not allowed, as it changes the promise of the node as well 
//  fall back to the default logic 
//  A set of progress operations that have been forwarded 
//  First child node 
//  this is necessary to prevent O(n^2) behavior in xcode project loading 
//  GENERATE super.getAsDynamicObject() 
//  Transform closure 
//  Should instead forward these to the task's validation context 
//  Mutable property 
//  DependencyResolutionListener 
//  end of tag marker 
//  Have read some data - let readers know 
//  Adds a void $propName(Closure<?> cl) method that throws MME, to avoid attempts to convert closure to something else 
//  Nexus uses sha1 etags, with a constant prefix   e.g {SHA1{b8ad5573a5e9eba7d48ed77a48ad098e3ec2590b}} 
//  part of a cycle : use the 'minimum' component as the root of the cycle 
//  Look for a realized object 
//  String[] 
//  Also releases any locks 
//  Not already known, attempt to resolve the parent 
// The first argument is not really used but it is very useful in diagnosing, i.e. running 'jps -m' 
// when root suite is completed we stop redirecting 
//  let the delegate resolver select among them 
//  Setting time to 0 because we need API jars to be identical independently of   the timestamps of class files 
//  for storing to field 
//  Property is readable and all getters and setters are abstract 
//  Wait for work to be submitted if the queue is empty and our worker count is under max workers   This attempts to keep up to max workers threads alive once they've been started. 
//  Ignore the decorated service 
//  Add a create task 
//  Directory has something in it already 
//  Source file has not changed and no include files 
//  Do a shallow render of any constraint edges, and do not mark the node as visited. 
//  assert the exit value signals success 
//  should be protected, but use of the class generator forces it to be public 
//  Turn off request logging, this can end up logging OAUTH   tokens which should not ever be in a build log 
//  Ignore some broken samples before the given date 
//  GENERATE new BeanDynamicObject(this) 
//  Both of these values are effectively part of a cross Gradle version contract.   Do not change them. 
//  TODO Use IvyArtifact here
//  Not part of a strongly connected component or the root of a strongly connected component 
//  modifies in place 
//  Copy the snapshots whose values are the same, then snapshot remaining values 
//  Serialize the incoming class and parameters (if necessary) 
//  null if type == UNDEFINED 
//  Only * characters: matches #1 above 
/*      * Checks whether the plugin marker artifact exists in the backing artifacts repositories.      */
//  this exception means that we want to try again. 
//  Probe for artifact with classifier 
//  note: BigInteger and BigDecimal are also imported by default 
//  SoftwareModel 
//  At this point we must have annotations on this private getter 
//  Create a SourceFile object to represent an "empty" extern 
//  <tr>     <td><literal><link linkend="$id">$name</link>$signature</literal></td>     <td>$description</td>   </tr> 
//  Any windows GCC compatible implementation (mingw, cygwin) 
//  ml/ml64 have position sensitive arguments,   e.g., /Fo must appear before /c and /c must appear before the source file. 
//  extract the files that were generated 
//  First scan for annotation, and short circuit transformation if not present 
//  asking isResolved here allows to check if a primitive   type name like "int" was used to make t. In such a case   we have nothing left to do. 
//  According to absolute positioning 
//  Make the argument serializers available so work implementations can register their own serializers 
//  Not sure under what scenario (if any) this would occur,   but there's no sense in collecting the descriptor if it does.
//  Rethrow 
//  We can only determine if two DaemonStopEvent point at the same daemon if we know the PIDs 
//  Use an IdeaModule to reference a project 
//  literal followed by at least one * 
//  Lifecycle messages 
//  If we've freed memory, invalidate the current OS memory snapshot 
//  consumer didn't express any preference, everything fits 
//  Traverse graph 
//  Enabled caching if task type is annotated with @CacheableTask 
//  Wrap build failure in 'cancelled' cross version exception 
//  alternatively, we could return project.getLayout().files(Runnable)   would differ in the following ways: 1. live (not sure if we want live here) 2. no autowiring (probably want autowiring here) 
//  Run the rules and try to find something again. 
//  Invalid paths fall through to here 
//  TODO - set ACL here if necessary
//  A map from progress operation id seen in event -> progress operation id that should be forwarded 
// just in case we have a bug related to logging,  printing some exit info directly to file: 
//  Register the defined substitutions for included build 
//  only need to decorate when this callback is delayed 
//  The task status line may appear twice - once for the execution, once for the UP-TO-DATE/SKIPPED/etc   So don't add to the task list if this is an update to a previously added task.
//  all tasks have the same value 
//  Create the domain object 
//  Calculate how many rows of the status area overlap with the text area 
//  An object-like macro 
//  Set up worker ClassLoader 
// eg. 'someTask' or 'sT'  eg. '', ':' or ':foo:bar' 
//  Watch for the client disconnecting before we call stop() 
//  separator 
//  ProjectStateWrapper might contain the configured eclipse project name 
// 1) we've seen the replacement, register new conflict and return 
//  Add new labels to the unused queue 
//  This is final - use {@link TaskDependencyContainer#visitDependencies} to provide the dependencies instead. 
// noinspection unchecked 
//  TODO: Add test name to the report   @formatter:off
//  triggering file resolve 
//  only an input for other task instances 
//  Wrap in a <span>, to work around CSS problem in IE 
//  Collect a map from component to its owning component. This might be better to move to the component or some publications model 
//  Can use arg without conversion 
//  super class not on the classpath - unable to scan parent class 
//  Get the next page, in the next iteration of this loop. 
//  Have already visited this node - skip it 
//  the class property stops resolving, dynamic property names too 
//  Missing ',' 
//  Match recording is optimized for the general case of a single match 
//  this happens when JNA is not in the path.. or   this happens when the stdout is being redirected to a file. 
//  
//  Add an adapter for each newly added target 
/*      * Groovy manipulates the JVM to let GString extend String.     * Whenever we have a Set or Map containing Strings, it might also     * contain GStrings. This breaks deserialization on the client.     * This method forces GString to String conversion.      */
//  only write if we have results, otherwise truncate 
//  TODO: Synchronization 
// we could retrieve annotations at construction time and hold references to them but unfortunately  in IBM JDK strong references are held from annotation instance to class in which it is used so we have to reflect 
//  Restore the existing object being deserialized. 
//  handle decoding underflow, multi-byte unicode character at buffer chunk boundary 
//  Either no cached, or it's changed. See if we can find something local with the same checksum 
//  we need to make sure the variants we consider provide the implicit capability 
// FileCollection files = ProjectBuilder.builder().build().files();  assertThat(call("{ bean, fc -> bean.files fc}", bean, files), nullValue());  assertThat(bean.getFiles(), sameInstance(files)); 
//  Do not reprocess 
//  relink, produce another object file   hide _main symbol 
//  Intentionally not a “create” method as this should not be exposed as a service 
//  Track any progress operation that either can't be display due to label shortage or child progress operation is already been displayed 
//  Assume 80 wide. This is to minimize wrapping on console where we don't know the width (eg mintty)   It's not intended to be a correct solution, simply a work around 
// noinspection ResultOfMethodCallIgnored 
//  Not looking at a match 
//  doesn't exist on either side, nothing to compare 
//  https://github.com/gradle/gradle/issues/9380   Remove a srcDir from a sourceSet 
//  Ignore artifact transforms 
//  Constraint: only consider explicit exclusions declared for this constraint 
//  check next level of interfaces 
//  This is expensive to calculate, so cache the result 
//  ignore anonymous classes 
//  standalone test suite 
//  When build output area is not visible, position the cursor at the end of the output area 
//  try to resolve a public static inner class' name 
//  fallback: take the name from the ProjectState 
//  Log the error but analyze the remaining interfaces. We could for example run into https://bugs.openjdk.java.net/browse/JDK-7032558 
//  Synthesize a start event 
// querying runtime for each invocation 
//  Eventually add blank line before section 
//  else, assume we can write to anything that exists and is not a directory 
//  Called from generated code on failure to convert the supplied value for a property to the property type 
//  System.nanoTime() can go backwards under some circumstances.   http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6458294   This max() call ensures that we don't return negative durations. 
//  Some POMs depend on themselves, don't add this dependency: Ivy doesn't allow this! 
//  TODO:instant-execution reconsider type visibility 
/*     This can't be called just include, because it has the same erasure as include(Iterable<String>).      */
//  setProperty(this, name, value) 
//  One of the Scala plugins is applied, but ScalaRuntime extension is missing or the ScalaPlatform is undefined.   we can't create a Scala SDK without either one 
//  Re-wording to exception message to get rid of the fqcn it contains
//  GENERATE getAsDynamicObject().setProperty(name, value) 
//  attributes. 
// assertThat(call("{ bean -> bean.things([1,2,3]) }", bean), nullValue());  assertThat(bean.getThings().size(), equalTo(3)); 
//  TODO:LPTR This should be like @Finalize void generatedSourcesAreInputs(@Each PlayApplicationBinarySpecInternal binary) 
//  It is okay to have redundant generated 'is'-getters 
/*      * This inner class hides the fact that the actual de-duplication algorithm is stateful.      */
// we're spinning a thread to do work to avoid blocking the connection  This means that the Daemon potentially can do multiple things but we only allows a single build at a time 
//  look into the module node if there is a class with that name 
//  Type is more complicated, need to check everything. 
//  Register at least the project buildDir as a directory to be deleted. 
//  TODO - use circular buffers to avoid copying   TODO - share a single initializer with MultiChannelQueue
//  Do nothing by default 
//  In Kotlin:     > Boolean accessor methods (where the name of the getter starts with is and the name of   > the setter starts with set) are represented as properties which have the same name as   > the getter method. Boolean properties are visible with a `is` prefix in Kotlin     https://kotlinlang.org/docs/reference/java-interop.html#getters-and-setters     This code assumes all configurable Boolean property getters follow the `is` prefix convention.   
/*      * Replaces the currently visited expression with the specified expression.      */
//  currently we only look in script code; could extend this to build script classes 
//  Ensure resource transport protocol, authentication types and credentials are all compatible 
//     @Rule 
//  we replace '.' only in the className part   with '$' to find an inner class. The case that   the package is really a class is handled elsewhere 
//  Always abort execution for an execution failure (as opposed to a node failure) 
//  Box value 
//  Back to being a pending dependency   Clear remaining incoming edges, as they must be all from constraints 
//  Notify upwards of currently existing descendant spec hierarchy 
//  For Maven we don't really know if an optional dependency is required for runtime or compile   so we use the safest: compile 
//  when FileVisitOption.FOLLOW_LINKS, we only get here when link couldn't be followed 
//  modifies args in place 
//  construct project tasks 
//  Locked by the same process, treat as if locked by another process 
//  end::jupiter-example[] 
//  We *absolutely* need to avoid polluting the project with ClassInfo from *our* classloader   So this class must NOT call any dynamic Groovy code. This means we must do what follows using   good old java reflection! 
//  Gcc on windows requires the path to be set 
//  jarName format: org.jacoco.agent-<version>.jar 
//  Continue 
//  Disable command line file for now because some custom assemblers   don't understand the same arguments as GCC. 
//  in particular, this is about GStrings 
//  Should retain this on the metadata rather than calculate on each invocation 
//  Collect this early, as the process' current directory can change during embedded test execution
// task properties:
// we can try sending something to the daemon and try out if he is really dead or use jps  if he's really dead we should deregister it if it is not already deregistered.  if the daemon is not dead we might continue receiving from him (and try to find the bug in messaging infrastructure) 
//  crash 
//  GENERATE getConvention() 
//  node and any subclass resolving will then take place elsewhere 
//  Set the context classloader to the bootstrap classloader, to work around how JAXP locates implementation classes   This should ensure that the JAXP classes provided by the JVM are used, rather than some other implementation 
//  Delete the coverage file before the task executes, so we don't append to a leftover file from the last execution.   This makes the task cacheable even if multiple JVMs write to same destination file, e.g. when executing tests in parallel.   The JaCoCo agent supports writing in parallel to the same file, see https://github.com/jacoco/jacoco/pull/52. 
/*      * The manifest if this is a jar file and has a manifest, null otherwise.      */
//  Either a resolvable expression or a non-empty unresolvable expression, collect. Ignore includes with no value 
//  Deployments are considered outOfDate until initial execution with file watching 
//  When the component defines a precompiled header, we need to check if the precompiled header is the _first_ header in the source file.   For source files that do not include the precompiled header as the first file, we emit a warning   For source files that do include the precompiled header, we mark them as a "source file for pch"   The native compiler then adds the appropriate compiler arguments for those source files that can use PCH 
//  Object propertyMissing(String name) 
//  Body is an expression with one or more arguments 
//  Always publish process info for multi-request workers 
//  the platform doesn't exist, so we're building a lenient one 
//  Don't bother resolving local components asynchronously 
//  A report to be generated, ignore 
//  Authoritative result means don't do remote search 
//  no dynamic constraints defined, so dynamicId equals revId 
//  Write rich content to stdout and plain content to stderr 
//  Build may have failed before getting to projectsLoaded 
//  Create test lifecycle task 
//  Ensure binding validation has been done. This should happen elsewhere 
//  invoked by Groovy 
//  IDEA doesn't like the result of file.toURI() so use the absolute path instead 
//  Version isn't used, except by a human looking at the output of jps. 
//  No tool chains can build for this platform. Assemble a description of why 
//  We need to use the deprecated constructor as it is compatible with certain previous versions of the Zinc compiler 
//  Need to compile all secondary routes ("Foo.routes") before primary ("routes") 
// handler.registerResolver(new UpgradeCapabilityResolver()); 
//  we do not do our name mangling to find an inner class   if the type is a ConstructedClassWithPackage, because in this case we   are resolving the name at a different place already 
/*      * <p>Allows the container to be configured, creating missing objects as they are referenced.</p>     *     * <p>TODO: example usage</p>     *     * @param configureClosure The closure to configure this container with     * @return This.      */
//  Ends up with: 1 2 3 -> 4 <- 5 6 
//  This agent should be loaded via the custom system ClassLoader 
//  Update the cache entry in the index: this resets the age of the cached entry to zero 
//  Should be excluded 
//  Still 'updated' with reason when version remains the same. 
//  check for duplicate entries in java and resources 
//  Use Throwable to record the location where a suffix was registered, to allow diagnostics when a collision is found   This may have performance implications, however the assumption is that class generators are global scoped objects that are created once and in very small numbers 
//  Strategy mutations will not require a re-resolve 
//  Maven local 
//  Adds a void $propName(Closure<?> cl) method that delegates to model state 
//  Print something to verify it is after task execution 
//  This is used only to retain strong references to the values 
// windows needs an additional backslash in jar urls 
//  Add a line before the first question that has been asked of the user   This makes the assumption that all questions happen together, which is ok for now   It would be better to allow this handler to ask the output renderers to show a blank line before the prompt, if not already present 
//  should not happen
//  Versions before 3.2 would throw away the cause. There was also a regression in 4.0.x 
//  This cannot be CopyOnWriteArrayList because we need to iterate it in reverse,   which requires atomically getting an iterator and the size.   Moreover, we iterate this list far more often that we mutate,   making a (albeit home grown) copy-on-write strategy more appealing. 
//  No more unused label? Try to resize. 
//  Some POMs depend on themselves through their parent POM, don't add this dependency   since Ivy doesn't allow this!   Example: http://repo2.maven.org/maven2/com/atomikos/atomikos-util/3.6.4/atomikos-util-3.6.4.pom 
// Assuming the message has correct format. Not bullet proof, but seems to work ok for now. 
//  A nested instance 
//  Use the origin file when it can satisfy the basename requirements 
//  https://docs.oracle.com/javase/specs/jls/se12/html/jls-3.html#jls-Keyword 
//  we must not use interrupt() because it would automatically   close the connection (sending data from an interrupted thread   automatically closes the connection) 
//  Eagerly calculate the file if this will be used as a dependency of some task   This is to avoid having to lock the project when a consuming task in another project runs 
//  legacy mode for internal APIs 
//  Clear previous traversal state, if any 
//  Notify threads that may be waiting on this task to complete.   This is required because although all builds may share the same coordination service, the 'something may have changed' event that is fired when a task in this build completes   happens before the state tracked here is updated, and so the worker threads in the consuming build may think the task has not completed and go back to sleep waiting for some   other event to happen, which may not. Signalling again here means that all worker threads in all builds will be woken up which can be expensive.   It would be much better to avoid duplicating the task state here and instead have the task executors communicate directly with each other, possibly via some abstraction   that represents the task outcome
// we don't want to support "--flag true" syntax 
//  Execute the health check that should send out a DaemonExpiration event   if the daemon is unhealthy 
//  this is an artifact asked for a particular dependency 
//  origins have to be stored until the end of the build 
//  Parking space for the write cursor 
//  Caller must be holding lock 
//  Don't close 
//  skipped versions were not used in a release 
//  Fallback to ClassLoader's lookup 
// argument quoting:   - " must be encoded as \"   - % must be encoded as %%   - pathological case: \" must be encoded as \\\", but other than that, \ MUST NOT be quoted   - other characters (including ') will not be quoted   - use a state machine rather than regexps 
//  test if vanilla name is current class name 
//  revisit all dependencies and possibly change the classpath order! 
//  Any node that the preceding task must run after is also a preceding node. 
//  return var 
//  Never up to date 
//  line gap between the text area and the status area. 
//  expand the thread pool until we hit max workers 
//  otherwise, keep lock open 
//  -1 because of Z_ERROR 
//  Work backwards from highest version, return the first candidate with qualified version and release status, or candidate with unqualified version 
//  externals are mapped to linked resources so we just need a name of the resource, without full path   non unique folder names are naively deduped by adding parent filename as a prefix till unique   since this seems like a rare edge case this simple approach should be enough 
//  Use the ABI as the hash 
//  need to defer loading of Zinc/sbt/Scala classes until we are   running in the compiler daemon and have them on the class path 
//  GENERATE super.<propName>(v) 
//  At this point, we need the component metadata, because it may declare attributes that are needed for matching   Component metadata may not necessarily hit the network if there is a custom component metadata supplier 
//  GENERATE private boolean <flag-name>; 
//  Expire when Daemon Registry becomes unreachable for some reason 
//  <tr>     <td><link linkend="$id"><literal>$name</literal></link</td>     <td>$description</td>   </tr> 
//  the new value is a better fit than the old one 
//  A single leaf node as child and total text is not too long, collapse 
//  Define a classes variant to use for compilation 
//  Edge states are deduplicated, this is a performance optimization 
//  Only remove edges that come from a different node than the source of the dependency going back to pending   The edges from the "From" will be removed first 
//  Coercion is an expensive process, so we cache the result of coercing to other attribute types.   We can afford using a hashmap here because attributes are interned, and their lifetime doesn't   exceed a build 
//  Detach the process from the parent terminal/console 
//  This is the first time we've seen the module, so register with conflict resolver. 
//  TODO: Whenever we allow _user_ services to be injected, this would have to know   from which classloader we need to load the service 
//  Source file has not been compiled before, or its include file graph has changed in some way   Calculate the include file graph for the source file and mark for recompilation 
//  Gradle core plus worker implementation classes 
//  TODO: Does a static library really have any runtime elements?
//  todo CC: check that it ok to do this if configurations have attributes 
//  Prefer direct transformation over indirect transformation 
//  Classes or resources requested, some Jars found, let's prefer these 
//  Check if type is Factory<? extends ElementType> 
//  The default name for a model is the name of the Java interface 
//  Compile the javascript file with the options we've created 
//  We should never attempt to join strings so if you see this, there's a problem 
//  Create a new group for tasks or configure project 
//  If we've never resolved, must resolve 
//  On Linux, we assume swift is installed into /opt/swift 
//  This already throws when creating `apiElements` so be eager to have a clear error message 
//  2 or more lines that look like stack trace elements 
// for example: ':a SKIPPED' or ':foo:bar:baz UP-TO-DATE' but not ':a' 
//  Maintain a hierarchy of all progress operations in progress — heads up: this is a *forest*, not just 1 tree 
//  Already have a hard dependency, this optional dependency is not pending. 
//  If the client has not set a location for SOURCE_OUTPUT, javac outputs those files to the CLASS_OUTPUT directory, so clean that instead. 
//  Literal followed by *: matches #3 above 
//  This may be thrown by the caller of this method at a later time 
//  Exclude rules 
// The maximum number of times to retry a request when S3 responds with a http 5xx error 
//  most outer class is now element 0 
//  3.x - 4.6 works on Java 7 - 8 
//  First need to populate the default variant version mapping strategy with the default values   provided by plugins 
//  Any available tool chain 
//  Lock is held while creating ClassLoader - nothing else can happen while this is running 
//  Treat all models returned to the action as part of the same object graph 
//  We don't use Attribute.INTENSITY_BOLD_OFF as it's rarely supported like Windows 10 
//  The wrapper uses the .ok file to identify distributions that are safe to use.   If we delete anything from the distribution before deleting the OK file, the   wrapper will attempt to use the distribution as-is and fail in strange and unrecoverable   ways. 
//  may be we have C[k1:v1, k2:v2] -> should become (C)([k1:v1, k2:v2]) 
//  A new module. Check for conflict with capabilities and module replacements. 
//  attributes 
//  return silently when directory doesn't exist 
//  so "leaks" into the public API of this component 
//  this.instantiator = AsmBackedClassGenerator.getInstantiatorForNext() 
//  Log configuration 
//  Isolate parameters in this thread prior to starting work in a separate thread 
//  not holding the cache lock, can stop now 
//  These are used to discard references to tasks so they can be garbage collected 
//  Generate inputReferences() method 
//  Special handling for artifacts declared for optional dependencies 
//  the following only needs to be done serially to preserve ordering of dependencies in the graph: we have visited the edges   but we still didn't add the result to the queue. Doing it from resolve threads would result in non-reproducible graphs, where   edges could be added in different order. To avoid this, the addition of new edges is done serially. 
//  Only false if no declared outputs AND no Task.upToDateWhen spec. We force to true for incremental tasks. 
//  a local component cannot have attributes (for now). However, variants of the component   itself may. 
//  TODO - put this somewhere else 
// Making the daemon infrastructure log with DEBUG. This is only for the infrastructure! 
//  Tasks are ignored by providers if launchables is not null 
// replace wildcard '*' with '.*' 
//  now, do our processing using the antlr preprocessor results whenever possible. 
//  Note: beforeEvaluate and afterEvaluate ops do not throw, instead mark state as failed 
//  Optimizes comparisons by making sure that the 2 elements of   the pair are "sorted" by hashcode ascending 
//  Return null to remove the statement 
//  Reached the end of input, worker has crashed or exited 
//  Ignore this progress operation, and map any reference to it to its parent (or whatever its parent is mapped to 
//  This code path will always be a no-op following the changes in DefaultImmutableAttributesFactory   However this code will have to remain forever while the other one should be removed at some point (Gradle 7.0?) 
//  Protects the following state 
//  Still starting up 
//  Show the direct cause of the last contextual cause only 
//  populates descriptors, last descriptor in wins for a given architecture 
//  We have a cached version, but it might be out of date, so we tell the upstreams to revalidate too 
//  1.1, 1.2 
//  determine the package name :( 
//  Force the user home services to be stopped first, the dependencies between the user home services and the global services are not preserved currently 
//  TODO: do not reference mutable state 
//  At this stage, 'strictly' implies 'requires'. 
//  Invert the map of (file extension -> UTI) pairs to   (UTI -> [file extension 1, ...]) pairs. 
//  A primitive type 
//  We could do this in Java, which would be easier. However, Twirl only has a Java interface in version 1.3+   If we used Java here then Gradle's TwirlCompiler would need to support both ScalaMethod for Twirl 1.0-1.2 and Java's Method for Twirl 1.3+   Method definition: https://github.com/playframework/twirl/blob/1.3.12/compiler/src/main/scala/play/twirl/compiler/TwirlCompiler.scala#L167 
//  clean up comments and new lines 
//     private ClassLoader methodParamClassLoader; 
//  Managed internal views are allowed not to be implemented by the default implementation 
//  equality has been tested before so we know groups are different 
//  Checking if there is a type variable to resolve, since resolving the type variable via `TypeToken` is quite expensive. 
//  if found only one project dependency - return it, otherwise call the next resolver 
//  invoke the typed setter 
//  All requests completed, write response 
//  Don't render empty 'requested' reason 
//  guessing right side part of a mapping 
//  Assume an infrastructure problem 
//  this.metaClass = <value> 
//  Remove Kotlin DSL and Kotlin jars 
//  maybe it matched through coercion 
//  Start the download in another thread and wait for the result 
//  '\\\r\n' discarded from stream 
//  Make sure file order is always consistent 
//  If previous resolve failed, no point in re-resolving 
//  If we are pretending that we don't have a sourcepath, the compiler will   look on the classpath for sources. Since we don't want to bring in any   sources implicitly from the classpath, we have to ignore source files   found on the classpath. 
//  Dependencies de-duplication 
//  we have for example a class name A, are in class X   and there is a nested class A$X. we want to be able   to access that class directly, so A becomes a valid   name in X. 
//  we're writing 2 copies of the resource: one relocated, the other not, in order to support `getResource/getResourceAsStream` with   both absolute and relative paths 
//  Cannot visit local artifacts until transform has been executed 
//  Note the order in which the build phase are added is important 
//  the "status" attribute is mandatory, so if it's missing, we need to add it 
//  Stop cancelling before sending end-of-input 
//  GENERATE private <type> <property-field-name>; 
//  Handler to detect Gradle metadata redirects 
//  Task is not required - skip it 
//  NOTE: we use non-blocking IO as there is no reliable way when using blocking IO to shutdown reads while   keeping writes active. For example, Socket.shutdownInput() does not work on Windows. 
//  If they change, continuity of the IDs will be broken. 
//  Zero or more * characters followed by at least one !* 
//  We can only have attributes if we have the factory, then need to copy 
//  We don't care about producing nodes that haven't finished yet 
//  The eclipse workspace contains projects from root and included builds. Check projects from all builds   so that models built for included builds do not consider projects from parent builds as external. 
//  Broken version 
// no mode infos available - fall back to defaults 
//  start of tag marker 
//  add groovy-ant to bring in Groovydoc for Groovy 2.0+ 
//  No hard dependency, queue up pending dependency in case we see a hard dependency later. 
//  TODO: Assumes there's a single 'main' Swift component 
//  the ansi escapes. 
//  It is possible that multiple threads will execute this branch concurrently, when the type is missing. However, the contract for `get()` below will ensure that   only one thread will actually generate the implementation class
//  Index of the artifact set == the id of the artifact set 
//  Version not found at this base path 
//  NOTE: Windows uses Path, but allows asking for PATH, and PATH         is set within builder object for some things such         as CommandLineIntegrationTest, try PATH first, and         then revert to default of Path if null 
//  Use Java serialization for everything else 
//  Save the processed metadata for next time. 
//  TODO:LPTR Should be @Nested with @Console inside 
//  We need to add missing files as source roots, since the package name for deleted files provided by IncrementalTaskInputs also need to be determined. 
//  ignore classes in method bodies 
//  There are only enough entries to make up 1 block, so move the entries of the right sibling into   this block and discard this block. Might also need to merge the parent 
//                 resolution.setLibraryBinary(null); 
//  A path, either "" or <> delimited 
//  If we get here, we have no idea how much memory the worker is using 
//  Work around some bugs in Input.skip() 
//  the ansi escapes for piping it into ansi color aware commands (e.g. less -r) 
//  remove build listener 
//  core javadoc options 
//  Need to make sure we remove duplicates, so we can't just compose iterators from source collections 
//  The provider is of compatible type and the element was either already realized or we are removing a provider to the element 
//  And now let's make sure we do not have another version of that virtual platform missing its metadata 
//  Current Model 
//  we add a package if there is none yet and the module has one. But we   do not add that if the type is a ConstructedClassWithPackage. The code in ConstructedClassWithPackage   hasPackageName() will return true if ConstructedClassWithPackage#className has no dots.   but since the prefix may have them and the code there does ignore that 
//  PatternFilterable overrides to broaden return type 
//    Generate factory class   
//  java.lang.Object found, which is not a test class 
//  If there are 'pending' dependencies that share a target with any of these outgoing edges,   then reset the state of the node that owns those dependencies.   This way, all edges of the node will be re-processed. 
//  the regular typed setter 
//  Inject 
//  Axe everything after the expected exception 
//  Use a Class-Path manifest JAR to circumvent too long command line issues on Windows (cap 8191)   Classpath is huge here because it's the test runtime classpath 
//  API first 
//  stderr of Gradle is redirected to stdout of xcodebuild tool. To work around, we consider xcodebuild stdout and stderr as   the error output only if xcodebuild failed most likely due to Gradle. 
//  Treat all errors as warnings, for backwards compatibility 
//  tag::host-and-path[] 
//  Just the minimal stuff necessary for the worker infrastructure 
//  unclear what the best thing to do here would be 
//  TODO wolfs: Move these identifiers to the actual strategy classes when they live in :snapshots 
//  May (or may not) be mutable - unpack the state 
//  Host: x86   Target: ia64 
//  Previously traversed but new constraints no longer pending, so partial traversing 
//  ...  end::sample[] 
//  MODULE_WORKING_DIR doesn't seem to work correctly and MODULE_DIR seems to be in `.idea/modules/<path-to-subproject>`   See https://youtrack.jetbrains.com/issue/IDEA-194910 
//  Note: order is crucial here. Nodes are traversed through these states in the order defined below 
//  Ignore 
//  verbose output is written to stderr for some reason 
//  V 
//  These errors happen if the JNI lib is not available for your platform.   But since we are on ANSI friendly platform, assume the user is on the console. 
//  in order to avoid tracking the set of enqueued nodes 
//  we assume generated file collections have no build dependencies 
//  Always need the files, as we need to run the transform in order to calculate the output artifacts. 
//  For each candidate node, add it to the preceding nodes. 
//  Add tasks to build various kinds of components 
//  Don't need these things, they're provided by the runtime 
//  Loop over all listed versions, sorted by LATEST first 
//  is method that returns Boolean is not a getter according to JavaBeans, but include it for compatibility with Groovy 
//  The following code was patched according to the following PR: https://github.com/fusesource/jansi/pull/70 
//  if we reach this point it means the node selection was restarted, but   effectively it has the same incoming edges as before, so we can return   the result we computed last time 
//  Create test suite test task 
//  Protects the following fields 
//  This happens when the connection between the worker and the build daemon is closed for some reason,   possibly because the build daemon died unexpectedly. 
//  not a valid signature
// remember if module id was annotated 
//  property requires >= JAXP 1.5 / Java8 
//  Capture non-file input changes 
//  Add the items in this page of results to the list we'll return. 
//  This will cause problems on Windows if the path to the Gradle executable that is used has a space in it (e.g. the user's dir is c:/Users/Luke Daley/)   This is fundamentally a windows issue: You can't have arguments with spaces in them if the path to the batch script has a space   We could work around this by setting -Dgradle.user.home but GRADLE-1730 (which affects 1.0-milestone-3) means that that   is problematic as well. For now, we just don't support running the int tests from a path with a space in it on Windows.   When we stop testing against M3 we should change to use the system property. 
//  TODO - should iterate over each candidate until we successfully copy into the cache
//  TODO: Replace with native test task
//  Must close each input first 
//  64 bit   32 bit 
//  prevent file system change events when generated content 
//  there are no left candidate, do not bother checking other attributes 
// partial match 
//  TODO:lptr this should be added only if the scan plugin is applied, but SnapshotTaskInputsOperationIntegrationTest     expects it to be added also when the build cache is enabled (but not the scan plugin)
//  Based on https://github.com/playframework/twirl/blob/1.3.13/compiler/src/main/scala/play/twirl/compiler/TwirlCompiler.scala#L156     
//  no-op 
//  path(Type) 
//  Find the status line for the previous record of this task 
//  Inherit implementation dependencies 
//  Register the domain object 
//  Temporary Classpath implementation for new jvm component model 
//  Special case "build successful" when there is no result object to send 
/*              * NOTE! The JDK code to create SSLContexts relies on the values of the given system properties.             *             * To prevent concurrent changes to system properties from interfering with this, we need to synchronize access/modifications             * to system properties.  This is best effort since we can't prevent user code from modifying system properties willy-nilly.             *             * The most critical system property is java.home. Changing this property while trying to create a SSLContext can cause many strange             * problems:             * https://github.com/gradle/gradle/issues/8830             * https://github.com/gradle/gradle/issues/8039             * https://github.com/gradle/gradle/issues/7842             * https://github.com/gradle/gradle/issues/2588              */
//  append full stack trace 
//  tag::custom-task-class[] 
//  Use the file from the cache when it does not 
//  see if the grammar if out-of-date by way of its super-grammar(s) as gleaned from parsing the grammar file 
//  This is a performance optimization. Most modules do not declare capabilities. So, instead of systematically registering   an implicit capability for each module that we see, we only consider modules which _declare_ capabilities. If they do,   then we try to find a module which provides the same capability. It that module has been found, then we register it.   Otherwise, we have nothing to do. This avoids most of registrations.
//  Use a dummy security manager, which hacks the application classpath into the system ClassLoader 
//  GENERATE this.services() 
//  A reference to this class 
//  checks if it's a derived platform 
//  Discard actions after execution 
//  Set explicit build file, if required 
//  Gradle's log levels correspond to slf4j log levels   as implemented in OutputEventListenerBackedLogger.   These levels are mapped to java.util.logging.Levels   corresponding to the mapping implemented in the   SLF4JBridgeHandler which is installed by this logging system. 
//  Not the first g++ in the path, needs the path variable updated 
//  Ivy can resolve files from multiple hosts, so we need to look at all   of the possible URLs used by the Ivy resolver to identify all of the repositories 
//  When age == 0, verified since the start of this build, assume the meta-data hasn't changed 
//  Keep this expression 
//  retrieve content from URL and write to output 
//  Default Eclipse JRE paths:   https://github.com/eclipse/eclipse.jdt.debug/blob/master/org.eclipse.jdt.launching/plugin.xml#L241-L303 
//  Callable<? extends String> 
//  Consider variant aware components with no buildable binaries as non-buildables 
// the default 
//  Only use this for top level project scripts 
//  Any available Visual Studio >= 2019 
//  TODO: Make plan executor respond to changes in parallelism configuration 
//  TODO: Change the default location for these reports to follow the convention defined in #configureReportOutputDirectory
//  do nothing 
//  An application ClassLoader: Inspect class to collect up the classpath for it 
//  do not include module-info files, as they would represent a bundled dependency module, instead of Gradle itself 
// We might leave that in if we decide it's a good idea for an extra safety net. 
//  User scope is expected to be persisted in the global cache since 4.0. 
// The matching is very simple at the moment but it should solve majority of cases.  It operates using String#contains and it tests either requested or selected module.
//  Move default values into body of closure, so they can use <inputs-lvar> 
//  Check that given daemon still exists in registry - a daemon registry could be removed and recreated between checks 
//  could make resolveDependencies() cache its result for later use by GenerateIdeaModule 
//  need to validate that the selected configuration still matches the consumer attributes   Note that this validation only occurs when `dependencyConfiguration != null` (otherwise we would select with attribute matching)
//  rename project dependencies 
//  Convert Swift-like macros to a Map like NativeCompileSpec expects 
// TODO:HH installTask.dependsOn(executable)
//  Will create `ivy.xml` even for Maven publishing! (as long as `Upload.uploadDescriptor == true`) 
//  The directory is now empty so delete it 
//  Take a deep copy of the compilerArgs because the following methods mutate it. 
//  NOTE: might make sense to respect per-compile-task log level 
//  Prefer 64-bit tools when building on a 64-bit OS 
//  No separating whitespace between the #define and the name 
//  we don't decorate everything in BuildListener, just projectsLoaded/projectsEvaluated 
//  as we don't have this right now we simulate it by reaching up the tree. 
//  Do nothing. 
//  Can get duplicate start events 
//  Copy built-on-demand state 
//  Lower or equal priority but higher version, keep higher scope and exclusions 
//  Any available Visual Studio >= 2017 
//  check module static imports (for static inner classes) 
//  because we need the attributes to be computes lazily too, because of component metadata rules. 
//  type 1 = ? extends T 
//  GENERATE new ConventionAwareHelper(this, getConvention()) 
//  Only download in parallel if there is more than 1 component to download 
//  Otherwise, just reuse previous result 
//  Rethrow the first failure 
// this does not change 
//  On rare occasions, exitValue == 0 when the process is expected to fail, and the error output indicates failure. 
//  2) create an AntlrTask for this sourceSet following the gradle 
//  Track all unused labels to display future progress operation 
//  Include as binary when the target project is not included in the workspace 
//  Collect changes that would trigger a rebuild 
//  if there is a cause, it's an invalid name exception 
//  TODO - add linkRenderer.link(property) 
//  Already started 
//  Start task execution if necessary: this is required for building plugin artifacts,   since these are built on-demand prior to the regular start signal for included builds. 
//  Only expand the thread pool if there is work in the queue or we know that work is about to be submitted (i.e. force == true) 
//  from this point down, the daemon is 'busy' 
//  Callable<S> 
// 2) new module is a replacement to a module we've seen already, register conflict and return 
// builds old model of resolved dependency graph based on the result events 
//  Any available Swift compiler <= 4 
//  Have not visited this node yet. Push its successors onto the queue in front of this node and visit   them 
//  This is a special case for backwards compatibility: it is possible to have   a cycle where the root component depends on a library which transitively   depends on a different version of the root module. In this case, we effectively   allow 2 modules to have the same capability, so we filter the nodes coming   from transitive dependencies
//  If any of the input values are not available for this selection, ignore the rule 
//  throw new ReadOnlyPropertyException(name, <view-type>.class) 
// add description only to the first module 
//  Order is significant 
/*         When writing a file into the filestore a marker file with this suffix is written alongside,        then removed after the write. This is used to detect partially written files (due to a serious crash)        and to silently clean them.      */
//  Any available Visual Studio >= 2015 
//  The file names passed to -cp are canonicalised by the JVM when it creates the system classloader, and so the file names are   lost if they happen to refer to links, for example, into the Gradle artifact cache. Try to reconstitute the file names   from the system classpath 
//  can be null in tests, ResolveState cannot be mocked   can be null in tests, ComponentState cannot be mocked 
//  Generate args 
//  Only use for system Java/Groovy classes; arbitrary use on the build classpath will result in class/jar leaks. 
//  Snapshot POMs use -SNAPSHOT instead of the timestamp as version, so validate against the expected id 
//  No need to resolve type parameters if the method is from the same class. 
//  Any available Visual Studio >= 2012 
//  We throw away all state between builds 
//  note: this is here to override the default Groovy Collection.findAll { } method. 
//  Not yet implemented 
//  Collect only the shortest paths 
//  this configuration is a child of toAdd, so no need to add it 
//  Reached the end of input, worker has exited without failing 
//  don't evaluate children, see if we know it's without validating it 
//  Collect any container level add actions then add the object specific action 
//  Should ask the annotation handler to figure this out instead
//  Transient fields 
//  Have to alter the "type" of the artifact to match what is published 
//  Cannot configure Slf4j logger. This will happen if:   - Tests are executed with a custom classloader (e.g using `java.system.class.loader`)   - Tests are run with `--module-path`, effectively hiding Gradle classes
//  10%   384M 
//  Any available Visual Studio >= 2013 
// then 
//  Search in the standard installation locations 
//  We do not consider injecting constructors public API 
//  For now, 'requires' implies 'prefers', and 'strictly' implies 'requires'   Only publish the defining constraint. 
//  Clear the user's environment 
//  Order is optimised for humans looking at the log. 
//  where the transform class is loaded from) 
//  For test suites (including suite-like custom Runners), if the test suite class   matches the filter, run the entire suite instead of filtering away its contents. 
//  not holding the cache lock, flush is done so notify flush thread and continue 
//  attribute name 
//  Include file graph for this source file has not changed, skip this file 
//  When deriving variants for the Java ecosystem, we actually have 2 components "mixed together": the library and the platform   and there's no way to figure out what was the intent when it was published. So we derive variants, but we also need   to use generic JAVA_API and JAVA_RUNTIME attributes, instead of more precise JAVA_API_JARS and JAVA_RUNTIME_JARS   because of the platform aspect (which aren't jars but "something"). Using JAVA_API_JARS for the library part and   JAVA_API for the platform would lead to selection of the platform when we don't want them (in other words in a single   component we cannot mix precise usages with more generic ones)
//  There are only enough entries to make up 1 block, so move the entries of the left sibling into   this block and discard the left sibling. Might also need to merge the parent 
//  JGit properties work from their relocated locations and conflict if they are left in place. 
//  Attempt to determine whether the compiler is the correct implementation 
//  we don't know about this kind of archive task 
//  Compile all secondary routes files first 
//  Read configuration from stdin 
//  since we need access to the method and that it's weakly referenced   we always need to double check that it hasn't been collected 
//  found the first project dependency 
//  If the Java plugin is applied, we want to express that the "compile" and "runtime" variants   are mapped to some attributes, which can be used in the version mapping strategy.   This is only required for POM publication, because the variants have _implicit_ attributes that we want explicit for matching 
//  fail fast, this should not happen 
//  Only unpack one level of Providers, since Provider<Provider<>> is not supported - we don't need two levels of laziness. 
//  Must prepare to bind inputs first 
//  One or more '*' followed by one or more non-wildcard: matches #2 above 
// already handled elsewhere 
// close all streams and redirect IO 
//  If there's more than group, merge them into a group set 
// Keeps the class set analysis of the given JavaCompile task 
//  This test class should be loaded via the custom system ClassLoader 
//  this.getClass() 
//  If no implementation classpath has been provided, just use the application classloader 
//  read entire response 
//  Didn't find node at path 
//  Already invoking a method on the mix-in 
//  Compare 2 static selectors semantically 
//  Remove compile and AST types from the Groovy loader 
//  now handle dirs 
//  Have visited all of this node's successors 
//  Kotlin passes these types for its own basic types 
//  subclass hook, allowing us to fake the context for testing 
//  Enhance already reported failures 
// checks if candidate project is dependent of the origin project with given configuration 
//  will be removed in 6.0 
// replacement candidates are the only important candidates 
//  We only cache the result of parsing the Maven settings files, but allow this value to be updated in-flight   via system properties. This allows the local maven repo to be overridden when publishing to maven   (see http://forums.gradle.org/gradle/topics/override_location_of_the_local_maven_repo). 
//  fact. We check here for ConstructedClassWithPackage. 
//  Inject missing interfaces to support the usage of plugins compiled with older Gradle versions.   A normal gradle build does this by adding the MixInLegacyTypesClassLoader to the class loader hierarchy.   In a test run, which is essentially a plain Java application, the classpath is flattened and injected   into the system class loader and there exists no Gradle class loader hierarchy in the running test. (See Implementation   in ApplicationClassesInSystemClassLoaderWorkerImplementationFactory, BootstrapSecurityManager and GradleWorkerMain.)   Thus, we inject the missing interfaces directly into the system class loader used to load all classes in the test.
//  Need to lock the cache in order to write to the module metadata store 
//  put var #1 ('foo') on the stack   push the constant Class onto the stack   push int 1 or 0 (interpreted as true or false) onto the stack 
//  As an optimization first check if the method name is among the candidates before we construct an equivalence wrapper 
//  Need to perform the actual resolve
//  else, unchanged; check next file 
//  fall back to standard out 
//  Token concatenation is only allowed inside a #define body   Arbitrary tokens won't resolve to an include path   Treat both these cases as an unresolvable include directive 
//  Track currently associated label with its progress operation 
//  Couldn't find a registration for the given type 
//  creating before locking, have to create the most flexible setup 
//  try to reconstruct the exception 
//  Attempt to merge with the right sibling 
//  We have an exclusive lock (whether we asked for it or not). 
//  Already at the front. If not at the front, need to recreate 
// copy configuration from parent descriptor 
//  + setter methods for the above - assume we’ve defined them 
//  List modules based on metadata files, but only if we won't check for maven-metadata (which is preferred) 
//  used in integration tests 
//  end::custom-task-class[] 
/*         Note: there is deliberately no internal synchronizing or caching at this level.        Class generation should be performed behind a ManagedProxyFactory.      */
//  Should use `InstantiatorFactory` instead to pick up some validation, but this is currently somewhat expensive
//  TODO: Add other build like files `build.gradle.kts`, `settings.gradle(.kts)`, other `.gradle`, `gradle.properties`
//  Something else may have removed it 
//  _changed_ since last execution, possibly by another task 
//  This can happen when a method fails which this method depends on 
//           dynamicObjectHelper = <init>        }        return dynamicObjectHelper;   } 
//  Transforms do not require project state 
//  The only reason for this unit test is to verify that no StackOverflowException is being thrown when   many patterns are passed to getPatternsMatcher. See https://github.com/gradle/gradle/issues/10329 
//  TODO IntSet 
//  GENERATE public ConventionMapping getConventionMapping() { 
//  make sure we can store it in order or we'll have surprises on deserialization 
//  <inputs-lvar> = <inputs-field> 
//  default packages do not contain classes like these 
//  Include the display name anyway 
//  ...   end::custom-task-class[] 
//  It's important that we do not block waiting for the lock while holding the project mutation lock.   Doing so can lead to deadlocks. 
//  An @Ignored class, ignore the event. We don't get testIgnored events for each method, so we have   generate them on our own 
//  Package private accessor used by MessageDigestHasher.putHash for performance reasons 
//  FileCollection is-a Iterable, Buildable and TaskDependencyContainer, so check before checking for these things 
//  there is at least one candidate which does NOT provide this attribute 
//  Matches: task <identifier>(<options-map>) 
//  TODO validations on method: synthetic, bridge methods, varargs, abstract, native
//  non leading ':' 
//  Already seen this class, skip it 
//  Iterate over unicode characters 
//  Get the metadata first to see if it's there 
//  Should use some variation of DefaultClassMap below to associate values with classes, as currently we retain a strong reference to each value for one session after the ClassLoader   for the entry's key is discarded, which is unnecessary because we won't attempt to locate the entry again once the ClassLoader has been discarded
/*      * When the artifacts declared in a component are modified for publishing (name/classifier/extension), then the     * Maven publication no longer represents the underlying java component. Instead of     * publishing incorrect metadata, we fail any attempt to publish the module metadata.     *     * In the long term, we will likely prevent any modification of artifacts added from a component. Instead, we will     * make it easier to modify the component(s) produced by a project, allowing the     * published metadata to accurately reflect the local component metadata.      */
/*          * SourceSet has no access to configurations where we could ask for a lenient view. This                * means we have to deal with possible dependency resolution issues here. We catch and                * log the exceptions here so that the Eclipse model can be generated even if there are         * unresolvable dependencies defined in the configuration.         *         * We can probably do better by inspecting the runtime classpath and finding out which         * Configurations are part of it and only traversing any extra file collections manually.                 */
//  Remove the "daemon starting" message 
//  need to take copy to prevent ConcurrentModificationException 
//  Ignore overrides of Object and GroovyObject methods 
//  If this default is ever changed, ensure the documentation on PathSensitive is updated as well as this guide:   https://guides.gradle.org/using-build-cache/#relocatability 
//  Index of the artifact set == the id of the artifact set, but reversed when sort order is dependency first 
//  IMPORTANT: return must be closed when done with. 
//  check Jar exists 
//  Add all included builds from the command-line 
//  Absolute coordinate system 
// done writing data, release any resources 
//  Assume all the other compilers are ok, if they happen to be installed 
//  The public result for the configuration has been calculated.   It is an error to change anything that would change the dependencies or artifacts 
//  JVM args that must be used for the build JVM 
//  GENERATE getAsDynamicObject().invokeMethod(name, (args instanceof Object[]) ? args : new Object[] { args }) 
//  tag name 
//  GENERATE public MetaClass getMetaClass() { 
//  This should pass 50% of the time 
//  GENERATE public Convention getConvention() { return getAsDynamicObject().getConvention(); } 
//  Callable<? extends T> 
//  Reuse parent label if possible 
// We need to ensure that the conflict is orderly injected to the list of conflicts  Brand new conflict goes to the end  If we find any matching conflict we have to hook up with it 
//  Any Swift 5.x compiler 
//  Do nothing since the only side effect is that we wouldn't   be able to log the plugin descriptor file name.  Shouldn't   be a reasonable scenario where this occurs since these   descriptors should be generated from real files. 
//  If there is no known last descriptor, associate it with the root test suite 
/* This is an internal option, it's used in com.sun.tools.javac.util.Names#createTable(Options options). The -XD backdoor switch is used to set it, as described in a comment        in com.sun.tools.javac.main.RecognizedOptions#getAll(OptionHelper helper). This option was introduced in JDK 7 and controls if compiler's name tables should be reused.        Without this option being set they are stored in a static list using soft references which can lead to memory pressure and performance deterioration        when using the daemon, especially when using small heap and building a large project.        Due to a bug (https://builds.gradle.org/viewLog.html?buildId=284033&tab=buildResultsDiv&buildTypeId=Gradle_Master_Performance_PerformanceExperimentsLinux) no instances of        SharedNameTable are actually ever reused. It has been fixed for JDK9 and we should consider not using this option with JDK9 as not using it  will quite probably improve the        performance of compilation.        Using this option leads to significant performance improvements when using daemon and compiling java sources with JDK7 and JDK8. */
//  cleanup 
//  there is nothing to be done. 
//  Note: used by generated subtypes 
//  Invalid lock state, need to do a real resolution to gather locking failures 
//  Apply strategies for "all variants" 
//  not a single candidate 
//  exclude the dependencies already provided by SCALA_CONTAINER; prevents problems with Eclipse Scala plugin 
//  A sibling node 
//  When the state changes to `SHOULD_RUN`, the dependencies need to be reprocessed since they also may be required now. 
//  Node must be at the predecessor state before calculating dependencies 
//  NOTE : locateOrBuildGenerationPlan populates the generationPlans map 
//  Path == prefix 
//  since we use the main source set, we need to make sure the compile classpath and runtime classpath are properly configured 
//  -r : Add files to static archive, creating if required   -c : Don't write message to standard error when creating archive   -s : Create an object file index (equivalent to running 'ranlib') 
//  Trailing slash on name indicates entry is a directory 
//  Exclude tasks from `buildSrc` 
//  Initialize and collect any new outgoing edges of this node 
//  Don't need to do anything 
//  Select the first variant 
//  if we already hold the project lock for this project 
//  Initial state. Only path and some projections are known here   All projections are defined   Private data has been created, initial rules discovered   Default values have been applied 
//  if the worker has not reported memory usage yet for some reason, or does not support it, 
// for example: ':hey' or ':a SKIPPED' or ':foo:bar:baz UP-TO-DATE' but not ':a FOO' 
// without it, the parent hangs without receiving the message above (flushing does not help). 
//  save name before redirect 
//  Wrap the result processor chain up in a blocking actor, to make the whole thing thread-safe 
//  HttpClient is used as a parameter of a public method 
//  Path is a descendant of this 
//  Overrides the global ClasspathFingerPrinter, currently need to have the parent parameter 
//  Resolve the dependency graph 
//  We have a matching component id that was rejected. These are handled later in the resolution process   (after conflict resolution), so it is not a failure at this stage. 
//  Don't serialize the causes - we'll serialize them separately later 
//  Variants 
//  Nothing found - do a second pass 
//  No auto-applied plugins available 
//  Ignore, as the node in the other build's execution graph takes care of this 
//  only if there are no conf defined in sub elements 
//  A new top level node, implicitly finish the previous node 
//  Use an EclipseProject to reference a project 
//  When running a test in a daemon executer, the input is buffered until a   newline char is received 
//  We could do a better job of figuring this out 
//  end::options-of-dynamic-processor[] 
//  in theory we don't need the synchronized here, but let's be safer in the beginning 
//  Maven repos are handled by MavenPlugin 
//  Ignore inner classes 
//  Avoid iterating on candidates if there's no requested attribute 
//  Fail fast 
//  Run any actions to add/modify dependencies 
//  Keep until the listener is created 
//  need to wrap all dependencies to force them 
/*      * Configures the project and all of its sub-projects, including task discovery and binding model rules.      */
//  Since Java 9, version should be X instead of 1.X   However, to keep backward compatibility, we change from 11 
// so that we don't miss out default tasks 
//  On macOS, we assume co-located Xcode is installed into /opt/xcode and default location at /Applications/Xcode.app     We need to search for Clang differently on macOS because we need to know the Xcode version for x86 support. 
//  Clean the interrupted status   because some test class processors do work here, e.g. JUnitPlatform 
//  iterate from the inner most to the outer and check for classes   this check will ignore a .class property, for Example Integer.class will be   a PropertyExpression with the ClassExpression of Integer as objectExpression 
//  There is no setter for this property 
//  We know that we're running single-threaded here, so we can use lenient project locking 
//  We use static private methods because private/protected methods are disallowed   in managed types. 
//  Path is Iterable, but we don't want to unpack it 
//  Source file has changed 
//  Skip prebuilt libraries 
//  ModelRegistrations.Builder methods 
//  Not attached to a console 
//  If we broke out of the comparison because there was a difference, we can reuse the snapshot of the new element 
//  else, throw it away 
//  any of the ansi sequences. 
//  ModelRegistry methods 
//  Add an assemble task for each binary and also wire the development binary in to the `assemble` task 
// configure verbosely only if arguments do not specify any log level. 
//  The selector failed or the module has been deselected. Do not attach. 
// See: NameValidator.FORBIDDEN_CHARACTERS 
//  Always assume a candidate from a lock will satisfy the latest version selector 
//  Map the arguments of the argument from this expression 
//  Mix in to Groovy DSL 
//  class in root package - should not happen 
//  with a lower case letter anymore 
//  this is a published artifact 
//  cancel OP_WRITE selection 
//  User likely doesn't care about daemons that stopped a long time ago 
//  Mappings between public and impl types   If the list of mappings grows we should move it to a data structure 
//  Remove the handler 
//  pre-compute the hashcode as it's going to be used anyway, and this object   is used as a key in several hash maps 
//  Any available GCC implementation (including mingw, cygwin, but not clang) 
//  Note: this may be a temporary measure while existing infrastructure is being ported to managed model elements 
//  Invoke the setter method, to pick up type coercion 
//  END 
//  We know it's an archive, but not what kind of archive   We know it's an artifact, but that's all we know for sure 
//  Adding an optional dependency: see if we already have a hard dependency on the same module 
//  GENERATE public <return-type> <setter>(<type> v) { <return-type> v = super.<setter>(v); __<prop>__ = true; return v; } 
//  Rewrite the method call to match TransformedModelDslBacking#create(String, Closure), which is what the delegate will be 
//  Filter imported classes which are not available yet 
/*          * This method returns the dependencies in buckets (projects first, then modules, then files),         * because that's what we used to do since 1.0. It would be better to return the dependencies         * in the same order as they come from the resolver, but we'll need to change all the tests for         * that, so defer that until later.          */
//  Must be no higher than this scope as needs cache repository services. 
//  guard against edge cases (e.g. JUnit 4 classes with custom runners that report the class as ignored after reporting it as started) 
//  Default Xcode installation 
//  Another thread holds the lock, release the project lock and wait for the other thread to finish 
//  Transitive dependency 
//  All dependencies visited 
//  We limit the inner class lookups here by using ConstructedClassWithPackage.   This way only the name will change, the packagePrefix will   not be included in the lookup. The case where the   packagePrefix is really a class is handled elsewhere.   WARNING: This code does not expect a class that has a static            inner class in DEFAULT_IMPORTS 
//  started, update the log level 
//  tag::isolating-annotation-processor[] 
//  if not a number, i.e. 2.ABD 
//  Same value 
//  Else, ignore abstract methods on non-abstract classes as some other tooling (e.g. the Groovy compiler) has decided this is ok 
//  Add the source of the source set to the include paths to resolve any headers that may be in source directories 
//  have visited all consumers, so visit this node 
//  check custom packaging 
//  Library or executable 
//  Matches: task <arg> or task(<arg>) 
//  End of the stream 
//  Thrown when jna cannot initialize the native stuff 
//  throws T 
//  Check if type extends Factory<? extends ElementType> 
//  We could support an unfiltered DirectoryFileTree here as a cacheable root,   but because @OutputDirectory also doesn't support it we choose not to. 
//  These are here just so that ProjectInternal can implement FileOperations to work around https://github.com/gradle/gradle/issues/6027 
//  This substitution is effectively a force 
//  Without this, HTTP Client prohibits multiple redirects to the same location within the same context 
//  not provided by older client versions 
//  TODO: Locking around this state 
//  Look for parameter substitutions 
//  getProperty(this, name) 
//  Eventually convert manifest content to UTF-8 before handing it to java.util.jar.Manifest 
//  Resolve it now 
//  The name of the test class 
//  If an annotation processor is detected, we need to force Java stub generation, so the we can process annotations on Groovy classes   We are forcing stub generation by tricking the groovy compiler into thinking there are java files to compile.   All java files are just passed to the compile method of the JavaCompiler and aren't processed internally by the Groovy Compiler.   Since we're maintaining our own list of Java files independent of what's passed by the Groovy compiler, adding a non-existent java file   to the sources won't cause any issues. 
//  Pass 2, compile everything except buildscript {}, pluginRepositories{}, and plugin requests, then run 
//  Update timestamp so that working directory is not garbage collected 
//  Find first position where values are different 
//  keep the ordering we had in earlier gradle versions 
//  All local/cached options failed, get directly 
//  Should use stronger modelling for this and make the set of tools open, rather than hard-coding here 
//  Remove .pdb file if present 
//  TODO: Enable this by default when toolVersion >= 6.0.0 if it's stable enough. 
//  Target module can change, if this is called as the result of a module replacement conflict. 
//  ProjectEvaluationListener 
//  For project dependencies de-duplication   Ignore scope on purpose   Ignore version because Maven doesn't support dependencies with different versions on different scopes   Ignore exclusions because we don't know how to choose/merge them   Consequence is that we use the highest version and the exclusions of highest priority dependency when de-duplicating   Use Maven Dependency "Management Key" as discriminator: groupId:artifactId:type:classifier
//  import checks that stack is not empty 
//  Write plain content to stdout and rich content to stderr 
//  Allow the publication to participate in incremental build 
//  Non-null when the result of visiting this file can be reused 
//  Determine the actual sources to clean/compile 
//  5) register fact that antlr should be run before compiling 
//  Read and verify count 
//  we have C[*:map] -> should become (C) map 
//  These versions couldn't handle milestone patches 
//  Only when this node has a transitive incoming edge 
//  TODO given that all the closures are from the same file, we should do the relativising once.        that would entail adding location information to the model {} outer closure.
//  avoiding us to implement a costly visitor and potentially missing edge cases 
//  By default we assume your Unix tty can handle ANSI codes.   Just wrap it up so that when we get closed, we reset the 
//  Else, ignore 
//  Calculated on demand 
//  If the operation hasn't finished normally (because of a shortcut or an error), we close it without a cache key 
//  isOpen was added in gradle 5.6. for 5.5 we default to true 
//  used only as defaultconf, not used for 
//  Context of the app under test. 
//  We don't do anything here, as older consumers call this method when the project connection is closed but then later attempt to reuse the connection 
//  GENERATE getAsDynamicObject().hasProperty(name); 
//  Strategy changes in a parent configuration do not affect this configuration, or any of its children, in any way 
//  Use the Jars when nothing has been requested 
//  create our own metaInf which runs after mainSpec's files 
//  Unrecognized expression or extra stuff after the expression, possibly another expression 
//  Check each unique edge in the include file graph 
//  Then use attribute specific mapping 
//  toAdd is a child, so implies this configuration 
//  Elements that may or may not be interesting only for build dependency calculation 
//  Read-only nested property with managed type 
//  Currently, we only track the major version. 
//  convert the file urls to cached jar files 
//  using a transforming classloader is only required for older buggy Groovy versions 
// calling overloaded method with extra behavior: 
//  there's an ambiguity, but we may have several variants matching the requested capabilities.   Here we're going to check if in the candidates, there's a single one _strictly_ matching the requested capabilities. 
//  Add these as separate specs, so they are not affected by the changes to the main spec 
//  path within its build (i.e. including project path)   path within the build tree (i.e. including project path)   path of the owning build 
//  No compatible daemons available - start a new daemon 
//  probably facing JDK-8046686 
//  GENERATE objectFactory.fileProperty() 
//  Badly formed arguments 
//  new value 
//  Look for a provider with that name 
//  List modules based on metadata files (artifact version is not considered in listVersionsForAllPatterns()) 
//  This is a safety net, it's unsure whether this can happen, because it's likely (certain?)   that for a specific module resolve state, all selectors are of the same type 
//  Do conflict resolution to choose the best out of current selection and candidate. 
// remove SLF4J error out like 'Class path contains multiple SLF4J bindings.'  See: https://github.com/gradle/performance/issues/375#issuecomment-315103861 
//  That is the state a node is in when it was selected but the selection violates a constraint (reject or strictly) 
// Assuming that the diagnostics were printed out to the last line. It's not bullet-proof but seems to be doing fine. 
//  Versions before 4.1 would log "CONFIGURE SUCCESSFUL" for model/action execution (but "BUILD FAILED" for task/test execution) 
//  On any line except the bottom most one, a new line simply move the cursor to the next row.   Note: the next row has a lower index. 
//  Visit the edges after sorting the components in consumer-first order 
//  Do not include implicit builds in workspace 
//  Choose explicit variant 
//  Preserve logging of headers for progress operations started outside of the build operation executor as was done in Gradle 3.x 
//  exclusions optimizations 
//  Use of a LinkedList for 2 reasons: `Set` proved to have a significant negative impact on performance   And list will see a lot of removals, which ArrayList isn't very well suited for. 
//  Only keep track of removed options that were present in the command line 
//  something happened, but we don't know what 
//  We cannot clean in progress markers, or in progress files here because   the file system visitor stuff can't handle the file system mutating while visiting 
//  tag::functional-test-junit[] 
//  Use a GradleProject to reference a project 
//  Check to see if there are any compatible idle daemons 
//  Maven adds inherited dependencies last 
//  A system class, skip it 
//  never swallow java.lang.Error 
//  Remove the "Expiring Daemon" message 
//  Make sure that map only contains Boolean.TRUE and Boolean.FALSE values and no other Boolean instances.   This is necessary because:   1. serialization/deserialization of the compile spec doesn't preserve Boolean.TRUE/Boolean.FALSE but creates new instances 
//  The contract of useCache() means we have to provide some basic synchronization. 
//  This means that the signature was not required and we couldn't generate the signature   (most likely project.required == false and there is no signatory)   So just noop 
/*  Parsing state  */
//  First step is to find an entry with the explicit inputs in the cache 
//  try to deserialize the original exception 
//  Special case some common combinations of names and paths 
//     ((PropertyInternal)<getter>()).setFromAnyValue(p);   } 
//  With multiple unclassified artifacts, choose the one with extension matching pom packaging 
//  Disallow instance fields. This doesn't guarantee that the object is immutable, just makes it less likely   We might tighten this constraint to also disallow any _code_ on immutable types that reaches out to static state 
//  restore only if there was a save operation first 
//  Nothing found locally - try a remote search for all resolve states that were not yet searched remotely 
//  Empty path, might match when more elements added 
//  If implements MethodMixIn, do not attempt to locate opaque method, as this is expensive 
//  We get only the first element here, nothing else. But Collection   forces us to use an iterator. 
//    Add constructor   
//  The changes about the interface's methods will be reported already 
// we don't really need to launch the daemon to acquire information needed for BuildEnvironment 
//  In order for the Groovy stubs to have annotation processors invoked against them, they must be compiled as source.   Classes compiled as a result of being on the -sourcepath do not have the annotation processor run against them 
//  Provide an implicit empty argument 
//  Create build configuration at the project level from all target's build configuration 
//  When implementing PropertyMixIn, do not check for opaque properties, as this can be expensive 
//  or all of them were rejected 
//  Object methodMissing(String name, Object args) 
//  not a 'Jar', not a 'test' 
//  Redraw every entry of this area 
//  This is fine, just ignore it 
//  TODO some representation of state of the inputs 
//  prefer to use the actual memory usage reported by the worker 
//  In order to use a newer version of jna the resources must not be available in the old location 
//  Exit early as we are reusing the create actions from the provider 
//  This shouldn't be the case, however, start and complete events are filtered in the prior stage when the logging level is > lifecycle   Should instead move the filtering after this stage 
//  Allow currently executing and enforced tasks to complete, but skip everything else. 
//  GENERATE objectFactory.setProperty(type) 
//  Target: x64 
//  Generate: Object[] unpackState() { state = new Object[<size>]; state[x] = <prop-field>; return state; } 
//  Callable 
// after redirecting we need to add the new std out/err to the renderer singleton 
//  Mark the connection has being handled 
//  Remove classes from core Gradle API 
//  Matches: task <method-call> 
//  Largest free block is too small 
//  This is a potential nested rule.   Visit method parameters 
//  Generated script class name must be unique - take advantage of this to avoid delegation 
//  count from left of screen, 0 = left most   count from bottom of screen, 0 = bottom most, 1 == 2nd from bottom 
//  We need to update pending count outside of withLocks() so that we don't have a race   condition where the pending count is 0, but a child worker lease is still held when   the parent lease is released. 
//  must be a @ClassRule; use the rule's class name instead 
//  By default, we push to the local cache. 
//  Copied from ToolProvider.defaultJavaCompilerName 
//  will flush any unterminated lines out synchronously 
//  no default mapping found for this configuration, map   configuration to itself 
//  Check if there are any transitive incoming edges at all. Don't traverse if not. 
//  <thead>     <tr>       <td>Block</td>       <td>Description</td>     </tr>   </thead> 
//  we're asking for a runtime variant, prefer -jars first 
//  GradleBuild tasks operate with their own build session and tree scope.   Therefore, they have their own RootBuildCacheControllerRef.   This prevents them from reusing the build cache configuration defined by the root.   There is no way to detect that a Gradle instance represents a GradleBuild invocation.   If there were, that would be a better heuristic than this. 
//  Generate new Object[] { args } 
// Logging exception here is only needed because by default Gradle does not show the stack trace 
//  Add attributes to be applied given the extension 
//  we're asking for an API variant, prefer -jars first for runtime 
//  nothing to do 
//  Always append a new line at EOF 
//  stop at super and this 
//  Don't generate method if it's not part of the view schema 
//  We have to go through URIish and back to deal with differences between how   Java File and Git implement file URIs. 
//  only check for the last byte of a multi-byte line separator   besides this, always check for '\n' 
//  non-heap spaces are not garbage collected 
//  Capture all output, lazily up until two new lines and an END_OF_TASK designation 
//  in order to make sure that the CacheEntry is not collected   while the cached class loader is still in use, we need to keep a strong reference onto 0
//  GENERATE new MixInExtensibleDynamicObject(this, getClass().getSuperClass(), super.getAsDynamicObject(), this.services()) 
//  assume EJB is the most common kind of EAR deployment 
//  Automatically substitute all available modules 
//  Force back to configure so that task graph will get reevaluated 
//  avoids creation of empty hashset 
//  full match 
//  copy one by one until the underflow has been resolved 
//  Order is important! 
//  static alias only for inner classes and must be at end of chain 
//  Task has already been run. This can happen when the owning build is used both at configuration time and execution time   This should move earlier in task scheduling, so that a worker thread does not even bother trying to run this task 
//  Disallow work-in-progress to take up more than half of the console display   If the screen size is unknown, allow 4 lines 
//  repositories 
//  Badly form args list 
//  By default, we do not push to the remote cache. 
//  For a dependency from _another_ build to _this_ build, don't make the artifact buildable   Making these artifacts buildable leads to poor error reporting due to direct task dependency cycle (losing the intervening build dependencies) 
//  this mimics the behavior of the Ant javac task (and therefore AntJavaCompiler),   which silently excludes files not ending in .java 
//  Handle trivial cases with 0 or 1 elements in both current and previous 
//  Latest is only given priority if it's in a require 
//  Should run after edges only exist between tasks, so this cast is safe 
//  Called from transformed DSL rules 
// noinspection SimplifiableIfStatement 
//  There was a breaking change after 0.8 
//  Use the loaded settings if it includes the target project (based on build file, project dir or current dir) 
//  Prefer having javac validate the location over us, by calling it first. 
//  this.super() 
//  Create a client that will match based on the daemon startup parameters. 
// in case one wants to synchronize this method,  bear in mind that it is blocking so it cannot share the same lock as others 
//  Write header 
//  Implementation provided by decoration 
//  should never happen 
//  network authentication required 
//  Determine the net exclusion for this node, by inspecting all transitive incoming edges 
//  Failure 
//  If we can detect that stdout is not a tty.. then setup 
/*             The semantics of this method are that the given action should be notified if the            Daemon is going to be terminated at the end of this build.            It is not a generic outlet for “expiry events”.            Ideally, the value given would describe the problem and not be phrased in terms of why we are shutting down,            but this is a practical compromise born out of piggy backing on the expiration listener mechanism to implement it.          */
//  Callable<String> 
//  Same serialized content - value has not changed 
//  Output events 
//  Generate: static Class generatedFrom() { ... } 
//  The hfs+ file system stores file names in decomposed form. Don't use precomposed characters on macOS, as way too few things normalise text correctly 
//  skip the UTF-8 BOM 
//  scan parent class 
//  We temporarily want to allow skipping the publication of Gradle module metadata 
//  old versions don't send a type 
// quote ', ", \, $. Probably not perfect. TODO: identify non-working cases, fail-fast on them 
//  CopySourceSpec overrides to broaden return type 
//  This will be the left most property 
//  A local, anonymous class or a private inner class - ignore the reference 
//  Alternate appending packages at beginning and end until we reach max length 
//  but all resolved ok 
// jdk5 does not have days, hours or minutes, normalizing to millis 
//  Failure to select the target variant/configurations from this component, given the dependency attributes/metadata. 
//  All items are complete. Do not release project lock and simply collect failures. 
//  Serialize configuration to daemon via the process' stdin 
//  Adding a small set with no duplicates 
//  We only need to hide "main", so only support short named symbols here. 
//  TODO: Duplicated in DefaultFileLockManager 
//  Write body 
//  Stop periodic checks 
//  Wire the antlr configuration into all antlr tasks 
//  A task created by a provider that does not understand launchables 
//  Make sure tree is removed if it exists already 
/*  how and what do we have to parse  */
//  The identity check is intentional here, do not replace with .equals() 
//  GENERATE <setter>(v) 
//  That means if the current class is not an InnerClassNode 
//  A ∩ (A ∪ B) ∩ (A ∪ C) -> A 
//  Only use this for top level settings scripts 
//  protocolVersion + lockId + type 
//  Special case for events defined prior to InternalProgressEvent 
//  element name 
//  Else, already visited 
//  boolean 
//  Use preemptive authorisation if no other authorisation has been established 
//  don't rename other types of dependencies 
//  The 'is'-getter is ignored, we can skip it in favor of the 'get'-getter 
//  if the return type doesn't use generics, then it's faster to just rely on the type name directly 
//  Defer creation of failures list, assume dispatch will succeed 
//  When Groovy coerces a Closure into an SAM type, then it creates a Proxy which is backed by the Closure.   We want to track the implementation of the Closure, since the class name and classloader of the proxy will not change. 
//  Virtual platforms require their constraints to be recomputed each time as each module addition can cause a shift in versions 
//  Supports building 32-bit binaries 
//  Remove the "Daemon will be shut down" message 
//  Here, we try to avoid using the reg exp backed pattern step, as it is expensive in terms of performance and heap usage.   There are several special cases we handle here:   1. '*'   2. '*' <literal>   3. <literal> '*'   4. <literal> '*' <literal>   5. <literal>   Everything else uses a reg exp. 
// failed to instantiate BlockJUnitRunner. try deprecated JUnitRunner (for JUnit < 4.5) 
//  we are at the first name part. This is the right most part.   If this part is in lower case, then we do not need a class   check. other parts of the property expression will be tested   by a different method call to this method, so foo.Bar.bar   can still be resolved to the class foo.Bar and the static   field bar. 
//  ordinary Groovy Gradle script   Kotlin Gradle script 
//  in the map, store a minimally populated LaunchableGradleTaskSelector that contains just the description and the path   replace the LaunchableGradleTaskSelector stored in the map iff we come across a task with the same name whose path has a smaller ordering   this way, for each task selector, its description will be the one from the selected task with the 'smallest' path 
//  the enqueue and dequeue methods are used for performance reasons 
//  remaining methods are here to make sure we didn't forget anything 
//  An internal counter used to track the number of outgoing edges   that use this selector. Since a module resolve state tracks all selectors   for this module, when considering selectors that need to be used when   choosing a version, we must only consider the ones which currently have   outgoing edges pointing to them. If not, then it means the module was 
//  Skip processing of any operations that both start and complete in the queue 
/*         TODO change this so that we extract all the information at compile time.        At the moment we use the transform to:        1. validate/restrict the syntax        2. transform rules into something more robust (e.g. foo.bar.baz {} into configure("foo.bar.baz", {})) - no dynamic propertyMissing() nonsense        3. hoist out input references (i.e. $()) into an annotation on rule closure classes to make available        This means we actually have to execute the code block in order to find the rule information within.        This is also problematic because it means we have to serialize this information into some form that fits into annotations.        Later, we will extract all the “up-front” information we need to know during compile time.        This will mean that we only need to execute the rules themselves, and not any code to actually register the rules.      */
//  Converts the binaries of a project library into regular binary instances 
//  if there are only 3 or fewer known subtypes, render them   in a single column 
//  not sure if this is required as its the parent of   deprecatedUsageLoader already
//  Worker didn't crash 
//  Classloader scope will be handled by the cache, class will be released when the classloader is. 
//  Deserialize the old value and use the equals() implementation. This will be removed at some point 
//  Time interval between the first event in the window and the last 
//  copy in case any actions mutate the store   linked list because the underlying store may preserve order   We make best effort not to create an intermediate collection if this container   is empty. 
//  Check ClassLoaders 
//  Flush and clean up 
//  Apache commons 
//  Needed to use inside lambda below 
//  Pad 
//  (macOS) Looks like: Test Case '-[AppTest.PassingTestSuite testCanPassTestCaseWithAssertion]' started.   (Linux) Looks like: Test Case 'PassingTestSuite.testCanPassTestCaseWithAssertion' started. 
//  Only initialize "name" child node if the schema has such a managed property.   This is not the case for a managed subtype of an unmanaged type that implements Named. 
//  for all commons attributes, make sure they are compatible with each other 
//  Any ProgressOperation in the parent chain has a message, the operation is considered renderable. 
/*      * Configures the project, discovers tasks and binds model rules.      */
// html does not like <a name="..."/> 
//  Missing parameter name 
//  Visit the selectors 
//  fallback to old behavior of always loading the resource 
//  Not quite immutable, see ImmutablePatternSet 
//  Should never get here, the last strategy should be a catch all
//  Add JVM args that were explicitly requested 
//  Before there was --scan, there was -Dscan or -Dscan=true or -Dscan=yes 
//  Already seen this ClassLoader 
//  some capabilities are explicitly required (in other words, we're not _necessarily_ looking for the default capability   so we need to filter the configurations 
//  there are still more than one candidate, but this time we know only a subset strictly matches the required attributes   so we perform another round of selection on the remaining candidates 
//  There has been a GC event 
//  No statements, or no statements that have an effect 
// noinspection ForLoopReplaceableByForEach 
//  if no installation can be located 
//  Matches: task <arg>{1, 3} 
//  Defaults 
//  XML declarations must be located at first position of first line 
//  2) we don't do progress logging for "downloading" 
//  Filter unexisting files as FindBugs can't handle them. 
//  CBZip2InputStream expects the opening "BZ" to be skipped 
//  try simplify 
//  We need to lock other processes out here because garbage collection can be under way in another process 
// we're making an assumption that all <pre> elements contain java code  this should mostly be true :)  if it isn't true then the syntax highlighting won't spoil the view too much anyway 
//  validate that the targetPlatform is valid 
//  Universal CRT is required only for VS2015 
//  GENERATE public boolean hasProperty(String name) { return getAsDynamicObject().hasProperty(name) } 
// CHECKSTYLE:ON 
//  We avoid using reflect, since that leads to class loading exceptions 
//  skip over stack trace 
//  <thead>     <tr>       <td>Method</td>       <td>Description</td>     </tr>   </thead> 
//  return state.equals(((GeneratedView)arg).__view_state()); 
//  When age == 0, verified since the start of this build, assume listing hasn't changed 
//  Emulate secondary inputs as a single property for now 
//  TODO - push all this stuff down to the tool chain and let it create the specific platform and provider 
//    Add `boolean immutable() { return true }`   
//  Don't know about this type 
//  Add the block line-number as an argument to call `plugins(int lineNumber, Closure pluginsBlock)` 
//  We check the params passed to the build factory 
//  Failed in another thread 
//  Called when some other problem occurs 
//  A project is involved, need to be aware of it
//  Store this because Locale.default is mutable and we want the unchanged default   We are assuming this class will be initialized before any code has a chance to change the default 
//  Only fire once 
//  Not a leaf node. Move up an entry from a leaf node, then possibly merge the leaf node 
//  If the configuration can still be mutated, we need to create a composite 
//  Disabled before 2.3 release due to not wanting to validate task names (which may contain invalid chars), at least not yet   ModelPath.validateName(name); 
//  Last group; what ever is left take that replace all characters that are not alphanum or '_' or '-' 
//  Else, the provider is of incompatible type, maybe we have a domain object collection of Provider, fallthrough 
//  TODO: Default branch can be different from just master 
//  only create an intermediate collection if there's something to copy 
//  Convert the UTF-8 manifest bytes to the requested content charset 
//  Same as above, if we have wrapped a closure in a WrappedConfigureAction or a ClosureBackedAction, we want to 
//  If there's an explicit dependency from consuming node to destroyer,   then we accept that as the will of the user 
//  check that groovy is visible. 
//  but visible as the surrounding class is imported and the inner class is public/protected static 
//  Wire the task into the library model 
//  Set the context classloader the bootstrap classloader, to work around the way that JAXP locates implementation classes   This should ensure that the JAXP classes provided by the JVM are used, rather than some other implementation 
//  Matches: task <expression> <operator> <expression> 
//  TODO: Removing `debug` from variant name to keep parity with previous Gradle version in tooling models
//  Use a random prefix to avoid reusing test directories 
//  fast path for two 
//  Ignore, deal with this problem later
//  Looks in the correct project registry for this binary 
//  Have visited this node's dependencies - add it to the graph 
//  Same size and no differences 
//  If textArea is on a status line but nothing was written, this means a new line was just written. While   we wait for additional text, we assume this row doesn't count as overlapping and use it as a status   line. In the opposite case, we want to scroll the progress area one more line. This avoid having an one 
//  Add artifact format as an implicit attribute when all artifacts have the same format 
//  TODO extract common stuff from this and ModelSet and reuse 
/*      * Allow null as a valid input. The default is to disallow null.     *     * <p>When this is enabled, all converters must be null safe.     *     * TODO - attach the null safety to each converter and infer whether null is a valid input or not.      */
//  (ia64 is no longer supported on later versions of Visual Studio) 
//  TODO - this belongs with the 'var' data structure 
//  Dependencies 
//  See JLS3 "Binary Compatibility" (13.1) 
//  This could probably be more efficient 
//  else ignore 
//  Not already known, attempt to self-close the parent 
//  TODO - introduce a new 'var' data structure that allows these conventions to be configured explicitly 
//  Calculate the actual type 
//  Clear environment variables that might effect cl.exe & link.exe 
//  Save the existing object being deserialized. 
//  Does nothing 
// it's possible that we receive an output for a suite here  in this case we will create the test result for a suite that normally would not be created  feels like this scenario should modelled more explicitly 
//  Check the normal metadata first 
//  Mark this version as rejected 
//  let's override this so that delegate isn't created at autowiring time (which would mean on every build) 
//  Was previously traversed, and no change to the set of modules that are linked by outgoing edges.   Don't need to traverse again, but hang on to the new filter since it may change the set of excluded artifacts. 
//  Jansi is required to log errors when generating Groovydoc 
//  For now just collect this as another dependency   TODO - collect this information and merge the metadata from the other module 
//  Short-circuit selector merging for single selector without 'prefer' 
/*         Note: the intention here is to work towards not having to create new objects        to meet the notification object interfaces.        Instead, the base types like BuildOperationDescriptor should implement them natively.        However, this will require restructuring this type and associated things such as        OperationStartEvent. This will happen later.      */
//  We might be able to use a cached/locally available version 
//  TODO: Combine with ProjectDependencyPublicationResolver
//  Read shared packages 
//  Do not forward events for rendering when there are no listeners to receive 
//  Ignore some broken samples 
//  <method>.getGenericReturnType() 
// when test is completed we should redirect output for the parent  so that log events emitted during @AfterSuite, @AfterClass are processed 
//  Add more data patterns to the default configuration to work around https://github.com/gradle/gradle/issues/1596 
//  Build a strongly typed (mergeable) exclude spec for each supplied rule 
//  Otherwise, already have a result, so reuse it 
//  End of path, might match when more elements added 
//  all of the interfaces that we decorate have 100% void methods  noinspection ConstantConditions 
//  TOOD:LPTR Should be just a relative path
//  first match, just record the value. We can't use "null" as the candidate value may be null 
//  TODO The scope information is superseded by test attributes. We can delete the corresponding code bits once we make sure that the majority of Buildship users use test sources.
//  If this configuration's version is in conflict, do not traverse.   If none of the incoming edges are transitive, remove previous state and do not traverse.   If not traversed before, simply add all selected outgoing edges (either hard or pending edges)   If traversed before:        If net exclusions for this node have not changed, ignore        If net exclusions for this node not changed, remove previous state and traverse outgoing edges again. 
//  Selected for the configuration 
//  Forward output immediately when the focus is on this operation group 
//  Note that @CompileClasspath here is an approximation and must be fixed before de-incubating getAstTransformationClasspath()   See https://github.com/gradle/gradle/pull/9513 
//  This means the client has not reported memory usage yet 
//  first let antlr preprocess the grammars... 
/*             Note: we currently extract this information from the execution plan because it's            buried under functions in #filter. This could be detangled/simplified by introducing            excludeTasks(Iterable<Task>) as an analog to addEntryTasks(Iterable<Task>).            This is too drastic a change for the stage in the release cycle were exposing this information            was necessary, therefore the minimal change solution was implemented.          */
//  When cancelled, try to stop the download thread but don't attempt to wait for it to complete   Could possibly loop here for a while trying to force the thread to exit 
//  possibly an inner class 
//  File loop exceptions are ignored. When we encounter a loop (via symbolic links), we continue   so we include all the other files apart from the loop.   This way, we include each file only once. 
//  When dependency resolution has failed, we don't want the build operation listeners to fail as well   because:   1. the `failed` method will have been called with the user facing error   2. such an error may still lead to a valid dependency graph 
//  Recreate the invoker when deserialized, rather than serialize all its state 
/*  method was only introduced in Groovy 1.8  */
//  Generate: <init>(Object[] state) { } 
//  make convention mapping work (at least for 'main'...   ...and for 'jvmArgs') 
//  found more than one 
//  Rely on the default linkage for providing the headers 
//  Unrecognized extension 
//  The CustomRunner class will fail this test if this class is initialized before its    run method is triggered.
//  Cannot yet publish module metadata without component 
//  in-process Groovy compilation throws a CompilationFailedException from another classloader, hence testing class name equality   TODO:pm Prefer class over class name for equality check once using WorkerExecutor for in-process groovy compilation 
//  TODO - do not hold lock while computing value 
//  Generate: int getFactoryId() { return <factory-id-field> } 
//  Using the caches for these connections leaves the Jar files open. Don't use the cache, so that the Jar file is closed when the stream is closed below   There are other options for solving this that may be more performant. However a class is inspected this way once and the result reused, so this approach is probably fine
//  for guessing right side part of a mapping 
//  Update any previously known files with a bogus timestamp to force a rebuild 
//  In case of getting a ConstructedClassWithPackage here we do not do checks for partial   matches with imported classes. The ConstructedClassWithPackage is already a constructed 
//  See TestDataGeneratorTest for examples 
//  The compilation will generate the new mapping file   Only merge old mappings into new mapping on incremental recompilation 
//  Should be using ConfigureUtil (with DELEGATE_FIRST strategy), however for backwards compatibility need to use OWNER_FIRST 
//  TODO - calculate this list of classes dynamically 
//  Collect incremental input changes 
//  for Groovy <1.6, we need to call org.codehaus.groovy.runtime.InvokerHelper#getVersion 
//  Any configuring event received from nested or buildSrc builds before the root build starts configuring is ignored 
// optional 
//  First try to determine the artifacts in-memory (e.g using the metadata): don't use the cache in this case 
//  experimentation shows the following, excluded modules are   inherited from parent POMs if either of the following is true:   the <exclusions> element is missing or the <exclusions> element 
//  Chuck away the implicit target. It has already been executed 
//  construct build invocations from task selectors and project tasks 
/*                 val leftResult = result.left()                val errorSeq = left.get()                // convert errorSeq -> Java types              */
//  Configure the binaries 
//  For legacy software model behaviour, which is to assume that any kind of runtime can be built when any compiler is available 
//  Ensure that deploy jars are not also added into lib folder.   Allows the user to get transitive dependencies for a bean artifact by adding it to both earlib and deploy but only having the file once in the ear. 
//  Versions before 5.1 would unpack the exception and throw part of it, losing some context 
//  Maps from interned absolute path for a file to metadata for the file. 
//  Don't traverse path back to root when there is nothing that can possibly match 
//  Find failure section 
//  For example, when using a local access to resolve something remote 
//  Do we have an 'is'-getter as well as a 'get'-getter?
//  There are enough entries in this block and the right sibling to make up 2 blocks, so redistribute   the entries evenly between them 
//  Capture the relative file 
/*  if it's already OSGi compliant don't touch it  */
//  Already visited this node 
//  Collect a map from component to coordinates. This might be better to move to the component or some publications model 
//  For each module participating in the conflict, deselect the currently selection, and remove all outgoing edges from the version. 
//  Nothing accessible, always up to date 
//  This is not the root block. Must have children >= minIndexChildNodes 
//  Compile all main routes files last 
//  This is necessary so that the watcher indicates its not running if the runnable gets cancelled 
//  ok to use caller classloader 
//  here, we need to check that applying the new resolution filter   we would actually exclude exactly the same dependencies as in   the previous visit. It is important that this is NOT a heuristic   (it used to be) because if the filters are _equivalent_, we would 
//  Iterate through each page of results, and add them to our results list. 
//  Note that the sourceSet is the sourceSet this pre-compiled header will be used with - it's not an   input sourceSet to the compile task. 
//  Stop is very slow, clean it up later 
//  Maximum pool size is fixed, so we should only need to get it from the first event 
//  If no tasks is specified then the default tasks will be executed.   To work around this, we assign a new empty task for execution. 
//  See the comment for {@link #createIsolatedClassLoader} above 
// the unlock was confirmed we are waiting 
//  First try to determine the artifacts locally before going remote 
//  In case more descendants are added to downward hierarchy, make sure they'll notify us 
//  implementation based on Spock's StackTraceFilter class 
//  No C++ compiler, complain about it 
//  Need to override as error message is hardcoded in constructor of public type ResolveException
//  MSVC doesn't allow a space between Fo and the file name 
//  At this point we know that we have a match for pname. This may   mean, that name[pname.length()..<-1] is a static inner class.   For this the rest of the name does not need any dots in its name.   It is either completely a inner static class or it is not.   Since we do not want to have useless lookups we create the name   completely and use a ConstructedClassWithPackage to prevent lookups against the package. 
//  BuildListener 
//  Clean the interrupted status 
//  A work around for not being able to skip the task when an input _file_ does not exist 
//  Reserve 0 for null (to be added later) 
//    Add factory method   
//  Nothing - just return the highest version 
//    Add `getFactoryId()` 
//  TODO: Register these mappings somewhere 
//  AST transforms need their own class loader that shares compiler classes with the compiler itself 
//  Replace absent Provider with null.   This is required for allowing optional provider properties - all code which unpacks providers calls Provider.get() and would fail if an optional provider is passed.   Returning null from a Callable is ignored, and PropertyValue is a callable. 
//  Defer creation and resolution of configuration until required. Short-circuit when script does not require classpath 
//  Fall back to serialization 
//  If stdout and stderr are attached to the console 
//  Equal values are compatible 
//  https://docs.oracle.com/javase/specs/jls/se12/html/jls-3.html#jls-BooleanLiteral 
//  Zero or more * characters followed by literal followed by at least one * 
//  classpath change?
//  Use DirectInstantiator here to avoid setting up the instantiation infrastructure early 
//  Versions before 5.1 would sometimes add some additional 'build cancelled' exceptions 
//  References some fixed value expression, return it after macro expanding 
//  Swift tests will always have a toolchain requirement for swiftc 
//  else leading ':', this is ok 
//  We don't have mutable access to the project, so we throw a deprecation warning and then continue with   lenient locking to prevent deadlocks in user-managed threads. 
//  We don't really need to handle this.
// btw. the ibm vm+winXP also has some issues detecting closed streams by the child but we handle this problem differently. 
//  lists all the values a revision token listed by a given url lister 
//  TODO - also close console when it is replaced 
//  A sequence of tokens that look like a function call argument list. Should support an arbitrary token sequence 
//  TODO: Decide if we want to push the gate concept into TAPI or other entry points   currently, a gate is only used by continuous build and can only be controlled from within the build.
//  @Param({"md5.java", "md5.bc", "sha1.java", "sha1.bc", "blake2b.bc"}) 
//  Visit the nodes prior to visiting the edges 
//  Everything else treat as a generic operation 
//  Native Services 
// Skip content download 
//  Generate makeRule() method 
// noinspection SwitchStatementWithTooFewBranches 
//  Need to delete the previous archive, otherwise stale object files will remain 
//  only set the TaskOperation as the parent if the Tooling API Consumer is listening to task progress events 
//  TargetJDK does not include 1.1, 1.2 and 1.8;   Use same fallback as PMD 
//  buffer has been fully read, start at the beginning 
//  Exactly Visual Studio 2019 
//  Note: this listener manager is scoped to the root Gradle object. 
//  Default for everything else 
//  Ignore the tag section of the comment 
//  Matches: task <identifier> <arg-list> <operator> <expression>   Map to: passThrough(task('<identifier>', <arg-list>) <operator> <expression>) 
//  performs a fast analysis of classes referenced in bytecode (method bodies) 
//  If we have no caching options, just get the thing directly 
//  Anything left over only exists in the new list 
//  add the configurations from this temporary parser to this module descriptor 
//  Old Scala Plugin does not specify a ScalaPlatform 
//  The fingerprint hashes for non-regular files are slightly different to the snapshot hashes, we only need to compare them for regular files 
//  Implementation is provided by 'plugin-use' module 
//  Implementation is generated 
// just returns the original object 
//  Iterate over the metadata sources to see if they can provide the version list 
//  No identifier, allow anything except '(' or ',' or ')' 
//  Input events 
//  File did not exist before locking, use some initial state 
//  Start the pipeline in reverse order:   1. mark daemon as running   2. start handling incoming commands   3. start accepting incoming connections   4. advertise presence in registry 
//  Corner case of Maven -SNAPSHOT compat 
//  if the collection is a read-only property, it must be initialized first (it will never be null)   if the collection is *not* read-only, then we will initialize it only if the collection is the   subject of a rule, that is to say that it can be mutated. This may look strange, if a read-write   collection is null to initialize it to an empty list, but this is how the specs define reaw-write   collections of scalar types. 
//  Make sure all entries are always written in the same order 
//  we need to compute a hash for a constant, which is based on the name of the constant + its value   otherwise we miss the case where a class defines several constants with the same value, or when   two values are switched  non-private const 
/*      * Tries to minimize the number of requests to the resolution engine by batching up requests     * for sources/javadoc.     *     * There is still some inefficiency because the ArtifactCollection interface does not provide     * detailed failure results, so we have to fall back to the more expensive ResolutionResult API.     * We should fix this, as other IDE vendors will face the same problem.      */
//  Not sure this can happen, unless in error state 
//  ignore these test suites 
//  skip exact matches 
//  runtime check because method is used from Groovy where type bounds are not respected 
//  type, payload size 
//  Check that ivy.xml isn't duplicated 
//  When age == 0, verified since the start of this build, assume still missing 
//  TODO - allow @InputFile and @SkipWhenEmpty to be attached to getExecutableFile() 
//  Save a reference to the dependency that was written before 
//  Maybe this type belongs in the same package as the node that is doing the   static import. In that case, the package may not have been explicitly specified.   Try with the node's package too. If still not found, revert to original type name. 
//  Not marked as @Nullable because of Groovy compiler bug: https://issues.apache.org/jira/browse/GROOVY-8505 
//  This happens for IBM JDK 6 for nested interfaces -- see https://issues.apache.org/jira/browse/GROOVY-7010   Let's try to return something as close as possible to the intended value 
//  Not public. Evaluation of these specs is a major hot spot for large builds, so use an array for iteration 
//  Expire compatible, idle, not recently used Daemons after a short time 
// The values are based on what I have found in sbt-compiler-maven-plugin.googlecode.com and zinc documentation  Hard to say what effect they have on the incremental build 
//  Not a zip file 
//  Cannot convert 
//  static classes are used for the actions to avoid implicitly dragging project/tasks into the model registry 
//  Add outgoing configurations and publications 
//  eliminate the common root 
//  The strategy for sharing build cache configuration across included builds in a composite,   requires that the cache configuration be finalized (and cache controller available)   before configuring them. This achieves that. 
//  Pass build JVM args through to daemon via system property on the launcher JVM 
//  look into the compile unit if there is a class with that name 
//  When used as an input, add the producing tasks if known 
//  no changes yet   handle case where monotonic clock isn't monotonic 
//  type2 = ? extends S, never contained 
//  There is a possibility that a platform version was selected before a new member   of the platform was discovered. In this case, we need to restart the selection,   or some members will not be upgraded 
//  Serialize the worker config, this is consumed by SystemApplicationClassLoaderWorker 
//  values from `JvmPackageNameTest` 
//  We allow the gradle version to be overridden for tests that are sensitive   to the version and need to test with various different version patterns.   We use an env variable because these are easy to set on daemon startup,   whereas system properties are scrubbed at daemon startup.
//  Ignore input received after the monitor operation has been completed 
//  Restore the environment 
// noinspection ConstantConditions 
//  Create variants container only as required 
//  Currently not supported 
//  Different implementation - assume value has changed 
//  Float f = (Float) tmp   f==null?0:f.floatValue() 
//  if more than one conflicting project dependencies 
//  acquiring the exclusive lock can fail in the rare case where another process is just doing or has just done the cache initialization 
// started, enable 
//  Copied from http://hc.apache.org/httpcomponents-client-ga/ntlm.html 
//  return this.metaClass 
//  Ignored 
//  Reasonable default threshold bounds: between 384M and 1G 
//  solution   IllegalAccessException 
//  This can happen if this is used in a constructor or a @Before method. It also happens when using   @RunWith(SomeRunner) when the runner does not support rules. 
//  Mark all affected configurations as observed 
//  no filtering in place 
//  These will also be copied across to any daemon used 
//  Exactly Visual Studio 2013 
//  end::isolating-annotation-processor[] 
// (SF) This approach should generally work because at the moment we reset capturing output per suite  (see CaptureTestOutputTestResultProcessor) and that reset happens earlier in the chain.  So in theory when suite is completed, the output redirector has been already stopped  and there shouldn't be any output events passed  See also GRADLE-2035 
// when no daemon process has started yet 
//  Dummy rule to cause the extension to be realized 
//  The registered nodes may contain nodes which are no longer selected.   We don't remove them from the list in the first place because it proved to be   slower than filtering as needed. 
//  This is necessary because for the Tooling Api compatibility runner, NativeServices   can get initialized in a different classloader, which then makes it broken and unusable   in the test class (because the native shared library is loaded from another classloader).   By initializing it here, we ensure that it is loaded from the classloader the test class   also uses. 
//  GENERATE public ExtensionContainer getExtensions() { return getConvention(); } 
//  Read server address and start connecting 
//  Defer dependencies gathering as we need to resolve across project's boundaries 
//    Add `name` field   
//  Empty initial operation to trigger onStartWork calls 
//  2.x and 3.0-milestone-1 work on Java 6 - 8 
//  Use the highest preferred version that refines the chosen 'require' selector 
//  When not running from a Gradle distro, need runtime impl for launcher plus the search path to look for other modules 
//  to avoid silent retry 
//  end::aggregating-annotation-processor[] 
//  SkipWhenEmpty implies incremental.   If this file property is empty, then we clean up the previously generated outputs.   That means that there is a very close relation between the file property and the output. 
//  cannot compute at task execution time because we need association with source set 
//  end::functional-test-junit[] 
//  Ignore, this will be reported later 
// the unlock was just requested but not yet confirmed, give it some more time 
// triggered through tooling API of Gradle <2.3 - native-platform.dll is shared by tooling client (<2.3) and daemon (current) and it is locked by the client (<2.3 issue) 
//  Ignore all but the first recorded annotation 
//  This factory should be injected but leaves non-daemon threads running when used from the tooling API client 
//  the collection will only be initialized if more than one project candidate is found 
//  Check if node was previously traversed with the same net exclusion when not a virtual platform 
//  Read path to Gradle user home 
//  Don't care, collect the files later (in the correct order) 
//  Mandatory 
//  Ensure we have a scope 
//  Used by generated code 
//  This deals with the fact that in TestNG, there are no class-level events,   but we nevertheless want to see the class name. We use "." rather than   " > " as a separator to make it clear that the class is not a separate   level. This matters when configuring granularity. 
//  Drain the buffer before returning end-of-stream 
//  assume indentation uses spaces 
//  Otherwise, we defer to the judgement of our internal backoff handler. 
//  slowest path, full distribution   (A ∪ B) ∩ (C ∪ D) = (A ∩ C) ∪ (A ∩ D) ∪ (B ∩ C) ∪ (B ∩ D) 
//  value 
//  Reset security manager the tests seem to have installed 
//  No supposed to happen 
//  Sort of determinism 
//  Keep the files and discard the origin values instead?
//  Short lived process, don't cache in memory 
//  Does not match element, will never match when more elements added 
//  We know that Jvm binaries are BinarySpec instances 
//  Search in the standard installation locations and construct 
//  This is used to parse a YAML file 
//  Check for duplicates 
//  Any work execution happening in nested or buildSrc builds before the root build has started executing work is ignored 
//  Write a line separator after any block 
//  The usage pattern of this exception providing the rule identity and the cause providing the detail is the   way it is due to how we render chained exceptions on build failures.   That is, because the information is usually dense, splitting things up this way provides better output. 
//  Take ownership 
//  Exactly Visual Studio 2017 
//          mapping = new ConventionAwareHelper(this, getConvention());       }       return mapping;   } 
//  If you update FILE_STORE, you may also need to update LocallyAvailableResourceFinderFactory 
//  Optimize for the single entry case, makes findEntry faster 
//  The following types can appear anywhere in the code   but say nothing about API or implementation usage 
//  RC has position sensitive arguments, the output args need to appear before the source file 
//  getMetaClass(..) 
//  Use this instead of Description.getMethodName(), it is not available in JUnit <= 4.5 
//  we don't currently hold the project lock 
//  1) Add a new 'antlr' virtual directory mapping 
//  Only called when node exists 
//  1.5 
//  Discard information region 
//  hashcode will always be used, so we precompute it in order to make sure we   won't compute it multiple times during comparisons 
//  created since last execution, possibly by another task 
//  Lock-in explicitly included builds 
//  Test Suite 'PassingTestSuite' started at 2017-10-30 10:45:47.828 
//  check for star imports (import static pkg.Outer.*) matching static inner classes 
//  Don't need to match on path 
//  GENERATE (args instanceof Object[]) ? args : new Object[] { args } 
//  Discard the calculated files collection too, but need to retain the display name for it 
//  We consider only extra attributes which are NOT on every candidate:   Because they are EXTRA attributes, we consider that a   candidate which does NOT provide this value is a better match 
//  nop if all ok 
//  if a SHA-256 hash sum has been defined in gradle-wrapper.properties, verify it here 
//  Since a single `Artifact` is shared between configurations, share the metadata type as well. 
//  Currently only snapshot the console output listener. Should snapshot all output listeners, and cleanup in restore() 
//  Setup component 
//  TODO - lock this down 
//  Exactly Visual Studio 2015 
//  This should turn into a set of converters at some point 
//  Important that this is constructed on the client so that it has the right gradleHomeDir and other state internally 
//  Convention 
//  1.4 
//  4) set up convention mapping for default sources (allows user to not have to specify) 
//  TODO: CC make capabilities accessible to rules
// remove the last walked should run after edge and restore state from before walking it 
//  Collect nodes as implicit capability providers if different than current node, selected and not having explicit capabilities 
//  Ensure a clean end of the line when the area scrolls 
//  same as default conf but is used 
//  Capture changes to implementation 
//  Broken meta-data, bail 
//  1.3 
//  if we reach this point, no match was found, either because there are no versions matching the selector 
//  Flags 
//  Capture input files state 
//  we have not root source folder information for the grammar files,   so we don't force relativeOutput as we can't calculate it.   This results in flat generated sources in the output directory 
//  Gradle stuff 
//  These fields are not covered by mutation lock 
//  Select all entry points. An entry point is a publication that does not contain a component whose parent is also published 
//  stack traces are filtered in call order (from bottom to top) 
//  TODO - this should be an input 
// allow the daemon to be started concurrently 
//  File.createTempFile sets the location of the temp directory to a static variable on the first call.  This prevents future   changes to java.io.tmpdir from having any effect in the same process.  We set this to use a common tmp directory for all   tests running in the same process so that we don't have a situation where one process initializes with a tmp directory   that it then removes, causing an IOException for any future tests that run in the same process and call File.createTempFile. 
//  Capture and restore this in case the build code calls Locale.setDefault() 
//  Ignore the version if the string cannot be read 
//  See https://issues.gradle.org/browse/GRADLE-3470 
//  Create a proxy 
//  Ignore the other values 
//  We can't use an immutable list here because some hashes can be null 
//  Look for 'our' daemon among the busy daemons - a daemon will start in busy state so that nobody else will grab it. 
// We cannot just delegate to the add method as we need the file content for checksum calculation here  and reexecuting the action isn't acceptable 
//  Read whether process info should be published 
//  List modules with missing metadata files 
//  Effectively read the manifest 
//  Loaded from a classes dir - assume we're running from the ide or tests 
//  for each source set we will: 
//  skip built-in properties 
//  this handles '\r' (MacOSX 9), '\r\n' (Windows) and '\n' (Linux/Unix/MacOSX 10) 
//  Make a copy of the closure, attach inputs and execute 
//  also check interfaces in case we have interfaces with nested classes 
//  Use the timestamped version for all published artifacts:   The timestamped version is hidden deep in `Metadata.versioning.snapshotVersions` 
//  Any Swift 4.x compiler 
//  ignore 
/*  @Nullable  */
//  Register a builder for the custom tooling model 
//  We need to check if the target version exists. For this, we have to try to get metadata for the aligned version.   If it's there, it means we can align, otherwise, we must NOT add the edge, or resolution would fail 
//  this method should have been added to the class 
//  @formatter:off 
//  Any Swift 3.x compiler 
//  Does not need to be redrawn 
//  is present, but empty. 
//  slowest path 
//  Otherwise do deep compare of outputs 
//  TODO - should attempt to flush the output stream prior to writing to the error stream (and vice versa)
//  Choose the shortest match 
//  Path is-a Iterable, so check before checking for Iterable 
//  kept for backwards compatibility of plugins using internal APIs 
//  GENERATE public Object invokeMethod(String name, Object params) { return getAsDynamicObject().invokeMethod(name, (Object[])params); } 
//  Fields used for performance optimizations: we avoid computing the derived dependencies (withConstraints, withoutConstraints, ...)   eagerly because it's very likely that those methods would only be called on the selected variant. Therefore it's a waste of time   to compute them eagerly when those filtering methods are called. We cannot use a dedicated, lazy wrapper over configuration metadata 
//  This line MUST be last! 
//  Replace deprecated usage values 
//  Basically, if we see an operation with a logging header and it's not grouped, just log it 
//  use reflection to support older JVMs while supporting Java 9 
//  Big-endian 
//  Apply any artifact type mappings to the attributes of the variant 
//  Using DefaultTestClassDescriptor to fake JUnit test 
//  Called under lock 
//  Meta data artifacts are determined locally 
//  GENERATE objectFactory.listProperty(type) 
//  Collapse the set 
//  Wait for any work still running in other threads 
//  Since s3 transport supports only one type of credentials at a time, let's use the first one found. 
//  @formatter:on 
//  Could return true if all of the read only properties point to immutable objects, but at this stage there are no such types supported 
//  add the module configuration's files 
//  Matches: task <identifier>, <arg>? 
//  Actual format: 'Apple Swift version 4.0.2 (...)' 
//  Overwrite the source to exclude `LinuxMain.swift` 
//  Unpack the provider 
//  remains the same as the content in the existing file 
//  No SDK information available in the registry 
//  Logging configuration 
//  Skip this for now 
//  https://github.com/gradle/gradle/issues/5763 
//  if we ask for "external" dependencies, it's still fine to bring a fat jar if nothing else is available 
//  Arbitrarily select and mark all as rejected 
//  Notify child configurations 
//  IDEA adds the JDK's bootstrap classpath to the classpath it uses to run test - remove this 
//  Can wait on request if previous handler allows waiting 
//  the order is strange logically but here for performance optimization 
//  only interrupt poller thread if it's not current thread 
//  Used to maintain timer 
//  test default imports 
//  Should reuse the link parsing stuff from JavadocLinkConverter instead 
//  if we are allowing unknowns, just pass through the whole arg 
//  Use the result of previous rules as the input for dependency substitution 
//  Not present in output, check error output. 
//  These could be injected directly to DefaultTransformerInvoker, too 
//  Used by HasPrefixAndSuffixPatternStep to ensure the suffix isn't matching any part of the prefix. 
//  Ignore future states of the input node 
//  Could be precomputed, but we avoid doing so if attributes are never requested 
//  It's often the case that all the candidate values are the same. In this case, we avoid   the creation of a set, and just iterate until we find a different value. Then, only in   this case, we lazily initialize a set and collect all the candidate values. 
// adding custom test listeners before Gradle's listeners.  this way, custom listeners are more powerful and, for example, they can change test status. 
// some validation: 
//  TODO: match with status, order versions correctly 
//  Check other behaviour still works 
//  Check already resolved results for a compatible version, and use it for this dependency rather than re-resolving. 
//  Evaluate init scripts 
//  It's an intersection, and this method is always called on the remainder   of a reduction operation. If the remainder is empty then it means that   the intersection is empty 
//  Any available GCC compatible implementation (including mingw, cygwin, and clang) 
//  When annotation processing isn't required, it's better to add the Groovy stubs as part of the source path.   This allows compilations to complete faster, because only the Groovy stubs that are needed by the java source are compiled. 
//  NOTE: There isn't much we can do about collection.matching { } filters as the spec requires a realized element, unless make major changes 
//  Presence of capabilities is bound to the definition of a capabilities extension to the project 
//  Do NOT change the order of members used in hash code here, it's been empirically   tested to reduce the number of collisions on a large dependency graph (performance test) 
//  Have received all requests, or have released something, so downstream can wait. This isn't quite right 
//  Avoid creating a copy if the resulting configuration is identical 
//  Convert Scala Seq[RoutesCompilationError] -> Java List<RoutesCompilationError> 
//  registry doesn't exist yet 
/*  (non-Javadoc)         * @see org.apache.ivy.plugins.parser.m2.PomDependencyMgt#getArtifactId()          */
//  Some other meta-class implementation - fall back to the public API 
//  A cycle, treat as resolved here 
//  To determine the dependencies of the class, load up the byte code and look for CONSTANT_Class entries in the constant pool 
//  There is some value to the other ways to locate MSBuild (aka matching the MSBuild installation with the VS installation), this is a last chance to try and locate a usable MSBuild installation which will just try to get the latest available MSBuild. We can refine this later. 
//  TODO: convert output file checks to a resource lock 
//  Gather the default tasks from this first group project 
//  Not empty: may match any case above 
//  Host: x64 
//  Remove the deprecations message: "Deprecated Gradle features...", "Use '--warning-mode all'...", "See https://docs.gradle.org...", and additional newline 
//  we must add the implicit capability here because it is assumed that if there's a rule   "addCapability" would effectively _add_ a capability, so the implicit one must not be forgotten 
//  1. Stop handling disconnects. Blocks until the handler has finished.   2. Stop the connection. This means that the thread receiving from the connection will receive a null and finish up.   3. Stop receiving incoming messages. Blocks until the receive thread has finished. This will notify the stdin and receive queues to signal end of input.   4. Stop the receive queue, to unblock any threads blocked in receive().   5. Stop handling stdin. Blocks until the handler has finished. Discards any queued input. 
//  tries to relocate literals in the form of foo.bar.Bar 
//  Based on https://github.com/playframework/playframework/blob/2.6.0/framework/src/build-link/src/main/java/play/TemplateImports.java 
//  Make sure getters end up before the setters 
//  GENERATE <method>(…, ConfigureUtil.configureUsing(v)); 
//  default Scala version 
//  TODO:ADAM - ARM only if the target OS is Windows 8 or later   TODO:MPUT - ARM also if the target OS is Windows RT or Windows Phone/Mobile/CE   TODO:ADAM - IA64 only if the target OS is Windows 2008 or earlier
//  Exception has already been reported 
//  Define some additional variants 
//  TODO - mix this in using decoration. Also validate closure parameter types, if declared 
// First, we replace slashes because they have special meaning in the javadoc options file  Then, we replace every linebreak with slash+linebreak. Slash is needed according to javadoc options file format 
// we don't serialise the module dependencies at this stage so we need to keep track  of the mapping module dependency <-> resolved dependency 
//  We intentionally consider “execution” done before doing afterEvaluate.   The Android plugin relies on this behaviour. 
//  Other stuff 
//  The following state needs to be tracked to consistently construct `ComponentOverrideMetadata` independent of the order dependencies are visited 
//  create a new temporary parser to read the configurations from   the specified file. 
//  Only called when node exists, therefore node is known 
// CHECKSTYLE:OFF 
//  TODO - the suffix should be a deterministic function of the known and enabled annotations   For now, just assign using a counter
//  for tests using rich console standard out and error are combined in output of execution result 
// there is already registered conflict with at least one matching participant, hook up to this conflict 
//  Contract requires build events are delivered by a single thread. This is taken care of by the daemon client when not in embedded mode   Need to apply some synchronization when in embedded mode 
//  end::custom-task-implementation[] 
//  Explain that Groovy, for compile, also needs the resources (#9872) 
//  no retry 
//  There are 2 possibilities here:   1. the "platform" referenced is a real module, in which case we directly add it to the graph   2. the "platform" is a virtual, constructed thing, in which case we add virtual edges to the graph 
// TODO reuse cached result from downstream users of our classes directory 
//  standard doclet options 
//  no luck 
//  verify URL by making a HTTP call 
//  this should really be <String, Object>, however properties loader signature expects a <String, String>   even if in practice it was never enforced (one can pass other property types, such as boolean) an   fixing the method signature would be a binary breaking change in a public API. 
//  Ignore files 
//  If the current target is a project component, it must be unmodified from the requested 
// this means that we receive an output before even starting any class (or too late).  we don't have a place for such output in any of the reports so skipping.  Unfortunately, this happens pretty often with current level of TestNG support  because output events emitted by constructor, beforeTest, beforeClass   are sent before test start event is started and there is no parent class event emitted by TestNG.  In short, the TestNG support could be better. See also TestNGOutputEventsIntegrationTest
//  After this point we only see getters 
// target does not exist in the map, there's no cycle for sure 
//  fine one or more project dependencies among conflicting modules 
//  _state == ARTIFACT_EXCLUDE || EXCLUDE 
//  barrier open, let it travel on 
//  ignore this installation for validation, it will be caught later 
//  On macOS, we assume co-located Xcode is installed into /opt/xcode and default location at /Applications/Xcode.app 
// this shouldn't happen if you call check availability with #available first 
//  Matches: task <name-value-pairs>, <identifier>, <arg>?   Map to: task(<name-value-pairs>, '<identifier>', <arg>?) 
//  could be caused by https://bugs.openjdk.java.net/browse/JDK-8011537 ignore problems in stopping 
//  Forward special cases directly to consumer 
//  can't delegate to compileClasspathLoader because this would result in ASTTransformation interface   (which is implemented by the transform class) being loaded by compileClasspathClassLoader (which is 
//  No 2.11 version of routes compiler published 
//  Default methods are public non-abstract instance methods declared in an interface. 
//  this.getMetaClass() 
//  The current filestore 
//  This uses the system classloader and will not release any loaded classes for the life of the daemon process.   Do not use this to load any classes which are part of the build; it will not release them when the build is complete. 
//  TODO - do not assume Maven layout 
//  when a selector changes from non forced to forced, we must reselect 
//  check that the length of the reserved region is enough for storing our content 
//    Generate implementation class   
// root should be the last entry 
//  legacy mode 
//  Print the header if:     we're in verbose mode OR we're in rich mode and some output has already been rendered     AND     we haven't displayed the header yet OR we've displayed the header but the status has since changed
//          metaClass = GroovySystem.getMetaClassRegistry().getMetaClass(getClass());       }       return metaClass;   } 
//  Don't need to do parameter substitution, return the value of the expression after macro expanding it 
//  Simplifies (A ∪ ...) ∩ A = A 
//  There is an inheritance hierarchy in play here, so the order   of the clauses is very important.
//  Flush any buffered events and update the clock 
// Ignore. It means the client has disconnected so no point sending him any log output.  we should be checking if client still listens elsewhere anyway. 
//  Need to check that versions do match, mismatch indicates a force was used 
//  else, already visited previously, skip 
//  do this after wtp is configured because wtp config is required to update classpath properly 
//  Implicit JVM args that should be used to fork a JVM 
//  Unbox value 
//  Add included builds defined in settings 
//  No target, or target is an ancestor of this node, so is already being handled 
// one binary store per id+threadId 
//  Remove any outgoing edges for the current selection 
//  Expire after normal idle timeout 
//  Generate sourceLocation() method 
//  <inputs-lvar> = <inputs-field> ?: <parent-inputs-lvar> 
//  Guava 
//  used internally to determine if a rule effectively did something 
//  TODO: Assumes there's a single 'main' C++ component 
//  Else, something has changed in the include file graph for this source file, so analyse again 
//  block until ready for write operations 
//  Compile the interface to a temp file and then copy it to the cache folder.   This avoids sporadic cache lock timeouts when the compiler interface JAR takes   a long time to generate while avoiding starving multiple compiler daemons. 
//  Any Swift compiler 
// 3) new module has more than 1 version, register conflict and return 
//  GENERATE public <returnType> <propName>(<type> v) { val = super.<propName>(v); __<prop>__ = true; return val; } 
//  No-op 
//  Foo can match both Foo and Foo$NestedClass 
//  Duplicate, ignore 
//  Always expand with trailing . 
//  Trigger a replay on this node, to add new constraints to graph 
//  not enough data points 
//  Unresolved - we have a selector that was deferred but the constraint has been removed in between
//  Called when the method throws an exception 
//  Collect for later, do not add until the graph is known to have not changed 
//  A further work around for missing ability to skip task when input file is missing (see #getInputFileIfExists below)
//  Returns a fixed value expression 
//  Try to move the file out of the way in case its permanently corrupt   Don't delete, so that it can be potentially used for debugging
// given 
//  note: it's not the role of this class to validate that the annotation is properly used, that   is to say only on a getter returning String or a Named instance, so we trust the result of   the call
//  Replace '.' with '/' in organisation 
// we don't like the assumption about the port very much 
//  Sort based on version 
//  GetMethod is used in a private method, so doesn't belong to the API 
//  If we aren't required and don't have a signatory then we just don't run 
//  What actually shows up on the console 
//  protects the following state 
//  Expose the task to build logic (for now) 
//  If no current test can be associated to the output, the last known descriptor is used.   See https://bugs.swift.org/browse/SR-1127 for more information. 
//  A cached ClassLoader 
//  super test class file not in test class directories 
//  Deprecations (these should just be rendered on the client instead of being sent to the daemon to send them back again) 
//  Capture the current state of things that we will change during execution 
//  The iteration order of zip.getEntries() is based on the hash of the zip entry. This isn't much use   to us. So, collect the entries in a map and iterate over them in alphabetical order.
//  Parent is a reference, need to resolve the target 
//  ensure type is registered 
//  We can compare here by length, because pname is always   a substring of name, so same length means they are equal. 
//  We found the desired settings file, now build the associated buildSrc before loading settings.  This allows   the settings script to reference classes in the buildSrc. 
//  in the binary inputs. 
//  Exclude frameworks for CLang - they need to be handled differently 
//  Should be final, and set in constructor 
//  The directory is passed as an argument since File.createTempFile sets the location   of the temp directory to a static variable on the first call unless a directory is passed to the call.   Some tests change java.io.tmpdir and this is to ensure that the current value of java.io.tmpdir gets used here. 
//  Avoid initializing the list if there are no components requiring download (a common case) 
//  Mix the implicit launcher JVM args in with the requested JVM args 
//  An identifier with no separator, so this is not an #include or #import directive, it is some other directive 
//  Make some assumptions about the console output 
//  Order from most recent to least recent 
//  Descriptor file has been deleted - ignore the entry 
//  This can happen when, for example, a @BeforeClass or @AfterClass method fails 
//  Use the resolved component id if available: this ensures that Maven Snapshot ids are correctly reported 
//  and  (A ∩ ...) ∪ A = A 
//  The `eclipse` task in the root project should generate Eclipse projects for all Gradle projects 
//  This URL is not recognized by the Mac console (too few leading slashes). We solve   this be creating an URI with an empty authority. 
//  Add in tools.jar to the systemClassloader parent 
//  Java and Kotlin Lambdas are coerced to SAM types at compile time, so no unpacking is necessary there. 
//  These methods return strings rather than types because it may be more complicated than what is able to be expressed via a ModelType.   Also, we don't want to encourage compatibility checking occurring by looping through such types as we have more options for optimising the compatibility check internally.   Also also, these methods are only called for reporting so values should typically not be precomputed. 
//  This is only required to avoid adding a new public constructor to the public `PatternSet` type. 
//  Based on https://github.com/playframework/playframework/blob/2.4.0/framework/src/build-link/src/main/java/play/TemplateImports.java 
//  Supported, but unavailable. Nothing to do. 
//  Could probably apply some caching and some immutable types 
//  Confirms there is enough space in candidate to fit both suffix and prefix. 
//  nothing to do, we don't store this 
//  Target: x86 
// model properties: 
//  No Visual Studio information available in the registry 
//  Ignore: All selectors failed, and will have failures recorded 
// cut the pre and postfix of this url 
//  Assume everything is loaded into the current classloader 
//  Note: this is currently not visible on {@link org.gradle.api.internal.TaskInternal} to avoid it leaking onto AbstractTask and so on to the public API. 
//  default value for older Gradle clients 
//  Callable<? extends Callable<?>> 
// override the params with the explicit settings provided by the tooling api 
//  Check dynamic object behaviour still works 
//  Cast to return type 
//  Should be constructed with the default system ClassLoader as root 
//  Ideally, we'd delegate directly to the AntBuilder, but its Closure class is different to our caller's   Closure class, so the AntBuilder's methodMissing() doesn't work. It just converts our Closures to String   because they are not an instanceof its Closure class. 
//  Cached state is not copied, since dependency inputs are different. 
//  Set the implicit system properties regardless of whether default JVM args are required or not, this should not interfere with tests' intentions 
//  Setting the length improves upload performance 
//  Ignore and fall back to growl notify 
//  TODO:Cedric find out why if we use the same ID directly, it fails resolution by trying to get the artifacts   from the resolving metadata instead of the resolved metadata 
//  according to JVM documentation 
//  Ensure target project is configured 
//  Lock protects the following state, using an intentionally simple locking strategy 
//  The target may already be modified from the original requested 
//  Skip properties with non-abstract getter or setter implementations 
//  release 
//  Taking the first selector here to determine the 'changing' status and 'client module' is our best bet to get the selector that will most likely be chosen in the end.   As selectors are sorted accordingly (see ModuleSelectors.SELECTOR_COMPARATOR). 
//  This is only used for testing purposes so we can test handling of fluid dependencies without adding dependency substitution rule 
//  Already seen this source file before. See if we can reuse the analysis from last time 
//  literal followed by * followed by literal: matches #4 above 
//  Now try each address 
//  We need to wrap the visitor so that the file seen by the visitor has already   been extracted from the archive and we do not try to extract it again.   It's unsafe to keep the FileVisitDetails provided by TarFileTree directly   because we do not expect to visit the same paths again (after extracting everything). 
//  note: this method is on TaskInternal 
//  When an artifact is being published it is first checked whether it is available.   If a transport returns `null` then it is assumed that artifact does not exist.   If we throw, an attempt to publish will fail altogether even if we use ResourceExceptions#getMissing(uri). 
//  We limit the inner class lookups here by using ConstructedClassWithPackage.   This way only the name will change, the packagePrefix will   not be included in the lookup. The case where the   packagePrefix is really a class is handled elsewhere. 
//  Serialize the worker, this is consumed by SystemApplicationClassLoaderWorker 
//  Always use x86 as default on windows 
//  Take a root worker lease, it won't ever be released as ProjectBuilder has no lifecycle 
//  Otherwise, expand 
//  List<? extends String>[] 
//  we have C[] if the list is empty -> should be an array then! 
// TODO:HH wire binary libs via executable 
//  Do not cache Test task if Jacoco doesn't produce its output as files 
//  do same decoration as in addListener to remove correctly 
//  GENERATE getAsDynamicObject().getProperty(name); 
//  everything excluded **only** applies to modules, not artifacts! 
//  Assume changed if reading old file fails 
//  Output reports per execution, not mixed.   Cross-project ModelRegistry operations do not happen concurrently. 
//  asking for a fat jar. If everything available is a shadow jar, that's fine 
//  Everything is an unmanaged struct that hasn't been handled before
//  Construct a new Compiler class 
//  It was no primitive type, so next we see if the name,   which is a vanilla name, starts with a lower case letter.   In that case we change it to a LowerCaseClass to let the   compiler skip the resolving at several places in this class. 
//  Parse parallelism flags 
//  Write the output 
//  Use Jansi's detection mechanism 
//    Add `Object unpackState() { return name }`   
//  Created only on demand 
//  Callable<?> 
//  Use the debug variant as the development binary   Prefer the host architecture, if present, else use the first architecture specified 
//  Toolchains should be using default configuration 
//  This instance ends up in build/gradle scoped services for nesteds   We don't want to invoke close at that time.   Instead, close it at the root. 
//  No matches - fall back to regexp 
//  Capture output files state 
//  If there is no previous state, then we do have output changes 
//  Should reuse `GlobalScopeServices` here, however this requires a bunch of stuff in order to discover the plugin service registries   For now, re-implement the discovery here 
//  This should apply some locking, but most access to the build state does not happen via this method yet 
//  Do not cache the task if we are not writing execution data to a file 
//  Not resolvable. Discard the body when the expression is not resolvable
//  Adding an action that is not a duplicate 
//  release the artifact to production 
//  Some interesting type references 
//  return this.name 
// ignore 
//  Lookup.defineClass can only define a class into same classloader as the lookup object   we have to use the fallback defineClass() if they're not same, which is the case of ManagedProxyClassGenerator 
//  Note: `null` for `settingsFile` means explicitly no settings         A non null value can be a non existent file, which is semantically equivalent to an empty file
//  Need another identifier 
//  GENERATE objectFactory.property(type) 
//  Download to temporary location 
//  Convert properties for logging  object 
//  Make sure it's always > 0 but without affecting the lower 32 bits 
//  For tests 
//  attempt resolution on all types, so don't short-circuit and stop if we've previously failed 
//  Left over data from previous append is only possible when a multi-chars new line is   been processed and split across multiple append calls. 
//  var = this.<field> 
//  Add dependencies for this goal 
//  the lock for this project is the only lock we hold 
//  FIXME: Always build type name to keep parity with previous Gradle version in tooling API
//  If there's more than one node selected for the same component, we need to add   the implicit capability to the list, in order to make sure we can discover conflicts   between variants of the same module. Note that the fact the implicit capability is   in general not included is not a bug but a performance optimization
//  Without this, the URLConnection will keep the backing Jar file open indefinitely   This will have a performance impact for Jar-backed `UriTextResource` instances
//  Wrap to prevent exposing Stoppable, as we don't want to stop at this scope 
//  Other home dir in use, close these. Otherwise, keep the services for next time 
//  Already realized, just run the action now 
//  Every selector was empty: simply 'resolve' one of them 
//  Cannot be private due to reflective instantiation 
//  Required for MavenLocal to verify the presence of the artifact 
//  Make sure more specific annotation doesn't get overwritten with less specific one 
//  Versions before 5.1 would discard context on forced cancel 
//  Register each child of each component 
//  IDEA Module for project in current build: don't include any module that has been excluded from project 
//  inverse process of resolveClasspath to make sure IncrementalResultStoringCompiler stores correct result 
//  Summary of deprecations is considered a part of the build summary 
//  A file that we can safely reuse the result for 
//  Not using setOptional(optional) in order to avoid <optional>false</optional> in the common case 
//  Caches the list of dependency states for dependencies 
//  It won't for arbitrary scripts though. 
//  TODO - prevent multiple threads from performing the same VCS populate operation at the same time 
//  Task graph is not calculated yet. Plugins can add tasks to it. 
//  since we might generate the deployment descriptor, record each top-level module 
//  Log events 
//  This import must be here due to a clash in Java 8 between this and java.util.Optional.   Be careful running “Optimize Imports” as it will wipe this out.   If there's no import below this comment, this has happened. 
//  These two are here to work around https://github.com/gradle/gradle/issues/6027 
//  remove leading '$', remove last child segment, use '/' as separator 
//  Returns a parameter 
//  Generate: Class immutable() { return <properties.empty> && <read-only-properties.empty> } 
//  Discard event 
//  Lock on demand 
//  Use the jar when nothing has been requested 
// InputStream originalIn = System.in; 
//  Decoration takes care of the implementation 
//  TODO hook this in to the (daemon) build lifecycle
//  If there's more than one module id, merge them into a module id set 
//  In opposite to outgoing edges, virtual edges are for now pretty rare, so they are created lazily 
//  this.services = AsmBackedClassGenerator.getServicesForNext() 
//  make sure we don't interpret any tag while in description tag 
//  Force graph resolution as this is required to calculate build dependencies 
//  This generates a synthetic enforced platform variant with the same dependencies, similar to what the Maven variant derivation strategy does 
//  Climb up the hierarchy looking for the highest parent 
//  Netscape expires pattern 
//  The path to the project's task container in the model registry 
//  only one file 
//  Maps from interned absolute path for a file to snapshot for the file. 
//  Used by the JavaScript plugins 
//  for non-java projects there are no source sets configured 
//  If not set for >= JAXP 1.5 / Java8 won't allow referencing DTDs, e.g.   using http URLs, because Groovy's XmlParser requests FEATURE_SECURE_PROCESSING 
//  for performance, ignore flushes 
//     naming conventions via call to sourceSet.getTaskName() 
//  no common root 
//  tag::aggregating-annotation-processor[] 
//  If we're reaching this point, we're very likely going to iterate on the dependencies   several times. It appears that iterating using `dependencies` is expensive because of   the creation of an iterator and checking bounds. Iterating an array is faster. 
//  Create test suite executable 
//  TODO - reuse metaData if it was already fetched to select the component from the version list 
/*      * Indicates whether the tests should be run in deterministic order. Preserving the order guarantees that the complete test     * (including @BeforeXXX and @AfterXXX) is run in a test thread before the next test is run.     *     * Not required.     *     * If not present, the order will not be preserved.      */
//  ...   end::task-arg-method[] 
//  check module node import packages 
//  this allows us to generate the deployment descriptor after recording all modules it contains 
//  Use the runtime when nothing has been requested 
//  Unfortunate cast! see LibraryBinaryLocator 
//  path(Type) { ... } 
//  This means the client does not support reporting jvm memory info 
//  TODO: synchronization with other methods 
//  Discard this operation and all children 
//  NOTE: We do not want/need a decorated version of JavaForkOptions or JavaDebugOptions because   these immutable instances are held across builds and will retain classloaders/services in the decorated object 
//  Don't go up the parent chain.   Don't want to risk classes crossing “scope” boundaries and being non collectible. 
// see GRADLE-3027 
//  The name of the test method 
// we should consider to change the return type to DirectDependency, which requires adjustment in Kotlin DSL 
//  File resources are handled slightly differently at present.   file:// repos are treated differently   1) we don't cache their files
//  tag::sample[] 
//  Discard listeners 
//  This doesn't take into account build dependencies of the SourceDirectorySet.   Should just ditch SourceDirectorySet from here since it's not really a great model, and drags in too much baggage.
//  we don't know if the underlying collection can return a size in constant time 
//  We always ignore line order for matching out of parallel builds 
//  project.getDependencies().create(String) seems to be the only feasible way to create a Dependency with a classifier 
//  Upgrade required 
//  There is currently a requirement in the JDK9 javac implementation   that when javac is invoked with an explicitly empty sourcepath   (i.e. {@code --sourcepath ""}), it won't allow you to compile a java 9   module. However, we really want to explicitly set an empty sourcepath   so that we don't implicitly pull in unrequested sourcefiles which   haven't been snapshotted because we will consider the task up-to-date   if the implicit files change.     This implementation of hasLocation() pretends that the JavaFileManager   has no concept of a source path. 
// @Input 
//  Restarting this configuration after conflict resolution.   If this configuration belongs to the select version, queue ourselves up for traversal.   If not, then remove our incoming edges, which triggers them to be moved across to the selected configuration 
//  No compilers available, complain about the missing C compiler 
//  Task dependencies may be calculated more than once.   This guard is purely an optimisation. 
//  Fields guarded by lock 
//  Need to remember if a further element was matched by an earlier one, no need to consider it then 
//  Once the root build starts executing work, we are in Executing phase 
//  Use an OS selected port 
//  Can wait if this handler has completed or if the previous handler allows waiting 
//  Sort based on from component 
// LOG_LEVEL_MAPPING.put(LogLevel.INFO, Level.CONFIG);  LOG_LEVEL_MAPPING.put(LogLevel.LIFECYCLE, Level.WARNING);  LOG_LEVEL_MAPPING.put(LogLevel.WARN, Level.WARNING);  LOG_LEVEL_MAPPING.put(LogLevel.QUIET, Level.SEVERE);  LOG_LEVEL_MAPPING.put(LogLevel.ERROR, Level.SEVERE); 
//  Ends up with: 1 2 -> 3 <- 4 5 6 
//  Supports building both 32-bit and 64-bit binaries 
//  load the static type descriptor from class constants 
//  We'd have created an EmptyCurrentFileCollectionFingerprint if there were no file fingerprints 
//  we decided if we have a vanilla name starting with a lower case   letter that we will not try to resolve this name against .*   imports. Instead a full import is needed for these.   resolveAliasFromModule will do this check for us. This method   does also check the module contains a class in the same package   of this name. This check is not done for vanilla names starting 
//  Need to do this here, so that the transfer is 'restarted' when HttpClient reopens the resource (DIGEST AUTH only) 
//  Not an OpenJDK-compatible compiler or signature changed 
//  TODO:ADAM - Deprecate 
//  Ignore tasks created after not closed 
//  Already reached this goal 
//  We always want to include className, even if longer than max length 
//  A kotlinc warning, ignore 
//  Node must project item as S 
//  flatten because we need to serialize 
//  Add a JAVA_HOME if none provided 
// for testing 
//  when -Xmx1024m, Runtime.maxMemory() returns about 910   assume that Gradle itself uses about 150MB heap 
/*        The GroovyObject interface defines dynamic property and dynamic method methods. Implementers       are free to implement their own logic in these methods which makes it invisible to the metaclass.       The most notable case of this is Closure.       So in this case we use these methods directly on the GroovyObject in case it does implement logic at this level.      */
//  TODO: Stop all daemon services 
//  for each level in the file path, add the path 
// below could be better.  Throwing InvalidUserDataException here means that useful context information (including candidate formats, etc.) is not presented to the user 
//  If nobody said anything about this variant's target platform, use whatever the convention says 
//  Reference class via `ModelType` to avoid strong reference 
//  Used for testing the plugins DSL 
//  Create key manager 
//  if the version string cannot be parsed 
//  if exclusions == nothing, then the intersection will be "nothing" 
//  Separate Java class because IBM JDK 6 -- See https://issues.apache.org/jira/browse/GROOVY-7010 
//  Update the state region 
//  Using an array here because we're going to iterate pretty often and it avoids the creation of an iterator   that checks for concurrent modification 
//  The download thread may still be running. Ignore any further status events from it 
//  Fall back to propertyMissing, if available 
//  known value, only write index 
//  Not supported on Java 6 
//  avoid excess creation of Suggestion objects 
//  TODO - set header dir for applications 
//  Just an identifier, this is a token 
//  Not the first top level node 
//  tries to relocate literals in the form of foo/bar/Bar 
//  both are strings, we compare them taking into account special meaning 
//  This could very well be a zip (or something else we understand), but we can't know for sure.   The client may try to infer from the file extension. 
//  Build `buildSrc`, load settings.gradle, and construct composite (if appropriate) 
//  Check to see if we should adjust the level based on a set lifecycle log level 
//  Check environment 
//  Restart each configuration. For the evicted configuration, this means moving incoming dependencies across to the   matching selected configuration. For the select configuration, this mean traversing its dependencies. 
//  A function-like macro 
//  Object propertyMissing(String name, Object value) 
//  The provider does not know how to produce the value, so use the value instead 
//  Register capabilities for this node 
//  Set this.name = param1 
//  Milestone 4 was broken on the IBM jvm 
//  Replace if higher priority or version with highest priority and version
//  Serialize the shared packages, this is consumed by GradleWorkerMain 
//  Send some messages 
//  Could throw UncheckedIOException 
//  handle consumer < 2.7 
//      throw new IllegalStateException("Accessor already registered: " + type + " " + accessor);   } 
// no operation, if there is no script code provided 
//  this dependency is internal only 
//  Will be overwritten by setIdle if not idle. 
//  There is no script class when there are no statements or methods declared in the script 
//  TODO(daniel): Swift compiler should extends from an abstraction of NativeCompiler (most of is applies to SwiftCompiler) 
//  No services to be mixed in 
//  Any available Visual Studio implementation 
//  Here, we know that the user requested a specific classifier. There may be multiple   candidate variants left, but maybe only one of them provides the classified artifact   we're looking for. 
//  Expected 
//  non-serializable field 
//  Can only set once: should really be part of the constructor 
//  this.super(p0 .. pn) 
//  We don't care about nodes whose output is not consumed by anyone anymore 
//  throw new MissingMethodException(name, <view-type>.class, args) 
//  Because these properties can be convention mapped we need special handling in here.   If you add another one of these “modelled” properties, you need to update:   - maybeAppendModelledInstruction()   - maybePrependModelledInstruction()   - maybeSetModelledInstruction()   - getModelledInstructions()   - instructionValue() 
//  Milestone 3 
//  Override this, so that the working directory is not canonicalised. Some int tests require that   the working directory is not canonicalised 
//  Generate an authentication token, which must be provided by the client in any requests it makes 
//  TODO - creating a bundle should be done by some general purpose plugin 
//  Wire build dependent components tasks dependencies 
// ibm vm 1.6 + windows XP gotchas:  we need to print something else to the stream after we print the daemon greeting. 
//  TODO: Turn this into an `@implSpec` annotation on the comment above:   https://github.com/gradle/gradle/issues/7486 
//  see IdeaScalaConfigurer which requires the ipr to be generated first 
//  Map the arguments of this expression 
// noinspection SuspiciousMethodCalls 
//  Don't retain the value, to allow ClassLoader to be collected 
//  Disallow custom services of type ServiceRegistry, as these are automatically provided 
//  Add a link task 
//  Assume this is a class and so has implemented all properties and methods somewhere in the superclass hierarchy 
//  This is so that VisualCpp has the object file of the generated source file available at link time 
//  If no result from 'require', just use the highest preferred version (no range merging) 
//  We are going to throw a CommandLineArgumentException below, but want the message   to reflect that we didn't recognise the first char (i.e. the option specifier) 
//  Take a copy because adding to an idMappings value may result in new mappings being added (i.e. ConcurrentModificationException) 
//  GENERATE super.<setter>(v) 
//  At this point:   If in daemon mode, the process has started successfully and all streams to the process have been closed   If in fork mode, the process has completed and all cleanup has been done   In both cases, all asynchronous work for the process has completed and we're done 
//  cache result because it is pretty expensive to compute 
//  trailing / or \ assumes ** 
//  https://github.com/gradle/gradle-private/issues/1368 
//  Milestone 8 and 9 
//  NOTE: meminfoMatcher is _not_ thread safe and access needs to be limited to a single thread. 
// otherwise the stream.size() returns max integer and the offset is no longer correct 
//  Broken in another thread 
//  Not supported for now 
//  end::host-and-path[] 
//  Include file changed 
//  Otherwise, try remotely 
//  This is a little coincidental: if view attributes have not been accessed, don't allow no matching variants 
//  TODO - we've already calculated the common prefix and calling plus() will calculate it again 
//  Add the unit test and extension 
//  Call this.super() 
//  A macro function call 
//  This ensures that subprojects are realized and register their project and project configuration IDE artifacts 
//  1. org.codehaus.groovy.classgen.asm.WriterController makes identity comparisons 
//  Milestone 6 
//  By removing the leading "/", this is no longer a "path" as defined by Eclipse 
//  Creates a control regexp pattern where extra revision tokens _must_ have the same value as the original one 
//  Notify any waiting flush threads that the worker is done, possibly with a failure 
//  Also use the generated class for itself 
//  Task execution services at all levels needs this 
//  no compatible variant found 
//  Ant is optional dependency of groovy(-all) module but mandatory dependency of Groovy compiler;   that's why we add it here. The following assumes that any Groovy compiler version supported by Gradle   is compatible with Gradle's current Ant version. 
//  usePluginsInInitScripts asserts using https://repo.gradle.org/gradle/repo 
//  used for log and date only 
//  Milestone 7 
//  Intentionally asymmetrical to getExecuted()   This prevents recursion on `project.afterEvaluate { project.evaluate() }` 
// adding the properties from the super class onto the inheriting class 
//  but should be 
//  A member of the class breaks binary compatibility.   That will be handled when the member is passed to `maybeViolation`. 
//  this.<services_method>() 
//  Empty or only whitespace 
//  re-use not possible across modules currently 
//  for backwards compatibility, we use the last added description 
//  On Linux, users cannot touch files they don't own but have write access to   because the JDK uses futimes() instead of futimens() [note the 'n'!]   see https://github.com/gradle/gradle/issues/7873 
//  <thead>     <tr>       <td>Property</td>       <td>Description</td>     </tr>   </thead> 
//  Read *.properties files 
//  implicitly don't clean up if this throws 
/*                              * For someone looking for the difference between this and the duplicate code above                             * this one uses the `testTaskProvider` and the `reportTask`. The other just                             * uses the `reportTask`.                             * https://github.com/gradle/gradle/issues/6343                              */
//  disable jar file caching to prevent file locking 
//  Add plugin implementation here 
/*  * A performance test that compares Gradle's current performance against * some baseline and fails if it is slower.  */
//  else, already visited or currently visiting (which means a cycle), skip 
//  Fix the source file name displayed in the error messages 
//  we can tell for sure 
//  When there is a class name match, return true for excluding it so that we can keep   searching in individual test methods for an exact match. If we return false here   instead, then we'll give up searching individual test methods and just ignore the   entire test class, which may not be what we want. 
/*          * Linux 4.x: MemAvailable         * Linux 3.x: MemFree + Buffers + Cached + SReclaimable - Mapped          */
//  These should come from the compiler classloader 
//  Acquire an exclusive lock on the information region and write our details there 
//  1.x works on Java 5 - 8 
//  trailing EOL 
//  Pom packaging doesn't matter when we have a single unclassified artifact 
//  Try each address in turn. Not all of them are necessarily reachable (eg when socket option IPV6_V6ONLY   is on - the default for debian and others), so we will try each of them until we can connect 
//  Use the display name anyway 
//  Use java 7 APIs, if available 
//  handle origin metadata 
//  Determine which output to produce at development time. 
//  BuildOperationListener dispatch is not serialized 
//  When running from a Gradle distro, only need launcher jar. The daemon can find everything from there. 
//  TODO - reuse graph, discard state once not required 
//  Collect the components to sort in consumer-first order 
//  replicate a little bit of AnnotationVisitor here   because we can't wait until later to do this 
//  This is the highest parent in the hierarchy 
//  No further mutation is allowed and there's no parent: the artifact set corresponds to this configuration own artifacts 
//  Do nothing for now 
//  Remove duplicates 
//  From compile configuration, or when the target's runtime configuration does not extend from compile, include the compile dependencies 
//  When creating the OSGi manifest, we must have a single view of all of the classes included in the jar. 
//  TODO - visit dependencies of this collection instead 
//  Don't write to the right-most column, as on some consoles the cursor will wrap to the next line and currently wrapping causes   layout weirdness 
//  We do not store the history if there was a failure and the outputs did not change, since then the next execution can be incremental.   For example the current execution fails because of a compile failure and for the next execution the source file is fixed, so only the one changed source file needs to be compiled. 
//  Check already-resolved dependencies and use this version if it's compatible 
//  Perform conflict resolution 
//  Caches the list of dependency states which are NOT excluded 
//  Relative coordinate system 
//  if the first call to getConfiguration is done before getDerivedVariants() is called   then it means we're using the legacy matching, without attributes, and that the metadata   we construct should _not_ include the constraints. We keep the constraints in the descriptors   because if we actually use attribute matching, we can select the platform variant which   does use constraints. 
/*      * Synchronizes on the system properties, because IvySettings iterates     * over them without taking a defensive copy. This can fail if another     * process sets a system property at that moment.      */
//  ANTLR 2 always returning 0 
//  TODO - do this inside some 'testng' suite, so that failures and logging are attached to 'testng' rather than some 'test worker' 
//  Progress events have no expensive logic of their own, so we don't do anything   with them. We only test the overhead of sending/receiving them 
//  Have not seen this node before - add its dependencies to the head of the queue and leave this   node in the queue   Make sure it has been configured 
//  Need tools.jar for compile tasks 
//  we handle the property part as if it were not part of the property 
//  We do not need to check instances of LowerCaseClass   to be a Class, because unless there was an import for   for this we do not lookup these cases. This was a decision   made on the mailing list. To ensure we will not visit this   method again we set a NO_CLASS for this name 
//  Trigger download of file, if required 
//  Do not substitute plugins from same build or builds that were not explicitly included 
// noinspection ThrowFromFinallyBlock 
//  this is an approximation: all "compiled" sources will use the same task dependency 
//  Shorten args and write out an options.txt file   This must be called only once per execute() 
//  At this point, the work-in-progress area may or may not have been resized due to maximum size constraint. 
//  Using a string instead of a plain ID here might look strange, but this turned out to be   the fastest of several experiments, including:        using ModuleIdentifier (initial implementation)      using ModuleIdentifier through ImmutableModuleIdentifierFactory (for interning)      using a 2-level map (by group, then by name)      using an interned string for the cachedId (interning turned out to cost as much as what we gain from faster checks in maps)     And none of them reached the performance of just using a good old string 
//  Copy the raw form 
//  Do not use a timestamp that is the same as the end of the last build or the start of this build 
//  When using IncrementalTaskInputs, keep the old behaviour of all file inputs being incremental 
//  unknown scope, defaulting to 'compile' 
//  Encode the character using hex notation 
//  Use an empty settings for a target build file located in the same directory as the settings file. 
//  at this point we know the component exists 
//  Any available Clang 
//  we cannot use md5 instead of sha1 here because cache will get corrupted due to its expectation of sha1 hashes 
//  discard static initializers 
//  GENERATE ((MixInExtensibleDynamicObject)getAsDynamicObject()).getConvention() 
//  If this Scala compile is published into a jar, generate a analysis mapping file 
//  Consume content for non-successful, responses. This avoids the connection being left open. 
//  Macro expand parameter 
//  Already in something to uncompress it 
//  Reset console mode 
//  Do not macro expand parameter 
//  gate hasn't been opened yet 
//  `getMaxWorkerCount() - 1` because main thread executes work as well. See https://github.com/gradle/gradle/issues/3273   TODO This could be more efficient, so that we only start a worker when there are none idle _and_ there is a worker lease available 
// don't synchronize value creation 
//  TODO: Locate this tool from a tool provider 
//  We have to keep this for a while: https://github.com/gradle/gradle/issues/4856 
//  Wire build dependent binaries tasks dependencies 
//  These files have an unreliable timestamp - discard any cached state for them and rehash next time they are seen 
//  If the previous result is still not rejected, do not need to re-resolve. The previous result is still good. 
// put the whole arguments string in single quotes, unless defaultJvmOpts was empty, 
//  A CONSTANT_Class entry, read the class descriptor 
//  we see a different value, or the set already exists, in which case we initialize   the set if it wasn't done already, and collect all values. 
//  Assuming format: 'Swift version 4.0.2 (...)' 
//  The “remote” may have already given us the checksum 
//  We need to resolve the classes into a set of files so @SkipWhenEmpty will work   Otherwise, a collection of empty directories is not seen as "empty" 
//  Let's make sure we never need to reallocate 
//  throws Exception 
//  This set represents the order in which elements are inserted to the store, either actual   or provided.  We construct a correct iteration order from this set. 
//  Yeah, setting the background intensity is not underlining.. but it's best we can do   using the Windows console API 
//  This could be more efficient; assume that removal happens much less often than addition 
//  (<type>)<service> 
//  Generate: Class publicType() { ... } 
//  protects the following state   Contains only application owned ClassLoaders 
//  These objects are going across the wire.   1. Convert any subclasses back to File in case the subclass isn't available in Gradle.   2. Make them absolute here to deal with a different root at the server 
//  Serialize anything else 
/*      * Does a defensive copy to avoid leaking class references through the MutablePropertyDetails     * contained in the maps values. The keyset would keep a strong reference back to the map     * and all its entries.      */
//  Also available via play.japi.twirl.compiler.TwirlCompiler.DEFAULT_IMPORTS but we would have to grab it via reflection 
//  extract exceptions 
//  summary 
//  TODO - mix Groovy DSL support in 
//  Order is important here, because they will be searched in that order 
/*      * Adds an action which is executed before this collection is mutated with the addition or removal of elements.     * Any exception thrown by the action will veto the mutation.     *     * TODO: Combine this with the MutationGuard or rework CompositeDomainObject to behave with MutationGuard/MutationValidator.     * The mutation validators used in DefaultConfiguration only expect to be used with add/remove methods and fail when we     * correctly try to also prevent all/withType/etc mutation methods.     *     * assertMutableCollectionContents is only used by add/remove methods, but we should remove this special handling and fix     * DefaultConfiguration and CompositeDomainObjects.      */
//  Null is ok if the ConstructorSelector says it's ok 
// create log file 
//  show all operation output when debug is enabled 
//  Transition any other nodes that depend on the predecessor state 
//  element names can only contain 0 or 1 colon   See http://www.w3.org/TR/2004/REC-xml-names11-20040204/#Conformance   If the name has a prefix, evaluate both prefix and name 
//  Coerce the value to the property type, if known 
/*          * MetaClass.getMetaProperty(name) is very expensive when the property is not known.         * Instead, we reach into the meta class to call a much more efficient lookup method.         * Since we do this in a hot code path, we also reuse the argument array used for the         * reflective call to save memory.          */
//  Don't collect build dependencies if not required 
//  please keep the formatting below as it helps enabling or disabling stages   optimizes for nulls, 2-params, ... mandatory   caches the result of TL operations   performs algebra   caches the result of optimization operations   the end of the chain, mandatory   shares the same caches as the top level one as after reducing we can find already cached merge operations 
//  Not part of the public API 
//  Clean-up old HTML report directories 
//  fix problems in updating jar files by disabling default caching of URL connections.   URLConnection default caching should be disabled since it causes jar file locking issues and JVM crashes in updating jar files.   Changes to jar files won't be noticed in all cases when caching is enabled.   sun.net.www.protocol.jar.JarURLConnection leaves the JarFile instance open if URLConnection caching is enabled. 
//  Here it means that we have validated that the entry is still up-to-date, and that means a couple of things:   1. the cache policy said that the entry is still valid (for example, `--refresh-dependencies` wasn't called)   2. if the rule is cacheable, we have validated that its discovered inputs are still the same 
// 2 gigs 
//  From every configuration other than compile, include both the runtime and compile dependencies 
//  Read serialized worker 
//  Only add confs if they are specified. if they aren't, endElement will handle this only if there are no conf defined in sub elements 
//  This is an empty root block, discard it 
//  buffer was full, just call Thread.yield 
//  These constants are defined here and not with the rest of their kind in HelpTasksPlugin because they are referenced   in the ‘core’ modules, which don't depend on ‘plugins’ where HelpTasksPlugin is defined. 
//  overwrite rather than append dependencies 
//  resolve constant-looking expressions statically (do here as gets transformed away later) 
//  Currently need to resolve the file, so that the artifact can be used in both a script classpath and the main build. Instead, this should be resolved as required 
//  Create unbuildable build configuration so the indexer can keep functioning 
//  Turn the requested watch points into actual enclosing directories that exist 
//  Need Transformer (part of AntBuilder API) from base services 
//  Create trust manager 
//  If we don't know what the max heap is, approximate it based on OS total memory 
//  Check for presence as the domain object may have been replaced 
//  Make convention mapping work 
//  Convert a second time with only the published configurations: this ensures that the correct artifacts are included 
//  nothing to do if no EclipseRuntime is supplied. 
//  Add separators before and after anything with a comment or that is a block or group of statements 
//  try to get the name from EclipseProject.name 
//  Shutdown the adapter Groovy system 
// Discard the compile loader 
//  Only report subject binding if target state is after node creation 
/*          * Remembers the unresolved dependency for later logging and also adds a fake         * file dependency, with the file path pointing to the attempted component selector.         * This shows up in the IDE as a red flag in the dependencies view. That's not the best         * usability and it also muddies the API contract, because we disguise an unresolved         * dependency as a file dependency, even though that file really doesn't exist.         *         * Instead, when generating files on the command line, the logged warning is enough.         * When using the Tooling API, a dedicated "unresolved dependency" object would be better         * and could be shown in a notification. The command line warning should probably be omitted in that case.          */
//  Set the visible included builds 
//  Nested closure 
//  Only cache non-overloaded methods by name 
//  Artifacts are not known until the file collection is queried 
//  Toolchains should be linking against stuff in the standard locations 
//  Have to pass build JVM args directly to launcher JVM 
//  Can't acquire lock, get details of owner to include in the error message 
//  Ignore things we know are empty 
//  Ping the owner via all available local addresses 
//  check our classpath 
//  @Inject is allowed on fields only 
// class file versions: 1.1 == 45, 1.2 == 46... 
//  TODO: When we support multiple components or configurable dependencies, we'll need to merge the confs of multiple dependencies with same id. 
//  ignore exception in shutdown 
//  If the target is a project component, it has not been modified from the requested 
//  GENERATE null 
//  return 
//  Detect anonymous static classes of enum constants with class body   See https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#d5e12300   And https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.9.1   "The optional class body of an enum constant implicitly defines an anonymous class declaration    that extends the immediately enclosing enum type." 
//  Hackery to make closure execution faster, by short-circuiting the expensive property and method lookup on Closure
//  Only managed implementation and value types are allowed as a managed property type unless marked with @Unmanaged 
/*  isInitialPass  */
//  Read-only property with managed type 
//  Do not traverse if seen already 
//  Inject the launcher JVM args via one of the environment variables 
//  If the classloader structure is flat, there's no need to send the classpath 
// we could potentially avoid creating value that is already being created by a different thread. 
//  Wait for the process' stdout to indicate that the process has been started successfully 
//  currently single list of optionals 
//  Expire under high JVM memory or GC pressure 
//  scenarioList contains duplicate scenarios because of rerun 
//  If the jansi.strip property is set, then we just strip the 
//  i >= 1 makes sure that commonElements < stackTrace.size() 
//  Use this instead of Description.getClassName(), it is not available in JUnit <= 4.5
//  GENERATE __<prop>__ = true 
//  Ignore any other outcome 
//  public methods belongs to your API 
//  TODO: Allow this to be added lazily 
// then we want to validate strictly 
//  Selection deferred as we know another selector will be added soon 
//  when a selector changes from non lock to lock, we must reselect 
//  Important that the launchables are unpacked on the client side, to avoid sending back any additional internal state that   the launchable may hold onto. For example, GradleTask implementations hold onto every task for every project in the build 
//  retry after getting "Bad file descriptor" exception 
//  Lambdas contain a name that's based on an index + timestamp at runtime and changes build-to-build.   This makes comparing two builds very difficult when a lambda is in the stack   changes SkipUpToDateStep$$Lambda$33.1050994387.apply -> SkipUpToDateStep$$Lambda$apply 
//  MutableModelNode methods 
// quote everything else 
//  This severs the connection between from this debugOptions to the other debugOptions 
//  just for reporting 
//  If we have a single common resolution, no conflicts to resolve 
//  must be an included build 
//  This is a slight different condition than that used for a dependency declared in a Gradle project,   which is (targetHasVariants || consumerHasAttributes), relying on the fallback to 'default' for consumer attributes without any variants. 
/*  * TODO - merge this and the component container  */
//  lookup class in all classloaders 
// Would typically use GetObjectMetadataRequest but it does not work with v4 signatures
//  Either a macro function, a macro or token concatenation 
//  GENERATE instantiator.newInstance(type) 
//  1.8 
//  if not null, is not empty 
//  Read -D command line flags 
//  Should not happen 
//  0.9.1 couldn't handle anything with a timestamp whose timezone was behind GMT 
//  Caching involves 2 distinct caches, so that 2 scripts with the same (hash, classpath) do not get compiled twice   1. First, we look for a cache script which (path, hash) matches. This cache is invalidated when the compile classpath of the script changes   2. Then we look into the 2d cache for a "generic script" with the same hash, that will be remapped to the script class name   Both caches can be closed directly after use because:   For 1, if the script changes or its compile classpath changes, a different directory will be used   For 2, if the script changes, a different cache is used. If the classpath changes, the cache is invalidated, but classes are remapped to 1. anyway so never directly used 
//  Create a SourceFile object to represent the javascript file to compile 
//  Remove all the methods from the main class 
//  We don't support shrinking at the moment 
//  Create a synthetic id for the build, if the id is already used   Should instead use a structured id implementation of some kind instead 
//  exists == has content 
//  Do not process Object's or GroovyObject's methods 
//  TODO - this should be applied to all methods, including delegating methods 
//  Could potentially coordinate with a thread that is snapshotting an overlapping directory tree 
//  Supported, nothing to do. 
//  If the module matches, add the root component into the mix 
//  Too many requests (not available through HttpStatus.XXX) 
//  Unpacks the request to serialize across to the daemon and creates instance of   TestExecutionRequestAction 
//  cleanup() will abort the process as desired 
//  Include file not found (but previously was found) 
//  An empty capability list means that it's an implicit capability only 
//  read-write-execute for user only   read-write for user only 
/*          *  GROOVY-4009: when a normal variable is simply being used, there is no need to try to         *  resolve its type. Variable type resolve should proceed only if the variable is being declared.          */
//  Only handle the command line for now 
//  Turn off request logging unless debug mode is enabled 
//  Unknown type - just inspect ourselves. Should instead share this with all registries 
// fall back to default runner 
//  Resolvable configurations 
//  Based on the benchmark found in org.gradle.internal.nativeintegration.filesystem.FileMetadataAccessorBenchmark   and the results in the PR https://github.com/gradle/gradle/pull/1183   we're using "native platform" for Mac OS and a  mix of File and NIO API for Linux and Windows   Once JDK 9 is out, we need to revisit the choice, because testing for file.exists() should become much   cheaper using the pure NIO implementation. 
/*                 val rightResult = result.right()                val generatedFiles = right.get()                val empty = generatedFiles.isEmpty()                empty.booleanValue()              */
//  Matches: task args?, <identifier>, args? or task(args?, <identifier>, args?)   Map to: task(args?, '<identifier>', args?) 
//  Report fields with annotations that have not been seen while processing properties 
//  Snarl is not running 
//  If credential decides it can handle it, the return code or message indicated   something specific to authentication, and no backoff is desired. 
//  Body is a simple expression, including a macro function call with no arguments 
//  Enable the use of Gradle metadata. This is a temporary opt-in switch until available by default 
//  this is cached because used very often in sorting selectors 
//  ProviderInternal is-a TaskDependencyContainer, so check first 
//  Implementations should not wrap exceptions, this is done in DefaultObjectConfigurationAction
//  found an attribute with the same name, but they do not necessarily have the same type 
//  Consumable configurations 
//  Handle just empty string, single identifier or '(' params? ')', should handle more by parsing the tokens into an expression 
//  TODO: Add handling for Test-only dependencies once https://github.com/gradle/gradle/pull/9484 is merged 
//  No macro name 
//  Does not take effect until after execution has completed 
//  Only apply default locations when none explicitly configured 
//  empty text nodes hinder subsequent formatting 
//  Resolve it later 
//  First look for a property known to the meta-class 
//  component under test 
//  Just move back 2 seconds 
//  A first pass to do local resolves only 
//  TODO Deprecate and eventually prevent these mutations in parent when already resolved
//  Artifacts   Keep track of transformed artifacts as a given artifact may appear in multiple variants 
//  Ignore exclusions for dependencies with `<optional>true</optional>`, but not for <dependencyManagement>. 
//  JVM args that must be used to fork a JVM 
//  custom type 
// discovered java location 
//  Include all 'optional' dependencies in "optional" configuration 
//  ignored 
//  Assume VS 2015 
//  Create the and initialize the SSLContext 
//  We use an identity hashmap for performance, because we know that our attributes   are generated by a factory which guarantees same instances 
//  https://docs.oracle.com/javase/specs/jls/se12/html/jls-3.html#jls-NullLiteral 
//  Casts to Class below are to workaround Eclipse compiler bug   See: https://github.com/gradle/gradle/pull/200 
//  Clean up old stop events 
//  Exit code 0 = success   Exit code 1 = failed test(s)   anything else is considered an execution failure 
//  On macOS, we assume co-located Xcode is installed into /opt/xcode 
//  previous character is not a separator 
//  Defer attaching the model until all components have been (most likely) configured   TODO - make this relationship explicit to make this more reliable and offer better diagnostics 
/*                  * An extracted distribution usually looks like:                 * checksumDir/                 *      | gradle-5.5.1-bin.zip.ok                 *      | gradle-5.5.1-bin.zip.lck                 *      | gradle-5.5.1-bin.zip                 *      | gradle-5.5.1                  */
//  check package this class is defined in. The usage of ConstructedClassWithPackage here   means, that the module package will not be involved when the   compiler tries to find an inner class. 
//  4.x   2.x - 3.x   1.x 
//  On windows we know the console does not interpret ANSI codes.. 
//  following patterns are built upon constants above and should not be modified 
//  ordered by how much they filter 
//  By default the local cache is a directory cache 
//  we just need to get the lock for this project 
//  NOTE: When removing provider, we don't need to fireObjectRemoved as they were never added in the first place. 
//  In the same situation with NATIVE_HEADER_OUTPUT, javac just NPEs.  Don't bother. 
//  If the jansi.passthrough property is set, then don't interpret 
/*  * Benchmark                     Mode  Cnt          Score         Error  Units * OptionalBenchmark.nullCheck  thrpt   20  107887111.061 ±  882182.482  ops/s * OptionalBenchmark.optional   thrpt   20   86746312.090 ± 1150860.296  ops/s * */
//  we are currently adding a configuration to either an include, exclude or artifact   element   of a dependency. This means that we have to add this element to the corresponding   conf   of the current dependency descriptor 
//  path { ... } 
//  If the previous result was rejected, do not need to re-resolve (new rejects will be a superset of previous rejects) 
//  MinGW requires the path to be set 
//  superName can be null if what we are analyzing is `java.lang.Object`   which can happen when a custom Java SDK is on classpath (typically, android.jar) 
//  See if all entry points have the same identifier 
//  Unfortunately, we can't determine this at constructor time, because CacheBuilder   calls our constructor and it's not easy to pass arguments to it. 
//  virtual components have no source 
//  Collect any container level add actions added since the last call to configure() 
//  DO NOT change the signature of this method: it is a convention used in   our internal performance testing infrastructure 
//  Add the application and extension 
//  Try to configure element 
//  Pass 1, extract plugin requests and plugin repositories and execute buildscript {}, ignoring (i.e. not even compiling) anything else 
//  another case we want to check here is if we are in a   nested class A$B$C and want to access B without   qualifying it by A.B. A alone will work, since that   is the qualified (minus package) name of that class   anyway. 
//  First things first, retro compatibility 
//  to strip the ANSI sequences.. 
//  1.0-milestone-5 was broken where jna was not available  noinspection SimplifiableIfStatement 
//  TODO: This is where the password information would go
//  If unknown, try a remote search 
//  For custom ivy pattern matchers, don't inspect the rule any more deeply: this prevents us from doing smart merging later 
// No conflict with matching participants found, create new 
//  tag::options-of-dynamic-processor[] 
//  if the included ivy file is not found on file system, tries to resolve using 
//  TODO - display name 
//  Prevent further tests (ignored) from triggering start actions 
//  Known, but not buildable 
//  Stop the pipeline:   1. mark daemon as stopped, so that any incoming requests will be rejected with 'daemon unavailable'   2. remove presence from registry   3. stop accepting new connections   4. wait for commands in progress to finish (except for abandoned long running commands, like running a build) 
//  Example: http://repo2.maven.org/maven2/net/jini/jsk-platform/2.1/jsk-platform-2.1.pom 
//  ExecuteBuild should be the last action, but in case we want to decorate the result in the future 
//  GENERATE public <type> <getter>() { return (<type>)getConventionMapping().getConventionValue(super.<getter>(), '<prop>', __<prop>__); } 
//  new entry 
//  Else, has been removed by something else - ignore 
//  Need to use a 'foreign' build id to make BuildIdentifier.isCurrentBuild and BuildIdentifier.name work in dependency results 
//  We use a set here because for excludes, order of edges is irrelevant   so we hit the cache more by using a set 
//  NOTE: the space in the directory name is intentional
// browsers dont understand <a name="..."/> 
//  Is the cached version still current?
//  Convert properties to ParallelismConfiguration object 
//  Delegate class is not visible to managed view type -> view type is more general than delegate type, so use the delegate classloader instead 
// module was already visited, there is a cycle 
//  hot path; create as little as possible… 
//  These are implemented as a system property, but don't really function like one   So we include it in this “no system property” set. 
//  We need scala.util.parsing.input.Positional 
//  There's no authentication involved, requests can be done concurrently 
//  Start preparing the result 
//  Deserialize the worker action 
//  Add tasks created through rules to the actual task container 
//  Can probably skip this 
//  Split out up the output into main content and post build content 
//  ... 
//  Use a defensive copy of the build definition, as it may be mutated during build execution 
//  https://docs.oracle.com/javase/specs/jls/se12/html/jls-3.html#jls-Identifier 
//  Can get duplicate finish events 
//  This method is effectively part of a cross Gradle version contract. 
//  Read worker implementation classpath 
//  Any logging prior to this point will not end up in the daemon log file. 
//  with normalized line endings 
//  The following values are relatively expensive to create, so defer creation until required 
//  Use java 7 APIs, if available, otherwise fallback to no-op 
//  Move into cache 
// iterate and stop all daemons 
//  Read header 
//  2 lines: 1 for BuildStatus and 1 for Cursor parking space 
//  construct task selectors 
//  Get the CompilationLevel.SIMPLE_OPTIMIZATIONS class and set it on the CompilerOptions class 
//  The task dependencies for the configuration have been calculated using Configuration.getBuildDependencies(). 
//  Consumer version is provided by client 1.2 and later 
//  Write rich content to both stdout and stderr 
//  Replace 'Returns the ...'/'Sets the ...' with 'The ...'
//  it's rare that a component would declare more than 1 capability
//  we don't want to add core classloader explicitly here. 
//  The 'get'-getter was ignored, we can override it with the 'is'`-getter 
// this rule is just here to ensure backwards compatibility for builds that create publications with model rules 
//  Lock the state region, with the requested mode 
//  Ignore private getters without annotations 
//  Discard the node so it can be garbage collected. Some Ant tasks cache a potentially large amount of state   in fields. 
//  for each remaining level in the relativeTo path, add a .. 
//  Ends up with: 1 2 -> 3 <- 4 5 
//  Not part of a normal visitor, see ClosureCreationInterceptingVerifier 
//  Don't need to unpack the serialized failure. It will already have been reported and is not used by anything downstream of this action. 
//  Flushing data coming only from current appending 
// in theory this should not happen
//  What is actually exposed 
//  visible tasks are specified as those that have a non-empty group 
//  Don't track publications to repositories configured without a base URL 
//  GROOVY-3110: It may be an inner enum defined by this class itself, in which case it does not need to be   explicitly qualified by the currentClass name 
//  Append to failures for locking and fail on version conflict 
//  sort for determinism 
//  Perform the work per repository 
//  3) Set up the Antlr output directory (adding to javac inputs!) 
//  GENERATE public <return type> <method>(Closure v) { return <method>(…, ConfigureUtil.configureUsing(v)); } 
//  Now visit the result in order 
//  TODO merge in IoActions
// we need to filter at the level child runners because the suite is not doing the right thing here 
//  So, we just ignore the exception if the dir doesn't exist anymore 
//  block until the listener has finished notifying. 
//  should never happen here
//  Deduplicates the include file states, as these are often shared between source files 
//  Currently the converter is stateless, doesn't need any external context, so for performance we return a singleton 
//  0.9-rc-1 was broken for Java 5 
//  Order dynamic selectors after static selectors 
//  Callable<? super String> 
//  Read logging config and setup logging 
//  This has the downside of adding play-java-forms for all kind of play projects   including Scala based projects. Still, users can exclude the dependency if they   want/need. Maybe in the future we can enable users to have some flag to specify   if the project is Java or Scala based. 
//  Self close parent in order to discover its children, or its target in the case of a reference 
//  Do nothing 
//  System types come from the system classloader and their classloader is null. 
//  If there are different output properties compared to the previous execution, then we do have output changes 
//  alternatively, we could return project.getLayout().files(Runnable)   would differ in at least the following ways: 1. live 2. no autowiring 
//  if the target was invalid 
//  Coerce the value to the type accepted by the property setter and invoke the setter directly 
//  release any other project locks we might happen to hold 
//  add groovy-templates for Groovy 2.5+ 
//  the main "Java" component 
//  We are handling the root of the tree here 
//  Try to use a new label 
//  No wildcards: matches #5 above 
//  Have not seen this node before - add its dependencies to the head of the queue and leave this   node in the queue 
//  push back remaining bytes of multi-byte unicode character 
//  BCPGOutputStream seems to do some internal buffering, it's unclear whether it's strictly required here though 
//  Logging 
// if we don't know the parent we will use the top suite  this way we always have and id to attach logging events for 
//  the old value is a better fit than the new one, let's ignore the new one altogether 
//  Important not to add until after it has been applied as there can be   plugins.withType() callbacks waiting to build on what the plugin did 
//  Choose the 'main' artifact based on its type. 
//  type1 = ? super T 
//  whatever the exclude filter, there are no dependencies 
//  5.x only supports up to Java 12, 5.6 was the last release 
//  Use highest version on highest scope, keep highest scope exclusions only 
//             new Inspector().inspectModel(result); 
//  unboxing and boxing does the trick 
//  Tasks graph is already calculated and tasks executed. Action or model builders can access tasks results. 
//  From fork options 
//  Tasks 
//  only set a non-null task list on the operationParamsBuilder if at least one task has been given to this method,   this is needed since any non-null list, even if empty, is treated as 'execute these tasks before building the model'   this would cause an error when fetching the BuildEnvironment model 
//  Overwrite property 
//  the cached class loader as long as the action is executed 
//  Defines all projections for the node   Initializes the node   Allows a mutation to setup default values for an element   Mutation action provided when an element is defined   Customisations   Post customisation default values   Post mutation validations 
//  If these are not null, we are pessimistic (loaders asked for before locking) 
//  Not known yet 
//  TODO wolfs: We use `_Decorated` here, since IDEA import currently relies on this   See https://github.com/gradle/gradle/issues/8244
//  Use the ANSIOutputStream to strip out the ANSI escape sequences. 
//  A decorating factory 
//  Host: x86 
//  Exclude framework directories for GCC - they are added as system search paths but they are actually not 
//  TODO: make build type configurable for components
//  currently, we leave it to ZincScalaCompiler to also compile the Java code 
//  Don't log 
//  evicted, but it can still be reintegrated later in a different path.
//  state, cachedResolvedConfiguration, and extendsFrom intentionally not copied - must re-resolve copy   copying extendsFrom could mess up dependencies when copy was re-resolved 
//  tag::task-arg-method[] 
//  GENERATE public Object getProperty(String name) { return getAsDynamicObject().getProperty(name); } 
//  This method tries to minimize the number of volatile read/writes.   Do NOT try to inline the variables there. 
//  shouldn't happen
//  TODO: Configure 'eclipse' projects too
//  do not delete parent dirs 
//  unspecified 
//  Synthesise a test for the broken configuration method 
//  See https://blogs.msdn.microsoft.com/vcblog/2016/10/07/compiler-tools-layout-in-visual-studio-15/ 
//  Should provide a Gradle version as parameter so this check can be more precise 
//  We need to work with the 'String' version of the usage attribute, since this is expected for all providers by the `PreferJavaRuntimeVariant` schema 
//  Queue this up for checking again later   This is done because we're checking what we have locally in cache, and there may be nothing   so we're queuing it back so that the next time we check in remote access. 
//  JAR is compatible with classes or resources 
//  Transform ProgressCompleteEvent into their corresponding progress OperationIdentifier. 
// we expect that all options must be applicable for each task 
//  no special validation 
//  '\\\n' discarded from stream 
//  The other is disambiguated by current, never consider other again 
//  add the file name 
//  Safety check: dispatching a message should not cause the thread to dispatch another message (eg should not do any logging) 
//  This logger has been replaced (for example using `Gradle.useLogger()`), so don't log anything 
// below does not help on windows environments. I was unable to get plain javadoc utility to work successfully with multiline options _in_ the options file.  at least, it will work out of the box on linux or mac environments.  on windows, the options file will have correct contents according to the javadoc spec but it may not work (the failure will be exactly the same as if we didn't replace line breaks) 
// so that logging gets its way to the daemon log: 
//  Only <function-call>+ <args-list> supported 
//  Explicit flush, System.err is an auto-flushing PrintWriter unless it is replaced. 
//  Don't need to generate a subclass
//  Note: We can't conclude anything if the label scrolled so we leave the erasing to the parent widget. 
//  Already reported 
//  GENERATE objectFactory.fileCollection() 
// Is there any other parent properties?
//  buffer is full, wait until it has been read 
//  The same gatekeeper that opened it must close it 
//  Write count 
//  track the closure itself, not the action class. 
//  This is a performance optimization, dependency states are deduplicated 
//  Rewrite the method call to match TransformedModelDslBacking#configure(String, Closure), which is what the delegate will be 
//  Don't attach to any labels 
//  Have visited this node's dependencies - add it to the end of the plan 
//  Need gradle core to pick up ant logging adapter, AntBuilder and such 
//  Ignore missing files 
//  Don't care 
//  tag::custom-task-implementation[] 
// Find an existing matching conflict 
//  Not present, assume no failure details 
//  Suppress - checkstyle gets confused with type params on the outer type 
//  Commit all changes in the working tree 
//  Not yet supported for implicit included builds 
//  Default behavior is to always be buildable.  Binary implementations should define what   criteria make them buildable or not. 
//  Only merge if about the same capability, otherwise last wins 
//  Goal has previously been achieved or is no longer required 
//  Compare 2 dynamic selectors lexicographically 
//  handle tree 
//  get(<type>, <annotation>) 
//  Once the root build starts configuring, we are in Configuring phase 
//  Discard state that is no longer required 
//  does not override equals() but hashCode() in order to cache the latter's   pre-computed value to improve performance when used in HashMaps 
//  When this function has no parameters, we don't need to substitute parameters, so return the expression after macro expanding it   Also handle calling a zero args function, as we also don't need to substitute parameters 
//  Use an options file to pass across application classpath 
//  if the plugin has already been added 
//  Empty RHS 
//  If the event has no logging header, it doesn't manifest as console output. 
//  same classes may be found in different classpath trees/jars   and we keep only the first one 
//  We have to add these after the system properties so they can override any system properties   (identical properties later in the command line override earlier ones) 
// we don't merge anything in the iws, yet.  I kept the logic for the sake of consistency   and compatibility with pre M4 ways of configuring IDEA information. 
//  The last comment line is the timestamp 
//  Don't need to lock anything until we use the caches 
//  Handle failure 
//  If we detect a transformation in the classpath, we need to recompile, because we could typically be facing the case where   2 entries are reversed in the order of classpath elements, and one class that was shadowing the other is now visible 
//  Deserialize the class and parameters in the workerClassLoader (the context classloader) 
// end of workaround. 
//  If abortAll is set, also stop enforced tasks. 
//  Don't map 
//  Ignore for now 
//  delivery was interrupted, return silently 
//  Nothing special to check for UCRT 
//  We have a conflict
//  Have not visited the successor node, so add to the queue for visiting 
//  Build events 
//  would normally log at a level higher than (or equal to) lifecycle, but the Ant message priority is   actually lower than the set lifecycle log level 
// Need to do parameter substitution, return the value of the expression after parameter substitutions and macro expanding the result 
//  Prefer a selector that strictly matches the selected version
//  Cached resolved executables 
//  buffer was still full after non-blocking retries, now block 
//  Capture or log all failures 
//  If no authState has been established and this is a PUT or POST request, add preemptive authorisation 
//  consumer didn't express any preferences, everything fits 
//  Catch any unchecked io exceptions and add the file path for troubleshooting 
//  Historic note: this class still uses the Groovy JsonBuilder, as it was originally developed as a Groovy class. 
//  Create a client that will not match any existing daemons, so it will always startup a new one 
//  try the owner 
//  Includes trailing '/' 
//  Only share an ArtifactSet if the artifacts are not filtered by the dependency 
//  Make sure hash codes are serializable with a single byte length 
//  The first directory is the one created by JvmComponentPlugin.configureJvmBinaries()   to be used as the default output directory for processed resources 
//  For tests in default method of interface,   we might not be able to get the implementation class directly.   In this case, we need to retrieve test plan to get the real implementation class. 
//  Just read the state region 
//  The value is true if it is an output file, false if it is a parent of an output file 
//  Matches: task <identifier> or task(<identifier>) 
//  Hackery
