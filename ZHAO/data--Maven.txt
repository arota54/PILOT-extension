/*                      * TODO Extensions like Flex Mojos use custom scopes like "merged", "internal", "external", etc. In                     * order to don't break backward-compat with those, only warn but don't error out.                      */
/*      * TODO this needs to accept a {@link OverConstrainedVersionException} as returned by     *       {@link #getVersionRangeViolation(int)} but it's not used like that in     *       DefaultLegacyArtifactCollector      */
//  it's the building of the grandchild project, having already cached the child project   (but not the parent project), which causes the problem. 
//  TODO I would like to get rid of this. jvz. 
/*          * NOTE: This should be considered a quirk to support interop with Maven's legacy ArtifactDeployer which         * processes one artifact at a time and hence cannot associate the artifacts from the same project to use the         * same timestamp+buildno for the snapshot versions. Allowing the caller to pass in metadata from a previous         * deployment allows to re-establish the association between the artifacts of the same project.          */
//  TODO I'm really wondering where this method belongs; smells like it should be on MavenProject, but for some   reason it isn't ? This localization is kind-of a code smell. 
//  TODO: hack because metadata isn't generated in m2e correctly and i want to run the maven i have in the 
//  TODO this does not belong here. 
//  this is FOUL!          snapshotArtifact.isSnapshot(); 
//  NOTE: There's java.nio.charset.MalformedInputException and sun.io.MalformedInputException 
/*      * Derive the path portion of the given URL.     *     * @param url the repository URL     * @return the basedir of the repository     * TODO need to URL decode for spaces?      */
// TODO restore these if it makes sense 
//  TODO could the configuration be passed to lookup and the configurator known to plexus via the descriptor   so that this method could entirely be handled by a plexus lookup? 
// TODO error reporting 
//  TODO This replacing shouldn't be necessary as user.home should be in the 
//  TODO currently this is first wins, but really we should take the latest by comparing either the   snapshot timestamp, or some other timestamp later encoded into the metadata.   TODO this needs to be repeated here so the merging doesn't interfere with the written metadata    - we'd be much better having a pristine input, and an ongoing metadata for merging instead 
//  TODO what about wildcards? Just specifying groups? versions? 
//  TODO Use StringUtils here 
//  TODO From a concurrency perspective, this class is not good. The combination of mutable/immutable state is not nice 
//  TODO we probably want to warn the user that he is building an artifact with   different values than in dependencyManagement 
//  ---------------------------------------------------------------------------------   I'm not sure if this last regexp was really intended to disallow the usage of   network paths as user.home directory. Unfortunately it did. I removed it and   have not detected any problems yet.   ---------------------------------------------------------------------------------   path = path.replaceAll( "//", "/" ); 
//  TODO better way than static? this might hide messages in a reactor 
/*  * This exception is thrown if an application attempts to attach * two of the same artifacts to a single project. * * @author pgier * @author jdcasey * TODO Make this a checked exception, and modify the API of MavenProjectHelper. * Currently, this modification would create compatibility problems for existing plugins.  */
// TODO lifecycles being executed  TODO what runs in each phase  TODO plugins that need downloading  TODO project dependencies that need downloading  TODO unfortunately the plugins need to be downloaded in order to get the plugin.xml file. need to externalize this        from the plugin archive.  TODO this will be the class that people get in IDEs to modify 
/*          * NOTE: For plugins that depend on other plugin artifacts the plugin realm contains more than one plugin         * descriptor. However, only the first descriptor is of interest.          */
//  TODO not sure about this here, and may want a getLog on here as well/instead 
//  TODO Does this check need to happen here? Had to add the same call   below when we iterate on child nodes -- will that suffice? 
//  TODO MNG-5766 changes likely made this redundant 
//  TODO Move this to plexus-utils' PathTool. 
//  go find the version. This is a total hack. See previous comment. 
/*          * NOTE: This is primarily to keep backward-compat with Maven 2.x which did not validate that dependencies are         * unique within a single POM. Upon multiple declarations, 2.x just kept the last one but retained the order of         * the first occurrence. So when we're in lenient/compat mode, we have to deal with such broken POMs and mimic         * the way 2.x works. When we're in strict mode, the removal of duplicates just saves other merging steps from         * aftereffects and bogus error messages.          */
//  TODO Validate for < 0? 
/*          * MNG-4312: We neither have reserved all of the above magic expressions nor is their set fixed/well-known (it         * gets occasionally extended by newer Maven versions). This imposes the risk for existing plugins to         * unintentionally use such a magic expression for an ordinary system property. So here we check whether we         * ended up with a magic value that is not compatible with the type of the configured mojo parameter (a string         * could still be converted by the configurator so we leave those alone). If so, back off to evaluating the         * expression from properties only.          */
//    This is not ideal but there are events specifically for configuration from the CLI which I don't   believe are really valid but there are ITs which assert the right events are published so this   needs to be supported so the EventSpyDispatcher needs to be put in the CliRequest so that   it can be accessed by configuration processors. 
//  TODO could we use a map? Maybe if the parent did that for components too, as this is too vulnerable to 
//  TODO current policy is to retain the original version - is this correct, do we need strategies or is that handled elsewhere? 
//  TODO The configuration for the lifecycle needs to be externalized so that I can use the annotations properly for the   wiring and reference and external source for the lifecycle configuration. 
//  TODO a similar test should be created to test the dependency management (basically all usages   of DefaultModelBuilder.getCache() are affected by MNG-6530 
//  TODO shouldn't the versions be merged across relocations? 
//  TODO this should not need to be handed off... 
//  note this will not be hit for Maven 1.x project.xml as it is an incompatible schema 
//  TODO push all common bits back to plexus cli and prepare for transition to Guice. We don't need 50 ways to make CLIs 
//  ------------------------------------------------------------------------   Metadata Resolution Exceptions: ArtifactResolutionExceptions   ------------------------------------------------------------------------ 
// TODO why is this using the context 
//  TODO !![jc; 28-jul-2005] check this; if we're using '-r' and there are aggregator tasks, this will result in weirdness. 
//  Validate versions aren't inherited when using parent ranges the same way as when read externally. 
//  TODO need to externalize CliRequest 
//    We should get a whole slew of dependencies resolving this artifact transitively 
//  NOTE: We SHOULD NOT be inheriting status, since this is an assessment of the POM quality.   NOTE: We SHOULD NOT be inheriting relocation, since this relates to a single POM 
//  TODO could be more efficient by sorting the list and then moving along the restrictions in order? 
//  set the recommended version   TODO maybe its better to just pass the range through to retrieval and use a   transformation? 
//    There are too many ConfigurationProcessors so we don't know which one to run so report the error.   
//  1.any < 1.1 ? 
/*  * Exception that occurs when an artifact file is used, but has not been resolved. * * @author <a href="mailto:brett@apache.org">Brett Porter</a> * TODO it may be better for artifact.getFile() to throw it - perhaps it is a runtime exception?  */
//  TODO log message or throw exception? 
/*      * NOTE: This exists merely for backward-compat with legacy-style lifecycle definitions and allows configuration     * injection to work instead of failing.      */
//  This class needs to stick around because it was exposed the the remote resources plugin started using it instead of   getting the repositories from the project. 
//  Maven 2.x quirk: an artifact always points at the local repo, regardless whether resolved or not 
//  TODO Optimize; or maybe just rewrite the whole way aggregating mojos are being run. 
/*              * NOTE: getId() was added in 3.x and is as such not implemented by plugins compiled against 2.x APIs.              */
//  TODO don't catch exception 
//  TODO use settings? 
/*      * TODO: Whether duplicates should be removed looks like an option for the generated merger.      */
// TODO These two tests display a lack of symmetry with respect to the input which is a free form string and the        mojo descriptor which comes back. All the free form parsing needs to be done somewhere else, this is        really the function of the CLI, and then the pre-processing of that output still needs to be fed into        a hinting process which helps flesh out the full specification of the plugin. The plugin manager should        only deal in concrete terms -- all version finding mumbo jumbo is a customization to base functionality        the plugin manager provides. 
// TODO this will be the basis of the customizable lifecycle execution so need to figure this out quickly. 
//  TODO Use the following two instead of manageArtifact   TODO Remove ResolutionListenerDM interface 
//  We have collected all the problems so let's mimic the way the old code worked and just blow up right here.   That's right lets just let it rip right here and send a big incomprehensible blob of text at unsuspecting   users. Bad dog!
//  note: see MNG-3454. This causes a problem, but fixing it may break more.
//  FIXME: This is hacky. What if module directory doesn't match artifactid, and parent   is coming from the repository?? 
//  NOTE: DuplicateArtifactAttachmentException is currently unchecked, so be careful removing this try/catch!   This is necessary to avoid creating compatibility problems for existing plugins that use   MavenProjectHelper.attachArtifact(..). 
/*  * Describes a version transformation during artifact resolution. * * @author <a href="mailto:brett@apache.org">Brett Porter</a> * TODO try and refactor to remove abstract main.methods - not particular happy about current design  */
/*      * @return the required dependencies in a specified scope     * TODO the name is not intelligible      */
//  TODO shouldn't need to double up on this work, only done for simplicity of handling   recommended 
//    Trying to give loggers back is a bad idea. Ceki said so :-)   notice to self: what was this method supposed to do?   
//  TODO Kristian wonders if this class really is necessary and if it overlaps other concepts. 
//  TODO might be better to have source.retrieve() throw a specific exception for this   situation 
//  This is really a wagon TransferFailedException so something went wrong after we successfully   retrieved the metadata. 
/*  * Filter to exclude from a list of artifact patterns. * * @author <a href="mailto:brett@apache.org">Brett Porter</a> * TODO I think this is equiv. to exclusion set filter in maven-core  */
//  TODO this is only to provide a project for plugins that don't need a project to execute but need some   of the values from a MavenProject. Ideally this should be something internal and nothing outside Maven 
//  TODO why MVN adds dot /./ in paths??? 
//  TODO introducing a space here...not sure what else to do but collapse whitespace 
//  igorf: Way too many declared exceptions!
/*  * Describes repository directory metadata. * * @author <a href="mailto:brett@apache.org">Brett Porter</a> * TODO not happy about the store method - they use "this"  */
//  TODO We currently cannot tell which <dependencyManagement> section contained the management        information. When the resolver provides this information, these log messages should be updated        to contain it. 
//  TODO Hack to make the cycle detection the same for the new graph builder 
//  TODO the antrun plugin has its own configurator, the only plugin that does. might need to think about how that works   TODO remove the coreArtifactFilterManager 
//    TODO jvz Why isn't all this checking the job of the duty of the workspace resolver, we know that we   have a model that is suitable, yet more checks are done here and the one for the version is problematic   before because with parents as ranges it will never work in this scenario.   
/*      * TODO: The order of the merged list could be controlled by an attribute in the model association: target-first,     * source-first, dominant-first, recessive-first      */
//  TODO add better exception 
//  TODO let the scope handler deal with this 
//  artifact or not. things like the stupid dummy artifact coming from surefire.
//  this is just silly, lookupList should return an empty list! 
//  TODO This needs to be colorized 
/*      * TODO: Whether the merge continues recursively into an existing node or not could be an option for the generated     * merger      */
/*  * Specific problems during resolution that we want to account for: * <ul> *   <li>missing metadata</li> *   <li>version range violations</li> *   <li>version circular dependencies</li> *   <li>missing artifacts</li> *   <li>network/transfer errors</li> *   <li>file system errors: permissions</li> * </ul> * * @author Jason van Zyl * TODO carlos: all these possible has*Exceptions and get*Exceptions main.methods make the clients too *       complex requiring a long list of checks, need to create a parent/interface/encapsulation *       for the types of exceptions  */
/*      * TODO this needs to accept a {@link OverConstrainedVersionException} as returned by     *       {@link #getVersionRangeViolation(int)} but it's not used like that in     *       {@link org.apache.maven.repository.legacy.resolver.DefaultLegacyArtifactCollector}      */
//  MAVENAPI FIXME: the DAG used is NOT only used to represent the dependency relation,   but also for <parent>, <build><plugin>, <reports>. We need multiple DAG's   since a DAG can only handle 1 type of relationship properly.   Usecase:  This is detected as a cycle:   org.apache.maven:maven-plugin-api                -(PARENT)->   org.apache.maven:maven                           -(inherited REPORTING)->   org.apache.maven.plugins:maven-checkstyle-plugin -(DEPENDENCY)->   org.apache.maven:maven-plugin-api   In this case, both the verify and the report goals are called   in a different lifecycle. Though the compiler-plugin has a valid usecase, although   that seems to work fine. We need to take versions and lifecycle into account. 
//  Don't want the artifact's version in here, as this is stored in the directory above that 
/*  * Use a regular expression search to find and resolve expressions within the POM. * * @author jdcasey Created on Feb 3, 2005 * TODO Consolidate this logic with the PluginParameterExpressionEvaluator, minus deprecations/bans.  */
//  FIXME: Filter out the inherited == false stuff! 
/*      * TODO pluginDescriptor classRealm and artifacts are set as a side effect of this     *      call, which is not nice.     * @throws PluginResolutionException      */
//  We need to set the file here or the resolver will fail with an NPE, not fully equipped to deal   with multiple local repository implementations yet. 
//  TODO if it was null, we really need to go find them now... or is this taken care of by the ordering? 
//  This won't be valid, but it constructs something easy to read in the error message 
//  TODO This should eventually be migrated to DefaultPathTranslator. 
/*                      * NOTE: Other configurators like the map-oriented one don't call into the listener, so do it the                     * hard way.                      */
/*  * Wraps an active project instance to be able to receive updates from its artifact without affecting the original * attributes of this artifact. * * @author <a href="mailto:brett@apache.org">Brett Porter</a> * TODO I think this exposes a design flaw in that the immutable and mutable parts of an artifact are in one class and * should be split. ie scope, file, etc depend on the context of use, whereas everything else is immutable.  */
//  Some better conventions for the test poms needs to be created and each of these tests   that represent a verification of a specification item needs to be a couple lines at most.   The expressions help a lot, but we need a clean to pick up a directory of POMs, automatically load   them into a resolver, create the expression to extract the data to validate the Model, and the URI   to validate the properties. We also need a way to navigate from the Tex specification documents to 
//  TODO classpath check doesn't belong here - that's the other method 
//  TODO Not entirely the same message 
//  TODO this could be a lot nicer... should really be in the snapshot transformation? 
//  TODO should this be part of mediation? 
//  FIXME: somehow report to the user   that there are too many '..' elements.   For now, ignore the extra '..'. 
/*              * MNG-4900: Hack to workaround deficiency of legacy API which makes it impossible for plugins to access the             * global profile manager which is required to build a POM like a CLI invocation does. Failure to consider             * the activated profiles can cause repo declarations to be lost which in turn will result in artifact             * resolution failures, in particular when using the enhanced local repo which guards access to local files             * based on the configured remote repos.              */
//  TODO without #, this could just be an evaluate call... 
//    Builder, concurrency and parallelism     We preserve the existing main.methods for builder selection which is to look for various inputs in the threading   configuration. We don't have an easy way to allow a pluggable builder to provide its own configuration   parameters but this is sufficient for now. Ultimately we want components like Builders to provide a way to   extend the command line to accept its own configuration parameters.
//  TODO ick. this forces the OCE that should have come from the previous call. It is still 
// Maybe it's better to move some of those main.methods to separate class (SoC).
//  TODO Not sure how best to set these for this implementation... 
/*          * NOTE: This should be considered a quirk to support interop with Maven's legacy ArtifactDeployer which         * processes one artifact at a time and hence cannot associate the artifacts from the same project to use the         * same version index. Allowing the caller to pass in metadata from a previous deployment allows to re-establish         * the association between the artifacts of the same project.          */
//  TODO shouldn't need a file intermediatary - improve wagon to take a stream 
//  TODO should we deprecate? 
//  shouldn't it be java-sources given the classifier?   shouldn't it be false given the classifier? 
//  validation error, continue project building and delay failing to help IDEs   result.getProblems().addAll(e.getProblems()) ? 
/*  * The bean containing the Mojo descriptor.<br> * For more information about the usage tag, have a look to: * <a href="https://maven.apache.org/developers/mojo-api-specification.html"> * https://maven.apache.org/developers/mojo-api-specification.html</a> * * TODO is there a need for the delegation of MavenMojoDescriptor to this? * Why not just extend ComponentDescriptor here?  */
//  TODO add better exception that can detail the two conflicting artifacts 
//  TODO Remove this! 
//  TODO also do this logging for other metadata? 
/*          * NOTE: From Artifact.hasClassifier(), an empty string and a null both denote "no classifier". However, some         * plugins only check for null, so be sure to nullify an empty classifier.          */
//  TODO not sure that it should assume this, maybe the calls to addMetadata should pre-merge, then artifact   replaces? 
//  Why are we just ignoring this exception? Are exceptions are being used for flow control 
//  TODO This is too early for build extensions, so maybe just remove it? 
/*          * The workspace/reactor is in flux so we better not assume definitive information for any of its         * artifacts/projects.          */
//  blech! this isn't even intelligible as a method name. provided for   consistency... 
/*  * Pseudo test to generate documentation fragment about supported CLI options. TODO such documentation generation code * should not be necessary as unit test but should be run during site generation (Velocity? Doxia macro?)  */
//  TODO throw something instead? 
//  will be reported via storeInlocalRepository 
//         {              message.append( "There was 1 validation error: " );          }          else          {              message.append( "There was " + messages.size() + " validation errors: " + NEWLINE );          }   
//  then relative path calculation will fail during build from disk but success when calculated from repo
//  workspace 
//  NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions
/*  (non-Javadoc)    * @see org.apache.maven.profiles.ProfileManager#explicitlyDeactivate(java.lang.String)     */
//  Sun/Oracle advises to empty the char array 
//  ----------------------------------------------------------------------   Requirements   ---------------------------------------------------------------------- 
//  Arch 
//  Comments 
//  constants -------------------------------------------------------------- 
//  noop 
//  USED BY REMOTE RESOURCES PLUGIN 
//  meta-versions are not valid <version/> values...don't write them.
//  Post 
//  MNG-3769: the [probably relocated] artifact is excluded.   We could process exclusions on relocated artifact details in the   MavenMetadataSource.createArtifacts(..) step, BUT that would   require resolving the POM from the repository very early on in   the build.
//  UpdatePolicy 
//  disown the parent 
//  ------------------------------------------------------------------------   ErrorArtifactExceptions: ArtifactResolutionExceptions   ------------------------------------------------------------------------
//  @Configuration(source="org/apache/maven/lifecycle/lifecycles.xml") 
//  phase 1 
//  Was not an expression
//  Includes 
//    The plugin has a custom component configurator but does not have a custom mojo execution configurator   so fall back to the default mojo execution configurator.   
//  We need to take in multiple lifecycles
/*  MNG-3938  */
//  v1-->v2 
// [01] clean:clean  [02] resources:resources  [03] compiler:compile  [04] it:generate-metadata  [05] resources:testResources  [06] compiler:testCompile  [07] it:generate-test-metadata  [08] surefire:test  [09] jar:jar  [10] install:install   
//    Acceptable versions for continuous delivery     changelist   revision   sha1   
//  BASE64Encoder b64 = new BASE64Encoder(); 
//  We want to eliminate any relative path nonsense and lock down the path so we   need to fully resolve it before any sub-modules use the path. This can happen   when you are using a custom settings.xml that contains a relative path entry   for the local repository setting. 
//    We enter the session scope right after the MavenSession creation and before any of the   AbstractLifecycleParticipant lookups   so that @SessionScoped components can be @Injected into AbstractLifecycleParticipants.   
/*              * MNG-2277, the check below compensates for our bad plugin support where we ended up with aggregator             * plugins that require dependency resolution although they usually run in phases of the build where project             * artifacts haven't been assembled yet. The prime example of this is "mvn release:prepare".              */
//  exact matches win first 
//  -------------------------------------------------------------------------------------   Alright, here's the justification for all the regexp wizardry below...     Continuum and other server-like apps may need to locate the user-level and   global-level settings somewhere other than ${user.home} and ${maven.home},   respectively. Using a simple replacement of these patterns will allow them   to specify the absolute path to these files in a customized components.xml   file. Ideally, we'd do full pattern-evaluation against the sysprops, but this   is a first step. There are several replacements below, in order to normalize   the path character before we operate on the string as a regex input, and   in order to avoid surprises with the File construction...   ------------------------------------------------------------------------------------- 
//  for the special case of a drive-relative Windows path, make sure it's absolute to save plugins from trouble 
//  Path Utils 
//  TODO figure out how to use the same PluginDescriptor when running mojos
//  ----------------------------------------------------------------------   Reactor Failure Mode   ---------------------------------------------------------------------- 
//  populate the configuration section 
//  this should never happen since we checked all possible error sources before but better be sure 
//  Keep this class in sync with org.apache.maven.plugin.internal.DefaultPluginDependenciesResolver.GraphLogger 
//  -------< groupId:artifactId >------- 
/* MNG-3900 */
//  Contributor 
//  version but the restriction is identical 
//  ----------------------------------------------------------------------------------------------------------------       D E P R E C A T E D       ----------------------------------------------------------------------------------------------------------------     Everything below will be removed for Maven 4.0.0     ---------------------------------------------------------------------------------------------------------------- 
//  likely Boolean -> boolean, Short -> int etc. conversions, it's not the problem case we try to avoid 
//  should have been AbstractToolchain... 
//  last ANSI escape code is reset: no next color 
//  guard against modification/removal of keys in the given properties (MNG-5670, MNG-6053, MNG-6105) 
//  We only check for groupId/artifactId/version/classifier cause if there is another   module with the same groupId/artifactId/version/classifier this will fail the build   earlier like "Project '...' is duplicated in the reactor.   So it is sufficient to check only groupId/artifactId/version/classifier and not the   packaging type. 
/*                      * Most existing extensions don't define exported packages, i.e. no classes are to be exposed to                     * plugins, yet the components provided by the extension (e.g. artifact handlers) must be                     * accessible, i.e. we still must import the extension realm into the project realm.                      */
//  ok 
// ------------------------------------------------------------------------------------------ 
//  version skew drop back to resolution from the repository 
//  aliases 
//  ----------------------------------------------------------------------   Goal specific configuration   ---------------------------------------------------------------------- 
//  Used by m2eclipse 
//  Group id 
//  normal for non-http wagons 
//  phase 2 
/*      * @see junit.framework.TestCase#setUp()      */
//  2nd pass of initialization: resolve and build parent if necessary 
// =================================================================================================== 
//  no workspace resolver or workspace resolver returned null (i.e. model not in workspace) 
//  to be processed in the outer catch block 
//  hide constructor 
//  -----------------------------------------------------------------------   , String version, String artifactUri ) 
//  nothing to do. 
//  NB this is live injected collection 
//  The remaining are basically "for future expansion" 
//  optional flag is not managed
//  remove once createArtifacts() is removed 
//  CHECKSTYLE_OFF: MagicNumber 
/* MNG-1957 */
/*  MNG-4102 */
//  ignore. The parent artifact will handle metadata.   we must fail silently here to avoid problems with the artifact transformers.
/*                  * NOTE: This is to provide a migration path for implementors of the legacy API which did not know about                 * getLifecycles().                  */
//  lower than 2^63 
//  "pluginPrefix:goal" or "groupId:artifactId[:version]:goal" 
//                              
//  of cause 
//  add default toolchain 
//  switch dominant with recessive 
//  ----------------------------------------------------------------------   Dependencies   ---------------------------------------------------------------------- 
//  ChildScmConnectionInheritAppendPath 
// */ 
//  this node 
//  ----------[ packaging ]---------- 
//  SnapshotRepository 
//  avoid concurrent modification if someone else sets/removes an unrelated system property 
//  3. the parent's <inherited/> flag is set to true 
//  resolve plugin artifacts 
//  Prefixes 
//    Public API   
//  Plugin management :: aggregate 
//  USED BY DEPENDENCY PLUGIN, ARCHETYPE DOWNLOADER 
//  DeveloperConnection 
//  v1-->v3 
//  Backward compat 
//  parent references child with directory name (which is not artifact id) 
//  It's a POM - we don't need to retrieve it first
/*  MNG-3567 */
//  TODO deep compare the lists
//  Dependencies 
//  Unsubscribe 
//  ensure canonical order of standard lifecycles 
//  This is being lazy instead of making interface 
//  System 
//  re-build pom with modified parent 
//  added to retain compile artifactScope. Remove if you want compile inherited as runtime 
/*  MNG-4008  */
//  if we haven't added this arg to the buffer, and we ARE building an argument   buffer, then append it with a preceding space...again, not sure what else to   do other than collapse whitespace. 
//  keep the checksum files from showing up on the download monitor... 
//  TargetPath 
//  only show msg if a change is actually taking place 
//  overlaps 
//  prime realm cache 
//  ModelVersion 
//  [groupId]:artifactId 
//  Id 
/*     * @see org.apache.maven.artifact.resolver.conflict.ConflictResolverFactory#getConflictResolver(java.lang.String)     */
//  inheritance assembly 
//  BuildBase 
/*  getArtifact  */
//  org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process@executionId 
//  still unreadable even in non-strict mode, rethrow original error 
//  unset the firstRun flag, so we don't get caught in an infinite loop... 
//  MNG-5670 guard against ConcurrentModificationException   MNG-6053 guard against key without value
//  path was already absolute, just normalize file separator and we're done 
//  ////////////////////////////////////////////////////////////////////////////////////////////////////////////////     Project collection     //////////////////////////////////////////////////////////////////////////////////////////////////////////////// 
//  changes above not being propagated to the map 
//  collect drop list 
/*  don't call createDependencyArtifact as it'll ignore test and provided scopes  */
//  clear the calculated artifactMap 
//  for each finished project 
//  else fall back to default log level specified in conf   see https://issues.apache.org/jira/browse/MNG-2570 
//  Plugin0 [plexus] 
//  the order of these two is non-deterministic, based on when they're added to the reactor. 
//  special case: if there is a windows drive letter, then keep the original return value 
//  Not going to happen 
//  Site 3.x 
//  model path translation 
//  org.apache.maven.its.mng4834:parent:0.1 
//  Plugins 
//  nop 
//  Properties 
//  ----------------------------------------------------------------------   I'm leaving the setting of system properties here as not to break   the SystemPropertyProfileActivator. This won't harm embedding. jvz.   ---------------------------------------------------------------------- 
//  add missing '/' between url and path 
//  ExcludeDefaults 
//    The projects need to be topologically after the participants have run their afterProjectsRead(session)   because the participant is free to change the dependencies of a project which can potentially change the   topological order of the projects, and therefore can potentially change the build order.     Note that participants may affect the topological order of the projects but it is   not expected that a participant will add or remove projects from the session.   
//  Keep this class in sync with org.apache.maven.project.DefaultProjectDependenciesResolver.GraphLogger 
//  main.methods ----------------------------------------------------------------
//  ------------------------------------------------------------------------   Exceptions   ------------------------------------------------------------------------
/*              * This logic (using filesystem, against wanted independence from the user environment) exists only for the             * sake of backward-compat with 2.x (MNG-5000). In general, it is wrong to             * base URL inheritance on the module directory names as this information is unavailable for POMs in the             * repository. In other words, modules where artifactId != moduleDirName will see different effective URLs             * depending on how the model was constructed (from filesystem or from repository).              */
//  ----------------------------------------------------------------------------   We need to allow per execution user and global settings as the embedder   might be running in a mode where its executing many threads with totally   different settings.   ---------------------------------------------------------------------------- 
//  fail fast on RuntimeExceptions, Errors and "other" Throwables   assume these are system errors and further build is meaningless
//  but ok from repo: local disk is ignored 
//  end hack 
//  ----------------------------------------------------------------------   Options that are set on the command line become system properties   and therefore are set in the session properties. System properties   are most dominant.   ---------------------------------------------------------------------- 
// insert classifier only if it was used in the artifact 
//  nothing here 
/*     	 *       v2    	 *   v1<    	 *      v3-v4    	 *    	  */
//  build project once 
//    All of this needs to go away and be couched in terms of the execution request 
//  build from disk expected to fail 
/*  && s2 != null  */
//  if we're building an argument, keep doing so. 
//  MNG-3832: Aether (part of M3+) supports wildcard expressions for exclusions
//  only set those on 2nd phase, ignore on 1st pass 
//  Empirical data from 3.x, actual =40 
//  Enabled 
/*  MNG-3846 */
//  else assume "never" 
//    We expect at most 2 implementations to be available. The SettingsXmlConfigurationProcessor implementation   is always available in the core and likely always will be, but we may have another ConfigurationProcessor   present supplied by the user. The rule is that we only allow the execution of one ConfigurationProcessor.   If there is more than one then we execute the one supplied by the user, otherwise we execute the   the default SettingsXmlConfigurationProcessor. 
//  Exclusions 
//  -----------------------------------------------------------------------------------------------   Tests which exercise the lifecycle executor when it is dealing with default lifecycle phases.   ----------------------------------------------------------------------------------------------- 
//  For some reason with the introduction of MNG-1577 we have the case in Yoko where a depMan section has   something like the following:     <dependencyManagement>       <dependencies>           <!--  Yoko modules -->           <dependency>               <groupId>org.apache.yoko</groupId>               <artifactId>yoko-core</artifactId>               <version>${version}</version>           </dependency>   ...     And the range is not set so we'll check here and set it. jvz.
//  System.err.println("Linked("+requestedScope+") 
//  drive-relative Windows path 
//  Checksum policy 
//  does nothing 
//  Mocks to inject into toolchainManager 
//  Recursive (really to just process the top-level POM) 
//  Needs to go away
/*  MNG-2309 */
//  these are local 
/*  MNG-2591  */
//  Optional 
//  marker interface for cache keys 
//  the declaring project MUST be listed after the plugin and its plugin-level dep, though. 
//  sleep for 10ms just in case this is windows holding a file lock 
//  Propagate the parallel flag to the root session and all of the cloned sessions in each project segment 
//  we don't canonicalize on unix to avoid interfering with symlinks
/*  MNG-4193  */
//  notify listeners about "soft" project build failures only 
//    1) Setup initial properties.     2) Validate local repository directory is accessible.     3) Create RepositorySystemSession.     4) Create MavenSession.     5) Execute AbstractLifecycleParticipant.afterSessionStart(session)     6) Get reactor projects looking for general POM errors     7) Create ProjectDependencyGraph using trimming which takes into account --projects and reactor mode.   This ensures that the projects passed into the ReactorReader are only those specified.     8) Create ReactorReader with the getProjectMap( projects ). NOTE that getProjectMap(projects) is the code that   checks for duplicate projects definitions in the build. Ideally this type of duplicate checking should be   part of getting the reactor projects in 6). The duplicate checking is conflated with getProjectMap(projects).     9) Execute AbstractLifecycleParticipant.afterProjectsRead(session)     10) Create ProjectDependencyGraph without trimming (as trimming was done in 7). A new topological sort is   required after the execution of 9) as the AbstractLifecycleParticipants are free to mutate the MavenProject   instances, which may change dependencies which can, in turn, affect the build order.     11) Execute LifecycleStarter.start() 
//  local wins now, and irrelevant if not local as test/provided aren't transitive   assertEquals( "Check artifactScope", Artifact.SCOPE_RUNTIME, artifact.getArtifactScope() ); 
//         child.setPluginRepositories(              ModelUtils.mergeRepositoryLists( child.getPluginRepositories(), parent.getPluginRepositories() ) ); 
//  ignore, see above 
/* - test projects for each of these- how to categorize the problems so that the id of the problem can be match to a page with descriptive help and the test  project- nice little sample projects that could be run in the core as well as integration testsAll Possible Errors- invalid lifecycle phase (maybe same as bad CLI param, though you were talking about embedder too)- <module> specified is not found- malformed settings- malformed POM- local repository not writable- remote repositories not available- artifact metadata missing- extension metadata missing- extension artifact missing- artifact metadata retrieval problem- version range violation- circular dependency- artifact missing- artifact retrieval exception- md5 checksum doesn't match for local artifact, need to redownload this- POM doesn't exist for a goal that requires one- parent POM missing (in both the repository + relative path)- component not foundPlugins:- plugin metadata missing- plugin metadata retrieval problem- plugin artifact missing- plugin artifact retrieval problem- plugin dependency metadata missing- plugin dependency metadata retrieval problem- plugin configuration problem- plugin execution failure due to something that is know to possibly go wrong (like compilation failure)- plugin execution error due to something that is not expected to go wrong (the compiler executable missing)- asking to use a plugin for which you do not have a version defined - tools to easily select versions- goal not found in a plugin (probably could list the ones that are)  */
//  plugin management injection 
//  would ever need this so it should not be exposed in a public API
//  MNG-5509   See org.eclipse.aether.connector.wagon.WagonRepositoryConnector.connectWagon(Wagon)
//    Publisher 
//  ------------------------------------------------------------------------   Repositories   ------------------------------------------------------------------------ 
//  This supports painless invocation by the Verifier during embedded execution of the core ITs 
/*  (non-Javadoc)    * @see org.apache.maven.profiles.ProfileManager#getActiveProfiles()     */
//  reactor failure modes 
//  Extensions are accumulated 
//  check all transitive deps of a compile dependency are compile scope, except for runtime and test 
//  use the local copy, or if it doesn't exist - go to the remote repo for it 
/*  && rootArtifact.getFile() == null  */
//  ChecksumPolicy 
//  , String version, String artifactUri ) 
//  verifies profile applied 
//  load the child project, which inherits from p0... 
//  Cyclic Dependency Error 
// InstallResult install( RepositorySystemSession session, InstallRequest request )                  throws InstallationException;   release, snapshot unique ou non unique, attachment 
//  more english-friendly method...keep the code clean! :) 
/*  artifacts  */
//  Plugin1 [antlr] 
//  Beer comes straight after package in stub, much like real life. 
//  as they are not both null 
//  if not then i need to grab the mojo descriptor and look at the phase that is specified 
//  tests ------------------------------------------------------------------ 
//  assume it won't ever be.
//  versions with string lengths from 1 to 19 
//  Update snapshots 
//  +" has been terminated on this entry set\n-------------------\n"   +ins   +"\n-------------------\n"   ); 
// [01] resources:resources  [02] compiler:compile  [03] it:generate-metadata  [04] resources:testResources  [05] compiler:testCompile  [06] plexus-component-metadata:generate-test-metadata  [07] surefire:test  [08] jar:jar   
//  Metadata cannot be retrieved 
//  TODO configure these on the repository 
//  be sure we're testing the right class, i.e. DefaultVersionResolver.class 
//  Cipher uses Strings 
/*  MNG-3545  */
//  check with getPom( baseName + "-expected" ) 
//    Retriever 
//  this will run at most twice. The first time, the firstRun flag is turned off, and if the retry flag   is set on the first run, it will be turned off and not re-set on the second try. This is because the 
//  File 
//  make sure IncludesArtifactFilter is not equal ExcludesArtifactFilter! 
//  previously we cloned the artifact, but it is more efficient to just update the artifactScope   if problems are later discovered that the original object needs its original artifactScope value,    cloning may   again be appropriate 
//  Length 11+ chars 
//  very important to use the parentPlugins List, rather than parentContainer.getPlugins() 
//  metadata is added via addPluginArtifactMetadata 
//    Our settings.xml source is historically how we have configured Maven from the CLI so we are going to   have to honour its existence forever. So let's run it.   
// LocalRepositoryManager newLocalRepositoryManager( LocalRepository localRepository ); 
//  Base directory 
//  multi projects build entry point 
// VersionRangeResult resolveVersionRange( RepositorySystemSession session, VersionRangeRequest request )                  throws VersionRangeResolutionException; 
//  Activation 
//  initial try, use locally cached metadata 
//  default: fail fast   default: true   default: false   optional   optional 
/*  MNG-4102  */
//  only merge plugin definition from the parent if at least one   of these is true:   1. we're not processing the plugins in an inheritance-based merge   2. the parent's <inherited/> flag is not set 
//  parent references child with artifactId (which is not directory name) 
//  ----------------------------------------------------------------------     ---------------------------------------------------------------------- 
//  The root artifact may, or may not be resolved so we need to check before we attempt to resolve.   This is often an artifact like a POM that is taken from disk and we already have hold of the   file reference. But this may be a Maven Plugin that we need to resolve from a remote repository   as well as its dependencies. 
//  ChildSiteUrlInheritAppendPath 
//  otherwise, we trim the trailing " and append to the buffer. 
//  read poms separately 
//  OutputDirectory 
//  for performance, check digits instead of relying later on catching NumberFormatException 
//  retain baseVersion 
//  Organization 
//  -----------------------------------------------------------------------------------------------   Tests which exercise the lifecycle executor when it is dealing with individual goals.   ----------------------------------------------------------------------------------------------- 
//  ------------------------------------------------------------------------------------- 
//  NOTE: There's no notion of taskSegment equality.
//  Remove remaining TransferListener instances (checksum handlers removed in above finally clause) 
//  NOTE: The case of a trailing quote is handled by nullifying the arg buffer. 
// ------------------------------------------------------------------- 
//    Raw file transfers   
//  We have metadata retrieval problems, or there are cycles that have been detected   so we give this back to the calling code and let them deal with this information   appropriately. 
//  file system errors 
//  Repository 
//  ------------------------------------------------------------------------------------------- 
//  effective line, with indent and reset if end is colored 
/*        At the moment, this class is totally immutable, and this is in line with thoughts about the       pre-calculated execution plan that stays the same during the execution.       If deciding to add mutable state to this class, it should be at least considered to       separate this into a separate mutable structure.      */
//  pure user error, suppress stack trace 
//  from here to the end of the method is dealing with merging of the <executions/> section. 
//  Family 
//  The system scoped dependencies will be present in the classloader for the plugin 
//  It would be cool if there was a hook that i could use to setup a test environment.   I want to setup a local/remote repositories for testing but i don't want to have   to change them when i change the layout of the repositories. So i want to generate   the structure i want to test by using the artifact handler manager which dictates   the layout used for a particular artifact type. 
//  start building an argument here. 
//      
//  this was a failed transfer, and we don't want to retry. 
//  previous one is more dominant 
//  Plugin groups 
//  won't happen 
//  We have no POM file.   
//    We are taking as much as we can from the DefaultArtifact.equals(). The requested artifact has no file so   we want to remove that from the comparison.   
//  Jdk 
//  Site 
//    Taken from LegacyRepositorySystem   
//  We will attempt to get nab a system property as a way to specify a   parameter to a plugins. My particular case here is allowing the surefire   plugin to run a single test so I want to specify that class on the cli   as a parameter. 
//  Tag 
//    Run the user supplied ConfigurationProcessor   
//  check all transitive deps of a default dependency are compile scope, except for runtime and test 
//  Directory 
/*          * NOTE: Not used by Maven core, only here to provide backward-compat with plugins like the Install Plugin.          */
//                           String nonProxyHosts )      {          ProxyInfo proxyInfo = new ProxyInfo();          proxyInfo.setHost( host );          proxyInfo.setType( protocol );          proxyInfo.setPort( port );          proxyInfo.setNonProxyHosts( nonProxyHosts );          proxyInfo.setUserName( username );          proxyInfo.setPassword( password );            proxies.put( protocol, proxyInfo );            wagonManager.addProxy( protocol, host, port, username, password, nonProxyHosts );      } 
//  Distribution 
//  do nothing 
//               TreeSet<MetadataGraphEdge> deps = new TreeSet<MetadataGraphEdge>(                          new Comparator<MetadataGraphEdge>()                          {                              public int compare( MetadataGraphEdge e1                                                , MetadataGraphEdge e2                                                )                              { 
//  <groupId>:<artifactId>:<goal> 
// TODO maven-site-plugin -- not used by the plugin directly, but used by Doxia Integration Tool & MPIR 
//  This is the case where someone has executed a single goal from the command line   of the form:     mvn remote-resources:process     From the metadata stored on the server which has been created as part of a standard   Maven plugin deployment we will find the right PluginDescriptor from the remote   repository. 
//  This is used by the SITE plugin. 
//  inverse order 
//  append childPathAdjustment and childDirectory to parent url 
//  redirect stdout and stderr to file 
//  The rest is deprecated   USED BY MAVEN ASSEMBLY PLUGIN 2.2-beta-2 
//    Deprecated
/*  s1 != null &&  */
/* MNG- 4008 */
/*  farthest = runtime  */
//  We are going to take the project packaging and find all plugin in the default lifecycle and create   fully populated Plugin objects, including executions with goals and default configuration taken   from the plugin.xml inside a plugin.     TODO This whole method could probably removed by injecting lifeCyclePluginAnalyzer straight into client site.   TODO But for some reason the whole plexus appcontext refuses to start when I try this. 
// ---------------------------------------------------------------------------- 
//    New interface main.methods for the repository system.
//  muxer.setThisModuleComplete( projectBuild ); 
//  ArrayIndexOutOfBoundsException are typical indication of threading issues 
// noinspection ObjectEquality 
//  Used to import dependencyManagement dependencies 
//  now add all options, except for -D with cli first then config file 
//  ----------------------------------------------------------------------   Online vs. Offline requirement   ---------------------------------------------------------------------- 
//  we want to see all top-level thread groups 
//  Transfer listeners 
//    Code taken from LegacyRepositorySystem   
//  Reactor 
//  update policy doesn't affect contents 
//  the parent version is not a range, we have version skew, drop back to resolution from repo 
// addParameterUsageInfo( expression, messageBuffer ); 
//  Scope 
//  url 
//    Don't need any of this 
//  ----------------------------------------------------------------------   Plugins   ---------------------------------------------------------------------- 
//  Exists 
//  1.1 > 1-sp 
//  then relative path calculation will success during build from disk but fail when calculated from repo 
//  We do this in here so we can checksum the artifact metadata too, otherwise it could be metadata itself 
//  TestSourceDirectory 
// DeployResult deploy( RepositorySystemSession session, DeployRequest request )                  throws DeploymentException; 
//  Errors
//  string tokenizer won't detect these and ignores them
//  Contextualizable main.methods -----------------------------------------------
/*  (non-Javadoc)    * @see org.apache.maven.profiles.ProfileManager#explicitlyActivate(java.lang.String)     */
//  remove whitespaces at the end 
//  would like to throw this, but we have crappy stuff in the repo 
/*  MNG-786 */
//  copy fields 
//  Transfer Error
//  continue the build 
//  Beer comes straight after package in stub 
//  NOTE: The check for missing plugin versions is handled directly by the model builder 
//  qualifier is the whole version, including "-" 
//  Building Project Name Version    [i/n] 
//  InceptionYear 
//  But it was reset by the call to setVersionRange on restricting the version 
//  dependency management import 
//    Here we just need to know that a version is fine to use but this validation we can do in our workspace   resolver.   
//  write baseName + "-actual" 
//  ----------------------------------------------------------------------   Field validation   ---------------------------------------------------------------------- 
// not sure it's necessary to provide a default toolchain here.  only version can be eventually supplied, and
// fail( "should have failed since module reference == artifactId != directory name" ); 
//  special case: if omitted // on protocol, keep path as is 
//  the same instance can be provided multiple times under different Key's   deduplicate instances to avoid redundant beforeXXX/afterXXX callbacks 
//  runtime exceptions are most likely bugs in maven, let them bubble up to the user 
//  This is required by the surefire plugin 
//  enables no-arg constructor 
/* if_not[MAVEN4] */
//  the args are easy, cli first then config file 
//  version schemes not really supported: fully transformed as qualifier 
//  1.1 > 1-1 
//  test interpolation of basedir values in mojo configuration 
//  Won't happen 
//  read and validate raw model 
//  verify 
//  Empty path entry ("...//.."), remove. 
// TODO remote-resources-plugin 
//  ----------------------------------------------------------------------   Object overrides   ---------------------------------------------------------------------- 
//  we update the build number anyway so that it doesn't get lost. It requires the timestamp to take effect 
//  if this is the case of "-Dfoo=bar", then we need to adjust the buffer. 
/*  MNG-3836 */
//  validation error, continue project building and delay failing to help IDEs 
//  MNG-1927, MNG-2124, MNG-3355:   If the build section is present and the project directory is non-null, we should make   sure interpolation of the directories below uses translated paths.   Afterward, we'll double back and translate any paths that weren't covered during interpolation via the   code below...
//  override from command line 
//  check with getPom( "module-path-not-artifactId-effective" ) 
// -------------------------------------------------------------------  ------------------------------------------------------------------- 
//  use key as is 
//  ensure resulting url ends with slash if initial url was 
//  DefaultProjectBuilder 
//  Adding this back in for compatibility with the verifier that hard codes this option. 
//  LOG STREAMS 
//  Children 
//  Message 
//  Interactive 
//  ordering 
//  inceptionYear 
//  Conflict Resolution 
//  rethrow original errors and runtime exceptions 
//  managedVersionMap 
//  test and provided are not transitive, so exclude them 
//  a1 = alpha-1, b1 = beta-1, m1 = milestone-1 
//    Used by Tycho and will break users and force them to upgrade to Maven 3.1 so we should really leave   this here, possibly indefinitely. 
//  ArtifactId is neither inherited nor injected 
//  Missing 
/*  MNG-3760 */
//  Layout 
//  system scope is historic only - and simple 
/*  pluginArtifact  */
//  ArtifactId 
//  USED BY REMOTE RESOURCES PLUGIN, DEPENDENCY PLUGIN, SHADE PLUGIN 
//  OrganizationUrl 
/*  (non-Javadoc)    * @see org.apache.maven.profiles.ProfileManager#explicitlyActivate(java.util.List)     */
//  TODO Consider throwing UnsupportedSomething on hashCode/equals
//  invalid version range, so drop back to resolution from the repository 
//  unless it's an entry point.   currently processing the entry point - it should not have any entry incident edges 
//  use DefaultJavaToolChain for compatibility with maven 3.2.3 and earlier 
//  Version Range Violation 
//  no edges - don't need this vertex any more 
//  schedule independent projects 
//   <proxies>      <proxy>        <active>true</active>        <protocol>http</protocol>        <host>proxy.somewhere.com</host>        <port>8080</port>        <username>proxyuser</username>        <password>somepassword</password>        <nonProxyHosts>www.google.com|*.somewhere.com</nonProxyHosts>      </proxy>    </proxies> 
//  Overwrite existing values in model properties. Otherwise it's not possible 
//  -------------------------------------------------------------------------------------------   ------------------------------------------------------------------------------------------- 
/*  MNG-2591 */
//  igorf: plugin realm comes later   assertNotNull( mojoDescriptor.getRealm() ); 
//  RelativePath 
//  valid - check if it is greater than the currently matched version 
//  This appears only to be used in test code 
//  [prefix]:[goal] 
//  system scopes come through unchanged... 
//  advance res2 
//  Select an appropriate available version from the (now restricted) range   Note this version was selected before to get the appropriate POM 
//  ----------------------------------------------------------------------- 
/*  MNG-3979  */
//    Default to the standard multithreaded builder   
//  we have a value, so it has to match the system value... 
//  exports descriptors are entirely optional 
//  Reset - only needed for 'getId'. 
//  check for exact match 
//  notice: extension and classifier not really used in this test... 
//  Subscribe 
//  DefaultGoal 
//  if this fails, forget about it, we'll try to overwrite it anyway so no need 
//  Don't use snapshot metadata for LATEST (which isSnapshot returns true for) 
/*  MNG-6386  */
//  PluginManagement 
//  enables default constructor 
//  ciManagement 
//  advance res1 
//    Be nice to whittle this down to Session, maybe add task segments to the session. The session really is the   the place to store reactor related information.   
//  assertTrue( new DefaultArtifactVersion( "1.0-alpha10" ).compareTo( new DefaultArtifactVersion( "1.0-alpha1" ) ) > 0 ); 
//  used by the site plugin 3.x 
//  TODO figure out how to reuse ModelLocator.locatePom(File) here 
//  Remove any previous repository with this Id 
//  We retrieve the POM below in the retrieval step. 
//  schedule dependent projects, if all of their requirements are met 
/*  MNG-4129  */
/*         LifecycleMappingsXpp3Reader reader = new LifecycleMappingsXpp3Reader();        LifecycleConfiguration config = reader.read( new InputStreamReader( getClass().getResourceAsStream( "/lifecycle.xml" ) ) );        assertEquals( "check number of lifecycles", 1, config.getLifecycles().size() );        Lifecycle l = (Lifecycle) config.getLifecycles().iterator().next();        assertEquals( "check id", "clover", l.getId() );        assertEquals( "check number of phases", 1, l.getPhases().size() );        Phase p = (Phase) l.getPhases().iterator().next();        assertEquals( "check id", "generate-sources", p.getId() );        assertEquals( "check number of executions", 1, p.getExecutions().size() );        Execution e = (Execution) p.getExecutions().iterator().next();        assertEquals( "check configuration", "true", ((Xpp3Dom) e.getConfiguration()).getChild( "debug" ).getValue() );        assertEquals( "check number of goals", 1, e.getGoals().size() );        String g = (String) e.getGoals().iterator().next();        assertEquals( "check goal", "clover:compiler", g );         */
//  Start all the threads 
//  this is a live injected collection 
//    Internal   
//  ----------------------------------------------------------------------   Dependency requirement   ---------------------------------------------------------------------- 
//  reportArtifacts 
//  check all transitive deps of a provided dependency are provided scope, except for test 
//  reset the retry flag. 
//  overlap 
//  ----------------------------------------------------------------------   Parameters   ---------------------------------------------------------------------- 
//  ignore for now and delay failure to higher level processing 
//  ConflictResolverFactory main.methods ----------------------------------------
//  try to verify the SHA-1 checksum for this file. 
//  clone source roots 
//  NOTE: Enforce recursive merge to trigger merging/inheritance logic for executions as well
//  if we need to update artifactScope of nearest to use farthest artifactScope, use the   nearest version, but farthest artifactScope 
//  lifecycle phase 
//  ignore plugin descriptor parsing errors at this point   these errors will reported during calculation of project build execution plan
//  this should always be the case for non-super POM instances... 
//  Test may fail if we get interrupted 
//    Make sure the Maven home directory is an absolute path to save us from confusion with say drive-relative   Windows paths.   
//  legacy support for maven-gpg-plugin:1.0 
//  site 
//    This should probably be a separate tool and not be baked into Maven.
//  ----------------------------------------------------------------------   Project requirement   ---------------------------------------------------------------------- 
//  if we also fail to verify based on the MD5 checksum, and the checksum transfer/read   succeeded, then we need to determine whether to retry or handle it as a failure. 
//  Not totally sure if this is needed for anything
//  This is required right now. 
//  fields ----------------------------------------------------------------- 
//  not critical here 
//  ------------------------------------------------------------------------ 
//  second try, refetch all (possibly outdated) metadata that wasn't updated in the first attempt 
//        
/*      * @see org.codehaus.plexus.PlexusTestCase#tearDown()      */
//  MNG-4543
//  ---------------------------------------------------------------------   --------------------------------------------------------------------- 
//  Mirrors 
//  otherwise it is ignore 
//  Use the recommended version from the specified VersionRange since there is no   original recommended version 
//  populate the provides section 
/*  system and provided dependencies are not transitive  */
//  Used by m2e but will be removed, really. 
//  1 extra '/' to remove 
//  Profiles 
//  single entry in the classpath, populated from itself 
//  reports configuration 
//  Connection 
//  Reports 
/*  putArtifact  */
//                             + project1.getScm().getDeveloperConnection() );            assertEquals( project1.getScm().getUrl(), "http://host/viewer?path=/p0/modules/p1" );          assertEquals( project1.getScm().getConnection(), "scm:svn:http://host/p0/modules/p1" );          assertEquals( project1.getScm().getDeveloperConnection(),                        "scm:svn:https://host/p0/modules/p1" );      } 
//  touch file so that this is not checked again until interval has passed 
//  Packaging 
//  ------------------------------------------------------------------------   Circular Dependency Exceptions   ------------------------------------------------------------------------ 
//  assertVersionOlder( "1.0-alpha-1-SNAPSHOT", "1.0-SNAPSHOT" ); 
// ----------------------------------------------------------------------------------------------------  ---------------------------------------------------------------------------------------------------- 
//  cannot inherit from null parent. 
//  remove the originating artifact if it is also in managed versions to avoid being modified during resolution 
/*      * TODO share with DefaultPluginMappingManager.      */
//  enable default constructor 
//  we use a dedicated comparator because we control our model version scheme. 
//  The fall-through indicates that the artifact cannot be found; 
//  compare against each other (including itself) 
//  delete the local copy so the old details aren't used. 
//  drive-relative Windows path, don't align with base dir but with drive root 
//  used by maven-dependency-tree and maven-dependency-plugin 
//  -TC2.2 
//  Needs to go away   These are really overrides now, projects defining dependencies for a plugin that override what is
//  Plugins are aggregated if Plugin.inherit != false 
//  profile injection 
//  this block prevents MNG-1703 
//  special case: if there is a windows drive letter using |, switch to : 
//  refresh logger in case container got customized by spy 
//  read projects together 
//    Put in a bogus file to make sure missing files cause the resolution to fail. 
//  Settings files 
//  no mojo in this POM 
//  TODO Copied from the DefaultInterpolator. We likely want to resurrect the PathTranslator or at least a   similar component for re-usage 
//  make projects that depend on me, and projects that I depend on 
//  forked phase 
//  sisu uses realm imports to establish component visibility 
//  First iteration - add initial id after version resolution. 
// Needed to make this method package visible to make writing a unit test possible 
//  Inherited 
//  to avoid constant folding by the compiler, this field must *not* be final 
/*  MNG-3944 */
//  fill in domain md with actual version data 
//  reports conversion to decoupled site plugin 
//  specified in the plugin itself. 
//          
//  ------------------------------------------------------------------------     ------------------------------------------------------------------------ 
/*  MNG-4070  */
//  Servers 
/*  farthest = test  */
//  ----------------------------------------------------------------------   I would like to be able to lookup the Mojo object using a key but   we have a limitation in modello that will be remedied shortly. So   for now I have to iterate through and see what we have.   ---------------------------------------------------------------------- 
//  Maybe do something ?
/*  transformer  */
// [01] clean:clean  [02] modello:xpp3-writer  [03] modello:java  [04] modello:xpp3-reader  [05] modello:xpp3-writer  [06] modello:java  [07] modello:xpp3-reader  [08] plugin:descriptor  [09] resources:resources  [10] compiler:compile  [11] resources:testResources  [12] compiler:testCompile  [13] surefire:test  [14] jar:jar  [15] plugin:addPluginArtifactMetadata  [16] install:install   
//  ----------------------------------------------------------------------   Mojo execution   ---------------------------------------------------------------------- 
//  licenses 
//  1-0 = 1- (normalize) = 1 
//  Profiles are neither inherited nor injected 
//  don't stop processing in case a future segment explicitly excludes this repo 
/*                  * NOTE: This is a sanity check of the cache hit. If the cached parent POM was locally resolved, the                 * child's <relativePath> should point at that parent, too. If it doesn't, we ignore the cache and                 * resolve externally, to mimic the behavior if the cache didn't exist in the first place. Otherwise,                 * the cache would obscure a bad POM.                  */
//  Roles 
//  type is inherited from the super pom 
/*  farthest = provided  */
//    System scoped version which should 
//  PluginNotFoundException, PluginResolutionException, PluginDescriptorParsingException,   CycleDetectedInPluginGraphException; 
//  ----------------------------------------------------------------------   Test and compile sourceroots.   ---------------------------------------------------------------------- 
//  check all transitive deps of a test dependency are test, except test and provided which is skipped 
//  ----------------------------------------------------------------------   Profile Activation   ---------------------------------------------------------------------- 
//  make sure repeated entries are skipped 
//  flush the calculated artifactMap 
//  null case is covered by canDetermineActivation(), so we can do a straight startsWith() here. 
//  Maven 
//  for instance if package produced nothing or classifier problems. 
//  [MNG-6074] Maven should produce an error if no model version has been set in a POM file used to build an   effective model.     As of 3.4, the model version is mandatory even in raw models. The XML element still is optional in the   XML schema and this will not change anytime soon. We do not want to build effective models based on   models without a version starting with 3.4.
//  USED BY SUREFIRE, DEPENDENCY PLUGIN 
//  ChildScmUrlInheritAppendPath 
//  NOTE: Some plugins like Surefire access this field directly!
//  CHECKSTYLE_ON: LineLength   TODO Move me to Maven Shared Utils
//  Reports :: aggregate 
//  constructors ----------------------------------------------------------- 
//  enable re-resolution 
//  the metadata source looks up the default impl, so we have to trick it 
//  url normalization 
//  Also, we need to ensure that any exclusions it presents are   added to the artifact before we retrieve the metadata   for the artifact; otherwise we may end up with unwanted 
//  ignore 
//  this one should never happen in practice... 
/*          * NOTE: This provides backward-compat with maven-deploy-plugin:2.4 which bypasses the repository factory when         * using an alternative deployment location.          */
//  This will put this plugin last in the sorted map 
/*     	 *       v2    	 *   v1<    	 *       v3-v4    	 *    	  */
// TODO This prevents a cycle in the composition which shows us another problem we need to deal with.  @Requirement 
//  we cannot set this directly in the MDO due to the interactions with dependency management 
//  drive-relative Windows path, don't align with project directory but with drive root 
//         throws Exception      {          File localRepo = getLocalRepositoryPath();            ArtifactFactory factory = (ArtifactFactory) lookup( ArtifactFactory.class );          Artifact artifact = factory.createProjectArtifact( "maven", "p1", "1.0" );            ArtifactRepositoryFactory repoFactory = (ArtifactRepositoryFactory) lookup( ArtifactRepositoryFactory.class );          ArtifactRepository localArtifactRepo = repoFactory.createLocalRepository( localRepo );            MavenProject project1 = getProjectBuilder().buildFromRepository( artifact, Collections.EMPTY_LIST, localArtifactRepo );   
//  TODO should this be inside the above check? 
//  TODO this should not be allowed to be null. 
//  normalize separators 
//  this tricks plexus-component-metadata generate required metadata 
//  MNG-2123: null is a valid response to getSelectedVersion, don't
//  LOG LEVEL 
//  Deploy 
//  The build has been set but we want to step in here and fill in   values that have not been set by the child. 
/*  * Metadata for the artifact version directory of the repository. * * @author <a href="mailto:brett@apache.org">Brett Porter</a> * TODO split instantiation (versioning, plugin mappings) from definition  */
//  Now the fully interpolated model is available: reconfigure the resolver 
/*         Wait until we are sure the print-stream thread is running.          */
/*  current POM rules all, if nearest is in current pom, do not update its artifactScope  */
//  we need the null check for pre-build legacy plugins... 
//  effective model validation 
//  I'm not entirely sure about the order but this should do...
//  calculated from request attributes. 
//  this relies heavily on the equals() and hashCode() for ComponentDescriptor,   which uses role:roleHint for identity...and roleHint == goalPrefix:goal.   role does not vary for Mojos. 
/*  (non-Javadoc)     * @see org.apache.maven.profiles.ProfileManager#addProfiles(java.util.List)      */
//  Notifiers 
//  special "aliases" a, b and m for alpha, beta and milestone 
//  Type 
//  check all transitive deps of a runtime dependency are runtime scope, except for test 
//  Only select snapshots that are unresolved (eg 1.0-SNAPSHOT, not 1.0-20050607.123456) 
//     {          setGroupId( af.getGroupId() );          setArtifactId( af.getArtifactId() );          setVersion( af.getVersion() );          setType( af.getType() );          setScope( af.getScope() );          setClassifier( af.getClassifier() );          //setUri( af.getDownloadUrl() );            this.resolved = af.isResolved();      } 
//  ----------------------------------------------------------------------   Components   ---------------------------------------------------------------------- 
//  this is the unusual version string, with 'H' in the middle 
//  Exceptions 
//  look for last ANSI escape sequence to check if nextColor 
//  session may be different from rootSession seeded in DefaultMaven   explicitly seed the right session here to make sure it is used by Guice 
//  ----------------------------------------------------------------------------   Settings equivalents   ---------------------------------------------------------------------------- 
//  ----------------------------------------------------------------------   Test artifact generation for unit tests   ---------------------------------------------------------------------- 
//  ----------------------------------------------------------------------   Project building   ---------------------------------------------------------------------- 
//  dependencies. 
//  NOTE: The PluginConfigurationExpander already merged the plugin-level config in 
//  add eventual current color inherited from previous line 
//            
//  ----------------------------------------------------------------------------   I'm fully aware that the file could just be moved using File.rename but   there are bugs in various JVM that have problems doing this across   different filesystem. So we'll incur the small hit to actually copy   here and be safe. jvz.   ----------------------------------------------------------------------------
//  first pass: build without building parent. 
/*  Allow for this test running across midnight  */
//    All the parts that were taken out of MavenProject for Maven 4.0.0   
/*      * Parse maven-...-plugin.     *     * TODO move to plugin-tools-api as a default only      */
/*  MNG-4000  */
//  system scope come through unchanged... 
//    Settings in core 
//  MNG-1911 / MNG-5572: Building plugins with extensions cannot be part of reactor
//  use this if we can, but prefer the original if possible 
//  Either the original or the specified version ranges have no restrictions 
//  Archive 
//  This should probably be moved to a separate stub
//  context of the container and thus the value would be interpolated by Plexus 
/*      * @see org.codehaus.plexus.personality.plexus.lifecycle.phase.Contextualizable#contextualize(org.codehaus.plexus.context.Context)      */
//  CHECKSTYLE_ON: MagicNumber 
//  pluginArtifacts 
//  if we're in the process of building up another arg, push it and start over.   this is for the case: "-Dfoo=bar "-Dfoo2=bar two" (note the first unterminated quote) 
//  We have a prefix and goal     idea:idea 
//  Maybe also make one with LifeCycleTasks 
/*  * Allows core extensions to participate in Maven build session lifecycle. * * All callback main.methods (will) follow beforeXXX/afterXXX naming pattern to * indicate at what lifecycle point it is being called. * * @see <a href="https://maven.apache.org/examples/maven-3-lifecycle-extensions.html">example</a> * @see <a href="https://issues.apache.org/jira/browse/MNG-4224">MNG-4224</a> * @since 3.0-alpha-3  */
//  calculated. 
//  don't need a deep copy, they don't get modified or added/removed to/from - but make them unmodifiable to be 
//  ----------------------------------------------------------------------     p1 inherits from p0   p0 inherits from super model     or we can show it graphically as:     p1 ---> p0 --> super model     ---------------------------------------------------------------------- 
//  an ordinary relative path, align with project directory 
//  developers 
/*  farthest = compile  */
//    Used by Tycho and will break users and force them to upgrade to Maven 3.1 so we should really leave   this here, possibly indefinitely.   
//  papa 
//  eaten, handled by repo system 
//  MNG-5368: Log a message instead of returning 'null' silently.
/*         This will not work until the RR plugin is released to get rid of the binding to the reporting exception which is a mistake.        This happens after removing the reporting API from the core:        java.lang.NoClassDefFoundError: org/apache/maven/reporting/MavenReportException        MavenSession session = createMavenSession( getProject( "project-with-inheritance" ) );        String goal = "process";        Plugin plugin = new Plugin();        plugin.setGroupId( "org.apache.maven.plugins" );        plugin.setArtifactId( "maven-remote-resources-plugin" );        plugin.setVersion( "1.0-beta-2" );        MojoDescriptor mojoDescriptor = pluginManager.getMojoDescriptor( plugin, goal, session.getCurrentProject(), session.getLocalRepository() );        assertPluginDescriptor( mojoDescriptor, "org.apache.maven.plugins", "maven-remote-resources-plugin", "1.0-beta-2" );        MojoExecution mojoExecution = new MojoExecution( mojoDescriptor );        pluginManager.executeMojo( session, mojoExecution );         */
//  We are doing something like "mvn clean:clean" where no version is specified but this   project we are working on has the version specified in the POM so the version should come from there. 
//    If we're logging to a file then we don't want the console transfer listener as it will spew   download progress all over the place   
// ----------------------------------------------------------------------------  ---------------------------------------------------------------------------- 
//  Name 
//  This one we will eat when looking through remote repositories   because we want to cycle through them all before squawking. 
/*                  * This is purely for backward-compat with 2.x where <extensions> consisting of a single artifact where                 * loaded into the core and hence available to plugins, in contrast to bigger extensions that were                 * loaded into a dedicated realm which is invisible to plugins (MNG-2749).                  */
//  ----------------------------------------------------------------------   System properties handling   ---------------------------------------------------------------------- 
// ------------------------------------------------------------------------ 
//  MNG-6170: Only schedule other modules from reactor if we have more modules to build than one.
//  If we're processing this merge as an inheritance, we have to build up a list of   plugins that were considered for inheritance. 
//  Length 7-8 chars 
//  calculated on-demand. 
//  -----------------------------------------------------------------------------------------------   Testing help   ----------------------------------------------------------------------------------------------- 
//  TODO configure on repository 
//  same instance from spec cache 
//    Deployer 
//  -T2.2C 
// TODO remove the update check manager  TODO separate into retriever and publisher  TODO remove hardcoding of checksum logic
//  1.any < 1-1 
//  forked goal 
//  read .mvn/maven.config 
//  we're going to parse this back in as XML so we need to escape XML markup 
//  1-1 < 1.0.x 
//  goal was missing - pass through to MojoNotFoundException 
//  intentionally blank 
//  ScriptSourceDirectory 
//  reload plugin realm from cache 
//  <groupId>:<artifactId>:<version>:<goal> 
//  ReportSets 
//  added to retain compile scope. Remove if you want compile inherited as runtime
//  ISO 8601-compliant timestamp for machine readability 
//  clear the inherited flag in the merge result. 
/*     * @see org.apache.maven.artifact.resolver.conflict.ConflictResolver#resolveConflict(org.apache.maven.artifact.resolver.ResolutionNode,    *      org.apache.maven.artifact.resolver.ResolutionNode)     */
//  lower than 2^31 
//  sure! 
//  ----------------------------------------------------------------------   Top-level elements   ---------------------------------------------------------------------- 
//  We are forcing the use of the plugin realm for all lookups that might occur during   the lifecycle that is part of the lookup. Here we are specifically trying to keep   lookups that occur in contextualize calls in line with the right realm. 
//  restore activation 
/*  MNG-3925  */
/* end[MAVEN4] */
//  expected failure 
//  default over to the main project builder... 
//  remove null trailing items: 0, "", empty list 
//  classical   now b < c, but before MNG-5568, we had b > c
//  ----------------------------------------------------------------------   Delegate to the model   ---------------------------------------------------------------------- 
/*  MNG-3887  */
//  description 
//  clean 
//  case insensitive 
//  The two phases below are really for future expansion, some would say they lack a drink   The point being that they do not really have to match the "real" stuff,
//  v3-->v4 
//  for the anonymous classes 
//  MNG-2861: match version can return null
//  TODO test reversed restrictions on all below 
// ------------------------------------------------------------------------  ------------------------------------------------------------------------ 
// List<MetadataResult> resolveMetadata( RepositorySystemSession session,                                        Collection<? extends MetadataRequest> requests ); 
//    Derive these from the URL   
//  warn if it is set to anything other than ignore
//  replace activation value with interpolated value 
//  TODO 
//  edge case - single vertex graph 
//    Allow the builder to be overridden by the user if requested. The builders are now pluggable. 
//  single project build entry point 
//  The first definition wins. 
/*  MNG-3984 */
//  move on to next in r2 
//  0 at the beginning of a number has a special handling 
//  TODO Make multiple segments on projectBuildList 
//  display progress [i/n] 
//  5 January 2014 
//  invalid 
//  see if this is a negative match 
//  If people want to deploy it 
//  don't add if they are equal and one is not inclusive 
//  We have everything that we need     org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process     groupId   artifactId   version   goal   
//  Length 9 chars 
//  1-rc < 1, 1-ga > 1 
//  org.apache.maven.plugins:maven-remote-resources-plugin:1.0:process   TODO take repo mans into account as one may be aggregating prefixes of many   TODO collect at the root of the repository, read the one at the root, and fetch remote if something is missing   or the user forces the issue
//  Remove every checksum listener 
//  if we find the original, use that 
//  TestCase main.methods -------------------------------------------------------
//  if this is shorter, then invert the compare and mul with -1 
//  Build 
// based on ModeBuildingResult.validationLevel 
//  OS 
//  MNG-2199: What else to check here ?
//  Get local midnight boundary 
//  If people are going to make their own lifecycles then we need to tell people how to namespace them correctly   so that they don't interfere with internally defined lifecycles. 
//  finally add the CLI system properties 
//  layer the creation of a project builder configuration with a request, but this will need to be   a Maven subclass because we don't want to couple maven to the project builder which we need to   separate. 
/*  MNG-3937 */
//  If there is no version to be found then we need to look in the repository metadata for   this plugin and see what's specified as the latest release. 
/*  farthest = system  */
//  leading / was previously stripped 
//  not a proper url so returns false; 
//  ----------------------------------------------------------------------   MavenProjectBuilder Implementation   ---------------------------------------------------------------------- 
//  if this fails, forget about it 
//  Classifier 
/*          * NOTE: Plugins like maven-release-plugin query the path to the settings.xml to pass it into a forked Maven and         * the CLI will fail when called with a non-existing settings, so be sure to only point at actual files. Having         * a null file should be harmless as this case matches general Maven 2.x behavior...          */
//  Only used for testing 
//  fallback to loose class files only if artifacts haven't been packaged yet   and only for plain old jars. Not war files, not ear files, not anything else. 
/*  MNG-3877 */
//  new-style report configuration already present: warn since this new style has been deprecated   in favor of classical reporting section MSITE-647 / MSITE-684 
//  assertVersionOlder( "2.0.1-xyz-SNAPSHOT", "2.0.1-SNAPSHOT" ); 
//  see DOXIASITETOOLS-167 & MPIR-349 
//                                       return e2.getPomOrder() - e1.getPomOrder();                                  }                                    return e2.getDepth() - e1.getDepth();                              }                          }                      ); 
//  profile activation 
//  Now we expect the host 
//    If we have a system scoped artifact then we do not want any searching in local or remote repositories   and we want artifact resolution to only return the system scoped artifact itself.
//  When this happens we have a Maven 1.x POM, or some invalid POM.   It should have never found its way into Maven 2.x repository but it did. 
//  ----------------------------------------------------------------------   Logging   ---------------------------------------------------------------------- 
//  resembles a SNAPSHOT   10 digit number   15 digit number   20 digit number 
//  LOG COLOR 
//  Metadata cannot be found 
//  test that mojo which does not require dependency resolution trigger no downloading of dependencies 
//  Constructor 
//  prevent additional checks of this artifact until it expires again 
/*  MNG-3811 */
// void manageArtifactVersion( Artifact artifact, Artifact replacement ); 
// ---------------------------------------------------------------------------------------------------- 
//  Local repository 
//  NOTE: Backward-compat with maven-help-plugin:2.1 
//    At this point the DefaultModelBuildingListener has fired and it populates the   remote repositories with those found in the pom.xml, along with the existing externally   defined repositories.   
// ------------------------------------------------------------------ 
//    Maven4: We may want to evaluate how this is used but we add these separate as the    getExecutionProperties is deprecated in MavenSession.   
//  ----------------------------------------------------------------------   Reactor Make Mode   ---------------------------------------------------------------------- 
//  this is the default behavior. 
//  The CLI should win for defining properties 
//  ----------------------------------------------------------------------   The local repository for this category of tests   ---------------------------------------------------------------------- 
//  After the collection we will have the artifact object in the result but they will not be resolved yet.
//  move on to next in r1 
//  This will catch cases like <version></version> or <version/> 
//  since this list is a local one, and may have been modified during processing. 
//  works, but we don't fail on cycles presently 
//  Message below is checked for in the MNG-4463 core IT. 
//  helper to determine if problems contain error 
// assuming Type is available in current ClassLoader 
//  enable no-arg constructor 
//  ----------------------------------------------------------------------------   Request   ---------------------------------------------------------------------------- 
//  ----------------------------------------------------------------------   Accessors   ---------------------------------------------------------------------- 
//  TODO use newest conflict resolver 
//  These are cases where the artifact just isn't present in any of the remote repositories   because it wasn't deployed, or it was deployed in the wrong place.
//    Ignore   
//  this is expected 
//  NOTE: Order counts here! 
//  Relocation 
//  No, this does not print to system.out. It's part of the test 
//  Ensure it is not printed as 1.5.0 
//  have been resolved. 
//    Implementation   
//  and catch here rather than have it return null
//  groupId:artifactId -> (version -> vertex) 
//  to delete on exit 
/*          * This provides backward-compat with 2.x that allowed plugins like the maven-remote-resources-plugin:1.0 to         * populate the builder configuration with model repositories instead of artifact repositories.          */
//  no edges - nothing to worry about 
// no inspection unchecked
//  We are doing something like "mvn resources:resources" where no version is specified but this   project we are working on has the version specified in the POM so the version should come from there. 
//  assertVersionEqual( "2.0-0-SNAPSHOT", "2.0-SNAPSHOT" ); 
//  do nothing for now 
//  sanity checks 
//  default: batch mode which goes along with interactive   default: false   default: false   default: warn 
//  Don't consider the artifact's version in here, as this is stored in the directory above that 
//    Parsing errors can happen during the processing of the arguments and we prefer not having to check if   the logger is null and construct this so we can use an SLF4J logger everywhere.   
//  lifecycle bindings injection 
//  muxer.associateThreadWithProjectSegment( projectBuild ); 
//  We have everything that we need except the version     org.apache.maven.plugins:maven-remote-resources-plugin:???:process     groupId   artifactId   ???   goal   
//  TODO figure out way to avoid duplicated message 
//  ------------------------------------------------------------------------   Version Range Violations   ------------------------------------------------------------------------ 
//  MNG-2123: if the previous node was not a range, then it wouldn't have any available   versions. We just clobbered the selected version above. (why? i have no idea.)   So since we are here and this is ranges we must go figure out the version (for a   third time...)
//  Pre-store the checksums as any future puts will overwrite them 
//  indications to use these in comparison 
//  default cache does not track record usage 
//  don't log it. 
/*          * NOTE: Metadata at the g:a level contains a collection of available versions. After merging, we can't tell         * which repository provides which version so the metadata manager must not restrict the artifact resolution to         * the repository with the most recent updates.          */
//  
//  version 
//  the test in question and vice versa. A little Eclipse plugin would do the trick. 
//  entry point 
//  now - drop vertices 
//  ModelBase 
//  if it already exists locally we were just trying to force it - ignore the update
//  parentData.setModel( interpolatedParent ); 
//  We don't consider the version range in the comparison, just the resolved version 
/*          * Grab plugin executions that are bound to the selected lifecycle phases from project. The effective model of         * the project already contains the plugin executions induced by the project's packaging type. Remember, all         * phases of interest and only those are in the lifecycle mapping, if a phase has no value in the map, we are         * not interested in any of the executions bound to it.          */
//  <mirrors>     <mirror>       <id>nexus</id>       <mirrorOf>*</mirrorOf>       <url>http://repository.sonatype.org/content/groups/public</url>     </mirror>   </mirrors> 
//  This should take care of creating destination directory now on
// -----------------------------------------------------------------------  ----------------------------------------------------------------------- 
// void manageArtifactScope( Artifact artifact, Artifact replacement ); 
//  really don't care if it failed here only log warning 
/*          * Initialize mapping from lifecycle phase to bound mojos. The key set of this map denotes the phases the caller         * is interested in, i.e. all phases up to and including the specified phase.          */
//  for each exception   - knowing what artifacts are missing   - project building exception   - invalid project model exception: list of markers   - xmlpull parser exception 
//  Goals 
//  We want to send the root artifact back in the result but we need to do this after the other dependencies 
//  JDK8: this should be a call to map.merge( key, v, remapping ) 
//  CHECKSTYLE_OFF: LineLength 
//  SourceDirectory 
/*  MNG-3827 */
//  grab it first, because it's about to change... 
//  Version 
// SyncContext newSyncContext( RepositorySystemSession session, boolean shared ); 
//  If it was optional and not a direct dependency,   we don't add it or its children, just allow the update of the version and artifactScope 
//  MNG-2861: the artifact data has changed. If the available versions where previously   retrieved, we need to update it.
//  should never happen because attributes have no children 
//  Will show up last in the sorted map 
//  DownloadUrl 
//  NOTE: The upper-case packaging name is intentional, that's a special hinting mode used for certain tests 
//  ----------------------------------------------------------------------   Local repository   ---------------------------------------------------------------------- 
//  Content 
//  Property 
//  Scm 
//  don't pull in the transitive deps of a system-scoped dependency. 
//  Offline 
//  TODO take repo mans into account as one may be aggregating prefixes of many   TODO collect at the root of the repository, read the one at the root, and fetch remote if something is missing   or the user forces the issue
/*  MNG-3906 */
//  Intentionally notNull because Super POM may not contain a modelId 
//  modelVersion is neither inherited nor injected 
//    Artifact Repository Creation 
//  default cache does not track plugin usage 
//  Install 
//  This means a module which is build has a dependency which has the same   groupId, artifactId, version and classifier coordinates. This is in consequence   a self reference or in other words a circular reference which can not being resolved.
//  These main.methods deal with construction intact Plugin object that look like they come from a standard   <plugin/> block in a Maven POM. We have to do some wiggling to pull the sources of information   together and this really shows the problem of constructing a sensible default configuration but   it's all encapsulated here so it appears normalized to the POM builder.
//  Logging 
//  --------------------------------------------------------------------- 
//  groupId:artifactId:version -> project 
//  resolve plugin version as necessary 
//  no ide workspace artifact resolution 
//  to define the version via command line: mvn -Drevision=6.5.7 ... 
//  explicitly exclude. Set result and stop processing. 
//  model interpolation 
//  check for 'ALGO (name) = CHECKSUM' like used by openssl 
//  used by the Maven ITs 
//  MNG-4488 where let invalid parents slide on by
//  clone properties modifyable by plugins in a forked lifecycle 
//  default (or at least some of them) 
/*  MNG-3886 */
//    These settings values need to be removed and pushed down into a provider of configuration information   
//  Version mediation 
//  ArtifactFactory 
//  plugins configuration 
//  ----------------------------------------------------------------------   Properties containing info about the currently running version of Maven   These override any corresponding properties set on the command line   ---------------------------------------------------------------------- 
//  We need to eat any quotes surrounding arguments... 
//  relative path, e.g. "sub", "../sub" or "." 
//  direct dependency retains its scope 
//  prepare 
//  correct 
//  no op 
//  NOTE: The lifecycle order can affect implied execution ids so we better be deterministic. 
//  issueManagement 
//  Locally installed file is newer, don't use the resolved version 
//  Configuration 
//  test restricting empty sets 
//  Proxies 
//  NOTE: To avoid inconsistencies, we'll use the TCCL exclusively for lookups 
//    Desired order of precedence for local artifact repositories     Reactor   Workspace   User Local Repository 
//  Currently disabled 
//  CHECKSTYLE_ON: LineLength 
//     /**       * Returns a list of {@link java.io.File}s which represents the bootstrap libraries for the       * runtime environment. The Bootstrap libraries include libraries in JRE's       * extension directory, if there are any.       *       * @return List       */      List getBootstrapLibraries();        /**       * Returns a list of {@link java.io.File}s which represent the libraries recognized by       * default by the platform. Usually it corresponds to contents of CLASSPATH       * environment variable.       *       * @return List       */      List getStandardLibraries();        /**       * Returns a {@link java.io.File}s which represent the locations of the source of the JDK,       * or an empty collection when the location is not set or is invalid.       *       * @return List       */      List getSourceDirectories();        /**       * Returns a {@link java.io.File}s which represent the locations of the Javadoc for this platform,       * or empty collection if the location is not set or invalid       *       * @return List       */      List getJavadocFolders(); 
//  Here we will actually not have any artifacts because the ProjectDependenciesResolver is not involved here. So   right now it's not valid to ask for artifacts unless plugins require the artifacts. 
//  model normalization 
//  this case is not specified, might also return -1 
//  if the POM didn't exist, retry if any repo is configured to always update 
//  path is already absolute, we're done 
//  Message below is checked for in the MNG-2199 core IT. 
//  should never happen since checked isDigits(s) before  
//  Prerequisites are neither inherited nor injected 
//  USED BY MAVEN ASSEMBLY PLUGIN 
//  set the recommended version 
//  Description 
// This will fail on a validation error if incorrect 
/*     public int containerCountForUri( String uri )        throws IOException    {        Validate.notEmpty( uri, "uri can neither be null nor empty " );        ModelDataSource source = new DefaultModelDataSource();        source.init( domainModel.getModelProperties(), null );        return source.queryFor( uri ).size();    }	 */
//  ignore if failed as we will overwrite 
/*  * A conflict resolver factory that obtains instances from a plexus container. * * @author <a href="mailto:markhobson@gmail.com">Mark Hobson</a> * TODO you don't need the container in here with the active maps (jvz). * @since 3.0  */
//  Parent is added as an edge, but must not cause a cycle - so we remove any other edges it has   in conflict 
//  ChildProjectUrlInheritAppendPath 
/*  avoid modifying the managed Versions parameter creating a new map  */
//  record the error and mark the project as failed 
/*  (non-Javadoc)    * @see org.apache.maven.profiles.ProfileManager#addProfile(org.apache.maven.model.Profile)     */
/*  parent  */
//  GroupId 
//  TODO into artifactScope handler 
//  Add the root artifact (as the first artifact to retain logical order of class path!) 
//  Value 
//  modify parent 
//  check for external:* 
//  release artifact repository 
/* MNG-3938 */
//  ----------------------------------------------------------------------   Configuration   ---------------------------------------------------------------------- 
//  TestOutputDirectory 
// ------------------------------------------------------------------------------------------  ------------------------------------------------------------------------------------------ 
// VersionResult resolveVersion( RepositorySystemSession session, VersionRequest request )                  throws VersionResolutionException; 
//    These are the only main.methods we need in our primordial logger
/*  farthest is runtime and nearest has lower priority, change to runtime  */
//  extensions realm is expected to be fully setup at this point   any exception means a problem in maven code, not a user error 
//  default 
// TODO completely separate local and remote artifact repositories 
//  remove everything after the first space (if available) 
//  Excludes 
//    The request has not set any local or remote repositories as the system scoped dependency being resolved should only   give us the dependency off the disk and nothing more. 
//  used by maven-dependency-tree 
//  ChildScmDeveloperConnectionInheritAppendPath 
//  continue the build but ban all projects that depend on the failed one 
//  expected 
//  If this child node is a managed dependency, ensure   we are using the dependency management version   of this child if applicable b/c we want to use the   managed version's POM, *not* any other version's POM. 
//  Here, we need to determine which policy to use. Release updateInterval will be used when   the metadata refers to a release artifact or meta-version, and snapshot updateInterval will be used when   it refers to a snapshot artifact or meta-version.   NOTE: Release metadata includes version information about artifacts that have been released, to allow   meta-versions like RELEASE and LATEST to resolve, and also to allow retrieval of the range of valid, released   artifacts available. 
//  verify a few typical parameters are not duplicated 
//  There is only a single threadsafe plugin here... 
/*  MNG-3864 */
//  -------------------------------------------------------------------------------------   ------------------------------------------------------------------------------------- 
//  consider the username&password because a repo manager might block artifacts depending on authorization 
//  Use the original recommended version since it exists 
//  This is like a filter but overrides all transitive versions 
//  Can be both "LifeCycleTask" (clean/install) and "GoalTask" (org.mortbay.jetty:maven-jetty-plugin:6.1.19:run) 
//  process the list 
//  a Maven 1.x pom will not even   update the resource if we stop supporting modelVersion 4.0.0 
//  guard against case where best-effort resolution for invalid models is requested 
//                                 { 
//  neither inherited nor injected 
//  NOI18N 
//  the default execution path only knows the DefaultModelProblemCollector,   only reason it's not in signature is because it's package private 
//  this block verifies MNG-1703
/* MNG-3995 */
//  ------------------------------------------------------------------------   Local Repository     1. Use a value has been passed in via the configuration   2. Use value in the resultant settings   3. Use default value   ------------------------------------------------------------------------ 
//  FinalName 
//  consider the URL (instead of the id) as this most closely relates to the contents in the repo 
//  Phase 
//  no separator between number and character 
// NOI18N 
//  All projects are the statics from this class 
//  Executions 
//  dependency management injection 
//  expected failure: wrong relative path calculation
//  restore profiles with file activation to their value before full interpolation 
//  if we're processing this as an inheritance-based merge, and   the parent's <inherited/> flag is not set, then we need to 
/*  MNG-1995  */
//  relocated dependency artifact is declared excluded, no need to add and recurse   further 
//  default cache does not track extension usage 
//  carry on 
//  draw the NPE. 
//  beware meta-versions! 
//  extensionArtifacts 
//  save profile activations before interpolation, since they are evaluated with limited scope 
//  The parent version may have resolved to something different, so we take what we asked for...   instead of - child.setVersion( parent.getVersion() ); 
//  We are going to take the project packaging and find all plugins in the default lifecycle and create   fully populated Plugin objects, including executions with goals and default configuration taken   from the plugin.xml inside a plugin.   
// noinspection SimplifiableIfStatement 
//  So now we have an url of the form file://<path> 
//  execute 
//  test a build where projects use different versions of the same plugin 
// mkleint: does this need to be public?
//  if the phase is specified then I don't have to go fetch the plugin yet and pull it down   to examine the phase it is associated to. 
//  Resources 
//  Url 
//  USED BY INVOKER PLUGIN 
/*  parentImports  */
//  reinstate the download monitor... 
//  if this IS NOT a ChecksumFailedException, it was a problem with transfer/read of the checksum   file...we'll try again with the MD5 checksum. 
//  can't happen 
/*  farthest is compile and nearest is not (has lower priority), change to compile  */
//  Timing (remove this) 
//  Filtering 
//  assume it is not assignable from Collection or Map 
//  TestResources 
//  This test verifies the baseline structure used in subsequent tests. If this fails, the rest will fail. 
/*  MNG-3943 */
//  when model is read from repo, a stream is used, then pomFile == null   (has consequences in inheritance algorithm since getProjectDirectory() returns null) 
//  we need to get the latest file for the project, not the artifact that was created at one point in time
/* MNG-3803 */
//  make a copy so the original in the POM doesn't get messed with 
//  fix for MNG-2221 (assembly cache was not being populated for later reference): 
//  USED BY MAVEN HELP PLUGIN 
//  mailingLists 
//  Attributes 
//  Extensions 
//  ------------------------------------------------------------------------   Artifact Transfer Mechanism   ------------------------------------------------------------------------ 
/*                             NOTE: Users occasionally misuse the id "local" for remote repos which screws up the metadata                            of the local repository. This is especially troublesome during snapshot resolution so we try                            to handle that gracefully.                              */
//  1.0 == 1, 1.1 > 1 
//  this has to be a separate "if" statement, to capture the case of: "-Dfoo=bar" 
//  if we catch a ChecksumFailedException, it means the transfer/read succeeded, but the    checksum doesn't match. This could be a problem with the server (ibiblio HTTP-200 error   page), so we'll try this up to two times. On the second try, we'll handle it as a bona-fide   error, based on the repository's checksum checking policy. 
//  older wagons throw this. Just get() instead 
//  same instance from version cache 
// TODO turn an equivalent back on when the RR plugin is released. 
//  SystemPath 
//  If file could not be found or was not valid, start from scratch 
/*                      * NOTE: We intentionally only support ${basedir} and not ${project.basedir} as the latter form                     * would suggest that other project.* expressions can be used which is however beyond the design.                      */
//  an ordinary relative path, align with base dir 
//  build the regular repos after extensions are loaded to allow for custom layouts 
//  Email 
//  protected main.methods ------------------------------------------------------
//  !final 
//  just to make sure all the bases are covered... 
//  ConflictResolver main.methods -----------------------------------------------
//  simple checks first to short circuit processing below. 
//  TODO this checking for file == null happens because the resolver has been confused about the root 
//  For a given project packaging find all the plugins that are bound to any registered   lifecycles. The project builder needs to now what default plugin information needs to be   merged into POM being built. Once the POM builder has this plugin information, versions can be assigned   by the POM builder because they will have to be defined in plugin management. Once this is setComplete then it   can be passed back so that the default configuration information can be populated.     We need to know the specific version so that we can lookup the right version of the plugin descriptor   which tells us what the default configuration is.   
/*  (non-Javadoc)    * @see org.apache.maven.profiles.ProfileManager#explicitlyDeactivate(java.util.List)     */
/*          * Determine the lifecycle that corresponds to the given phase.          */
/*          * Probably is not worth it, but here I make sure I restore request         * to its original state.          */
//  default does nothing 
//  1-1 > 1-sp 
//  Length 7 chars 
//  if the POM has no file, we cached a missing artifact, only return the cached data if no update forced 
//  local wins now, and irrelevant if not local as test/provided aren't transitive   assertEquals( "Check artifactScope", Artifact.SCOPE_COMPILE, artifact.getArtifactScope() ); 
/*  MNG-3899  */
//  Before we update the version of the artifact, we need to know   whether we are working on a transitive dependency or not. This   allows depMgmt to always override transitive dependencies, while   explicit child override depMgmt (viz. depMgmt should only   provide defaults to children, but should override transitives).   We can do this by calling isChildOfRootNode on the current node. 
//  We leave in optional ones, but don't pick up its dependencies 
/*  MNG-2174  */
// TODO used by the Enforcer plugin 
//  org.eclipse:emf:2.3.0-v200706262000   org.eclipse.wst.common_core.feature_2.0.0.v200706041905-7C78EK9E_EkMNfNOd2d8qq 
//  Filters 
//  Just hide the one method we want behind the RepositorySystem interface. 
/*  MNG-2174 */
//  The temporary file is named destination + ".tmp" and is done this way to ensure   that the temporary file is in the same file system as the destination because the   File.renameTo operation doesn't really work across file systems.   So we will attempt to do a File.renameTo for efficiency and atomicity, if this fails   then we will use a brute force copy and delete the temporary file. 
//  snapshot artifact repository 
//  don't allow construction. 
//  ----------------------------------------------------------------------   Artifact repository policies   ---------------------------------------------------------------------- 
//  bad url just skip it here. It should have been validated already, but the wagon lookup will deal with it 
//    Customizations available via the CLI   
//  Map types of artifacts 
//  create and cache extensions realms 
//  make copy to get rid of needless overhead for dynamic lookups 
//  ----------------------------------------------------------------------   Now that we have everything that we need we will fire up plexus and   bring the maven component to life for use.   ---------------------------------------------------------------------- 
